<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>费罗里</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-04T13:42:22.941Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Oliver</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>django搭建</title>
    <link href="http://yoursite.com/2020/04/03/django%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2020/04/03/django%E6%90%AD%E5%BB%BA/</id>
    <published>2020-04-03T15:51:15.000Z</published>
    <updated>2020-04-04T13:42:22.941Z</updated>
    
    <content type="html"><![CDATA[<p>搭建django的一些坑</p><a id="more"></a><h5 id="1-下载安装python"><a href="#1-下载安装python" class="headerlink" title="1. 下载安装python"></a>1. 下载安装python</h5><p>3.4以上新版python下载后自带pip，pip根据提示自我更新</p><h5 id="2-用python-的pip管理器去下载django"><a href="#2-用python-的pip管理器去下载django" class="headerlink" title="2. 用python 的pip管理器去下载django"></a>2. 用python 的pip管理器去下载django</h5><p>注意pip 和 django  和python 的版本</p><p>注意 pip 自我更新 和下载django的时候，报错重来，多下几次。</p><h5 id="3-配置django环境变量"><a href="#3-配置django环境变量" class="headerlink" title="3. 配置django环境变量"></a>3. 配置django环境变量</h5><p>在path中加入两个 一个是到script 一个是到bin</p><h5 id="4-下载安装pycharm社区版（官网）"><a href="#4-下载安装pycharm社区版（官网）" class="headerlink" title="4. 下载安装pycharm社区版（官网）"></a>4. 下载安装pycharm社区版（官网）</h5><p>目前双击打不开，用cmd可以输入pycharm打开，命令不能关</p><h5 id="5-pycharm-设置背景颜色-字体大小"><a href="#5-pycharm-设置背景颜色-字体大小" class="headerlink" title="5. pycharm 设置背景颜色 字体大小"></a>5. pycharm 设置背景颜色 字体大小</h5><p>settings里面的</p><h5 id="6-project-interpreter"><a href="#6-project-interpreter" class="headerlink" title="6. project interpreter"></a>6. project interpreter</h5><p>在settings -&gt; Project 中添加 python</p><h5 id="7-django项目要添加python-exe"><a href="#7-django项目要添加python-exe" class="headerlink" title="7. django项目要添加python.exe"></a>7. django项目要添加python.exe</h5><h5 id="8-在下面-的-Terminal终端中执行"><a href="#8-在下面-的-Terminal终端中执行" class="headerlink" title="8. 在下面 的 Terminal终端中执行"></a>8. 在下面 的 Terminal终端中执行</h5><p>python manage.py runserver 开启服务器，django自带一个小型服务器，自动开启8000端口号。可在settings文件中更改</p><h5 id="9-python-3-x和2-x"><a href="#9-python-3-x和2-x" class="headerlink" title="9. python 3.x和2.x"></a>9. python 3.x和2.x</h5><p>两个版本是由差距的，会影响django还有一些依赖插件比如pymysql是3.x用的</p><h5 id="10-接口测试时Forbidden-CSRF-cookie-not-set"><a href="#10-接口测试时Forbidden-CSRF-cookie-not-set" class="headerlink" title="10. 接口测试时Forbidden (CSRF cookie not set.)"></a>10. 接口测试时Forbidden (CSRF cookie not set.)</h5><p>可以去settings里面 MIDDLEWARE = [ 那个csrf. ]  注释掉</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Create your views here.</span></span><br><span class="line"><span class="keyword">from</span> django.views.decorators.csrf <span class="keyword">import</span> csrf_exempt</span><br><span class="line"> </span><br><span class="line"><span class="meta">@csrf_exempt </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_api</span><span class="params">(request)</span>:</span></span><br><span class="line">    dic = &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'GET'</span>:</span><br><span class="line">        dic[<span class="string">'message'</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(json.dumps(dic))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        dic[<span class="string">'message'</span>] = <span class="string">'方法错误'</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(json.dumps(dic, ensure_ascii=<span class="literal">False</span>))</span><br><span class="line">    </span><br><span class="line"> <span class="comment"># 这里是views里面的一个如何返回类似json文件的例子</span></span><br><span class="line"> <span class="comment"># 这样 就可以 简单的实现写views 不用管渲染的部分</span></span><br></pre></td></tr></table></figure><h5 id="11-ajax-简单传值"><a href="#11-ajax-简单传值" class="headerlink" title="11. ajax 简单传值"></a>11. ajax 简单传值</h5><img src="/2020/04/03/django%E6%90%AD%E5%BB%BA/d1.png" class><h5 id="12-Django-中-request方法"><a href="#12-Django-中-request方法" class="headerlink" title="12. Django 中 request方法"></a>12. Django 中 request方法</h5><p>request.session</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">请求的路径，这里的路径是指相对路径，也就是说一个登陆后台页面的请求：http:&#96;&#96;&#x2F;&#96;&#96;&#x2F;&#96;&#96;127.0&#96;&#96;.&#96;&#96;0.1&#96;&#96;:&#96;&#96;8000&#96;&#96;&#x2F;&#96;&#96;admin 的路径是 &#96;&#96;&#x2F;&#96;&#96;admin</span><br><span class="line">获取完整路径（包括参数）：HttpRequest.get_full_path()</span><br><span class="line">获取绝对url： HttpRequest.bulid_absolute_uri(location) 此参数默认为完整路径</span><br></pre></td></tr></table></figure><p>request.encoding</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请求提交的数据的编码方式</span><br></pre></td></tr></table></figure><p> request.session</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">request.session 获取的是一个类似于字典的对象，可以进行读取写入操作，常用来保存一些数据来实现会话跟踪技术。 因为 HTTP 是一个无状态，不连续的协议。如果想让服务器记住当前的访问对象，就需要记录请求者的一些信息来达到这个目的。</span><br><span class="line"># 设置session&#96;&#96;request.session[&#96;&#96;&quot;name&quot;&#96;&#96;] &#96;&#96;&#x3D;&#96; &#96;&quot;root&quot;&#96;&#96;# 获取session&#96;&#96;name &#96;&#96;&#x3D;&#96; &#96;request.sessin[&#96;&#96;&quot;name&quot;&#96;&#96;]</span><br></pre></td></tr></table></figure><p>django会默认为session使用json序列化。json序列化只能序列化一些基本数据类型，如数字，字符串，列表等。所以session不能直接存储对象.可以简单的在settings中添加 SESSION_SERIALIZER = “django.contrib.sessions.serializers.PickleSerializer”</p><p>request.method   请求方式POST/GET</p><h5 id="13-request获取数据"><a href="#13-request获取数据" class="headerlink" title="13. request获取数据"></a>13. request获取数据</h5><p>request.body</p><p>请求的主体，返回一个字符串</p><p>request.data</p><p>请求数据部分，返回一个字典对象，其他和request.body很想</p><p><strong>request.POST</strong></p><p>获取post方式表单中提交的数据</p><p>request.POST[“username”]</p><p>request.POST.get（“username”）</p><p>request.GET</p><p>获取get方式表单中或url提交的数据</p><p>request.GET[“username”]</p><p>request.GET.get（“username”）</p><h5 id="14-postman请求"><a href="#14-postman请求" class="headerlink" title="14. postman请求"></a>14. postman请求</h5><p>请求post时，在body里面写参数！！</p><p>请求get时，在params里面写参数！！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;搭建django的一些坑&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Django" scheme="http://yoursite.com/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>前端UI框架小总结</title>
    <link href="http://yoursite.com/2020/04/01/%E5%89%8D%E7%AB%AFUI%E6%A1%86%E6%9E%B6%E5%B0%8F%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/04/01/%E5%89%8D%E7%AB%AFUI%E6%A1%86%E6%9E%B6%E5%B0%8F%E6%80%BB%E7%BB%93/</id>
    <published>2020-04-01T09:42:36.000Z</published>
    <updated>2020-04-01T09:55:19.724Z</updated>
    
    <content type="html"><![CDATA[<p>收集前端UI框架 包括移动端 PC端的官网</p><a id="more"></a><hr><blockquote><h4 id="移动端UI框架"><a href="#移动端UI框架" class="headerlink" title="移动端UI框架"></a>移动端UI框架</h4></blockquote><h5 id="Mint-UI（饿了么团队）"><a href="#Mint-UI（饿了么团队）" class="headerlink" title="Mint UI（饿了么团队）"></a><strong>Mint UI（饿了么团队）</strong></h5><p>中文官网：<a href="http://mint-ui.github.io/#!/zh-cn" target="_blank" rel="noopener">http://mint-ui.github.io/#!/zh-cn</a></p><p>描述：基于vue的移动端UI框架<br>基于vue</p><p>GitHub地址：<a href="https://github.com/ElemeFE/mint-ui/" target="_blank" rel="noopener">https://github.com/ElemeFE/mint-ui/</a></p><h5 id="Weui（微信官方设计团队）"><a href="#Weui（微信官方设计团队）" class="headerlink" title="Weui（微信官方设计团队）"></a>Weui（微信官方设计团队）</h5><p>描述：WeUI 为微信 Web 服务量身设计,是一套同微信原生视觉体验一致的基础样式库，由微信官方设计团队为微信 Web 开发量身设计，可以令用户的使用感知更加统一。</p><p>GitHub地址：<a href="https://github.com/weui/weui" target="_blank" rel="noopener">https://github.com/weui/weui</a></p><h5 id="Pure"><a href="#Pure" class="headerlink" title="Pure"></a>Pure</h5><p>中文官网：<a href="https://www.purecss.cn/" target="_blank" rel="noopener">https://www.purecss.cn/</a><br>描述：纯CSS<br>美国雅虎公司出品的一组轻量级、响应式纯css模块，适用于任何Web项目。<br>GitHub：<a href="https://github.com/yahoo/pure/" target="_blank" rel="noopener">https://github.com/yahoo/pure/</a></p><blockquote><h4 id="PC-端-UI框架"><a href="#PC-端-UI框架" class="headerlink" title="PC 端 UI框架"></a><strong>PC 端 UI框架</strong></h4></blockquote><h5 id="Element-UI（饿了么团队）"><a href="#Element-UI（饿了么团队）" class="headerlink" title="Element UI（饿了么团队）"></a>Element UI（饿了么团队）</h5><p>官方地址：<a href="http://element-cn.eleme.io/#/zh-CN" target="_blank" rel="noopener">http://element-cn.eleme.io/#/zh-CN</a><br>描述：基于 Vue 2.0 的桌面端组件库<br>GitHub：<a href="https://github.com/ElemeFE/element" target="_blank" rel="noopener">https://github.com/ElemeFE/element</a></p><h5 id="iView"><a href="#iView" class="headerlink" title="iView"></a>iView</h5><p>官网地址：<a href="https://www.iviewui.com/" target="_blank" rel="noopener">https://www.iviewui.com/</a><br>描述：一套基于 Vue.js 的高质量 UI 组件库。iView 是一套基于 Vue.js 的开源 UI 组件库，主要服务于 PC 界面的中后台产品。<br>GitHub地址：<a href="https://github.com/iview/iview" target="_blank" rel="noopener">https://github.com/iview/iview</a></p><h5 id="layui"><a href="#layui" class="headerlink" title="layui"></a>layui</h5><p>官方地址：<a href="http://www.layui.com/" target="_blank" rel="noopener">http://www.layui.com/</a></p><p>描述：更多是为服务端程序员量身定做，你无需涉足各种前端工具的复杂配置，只需面对浏览器本身，让一切你所需要的元素与交互，从这里信手拈来。</p><p>layui 兼容人类正在使用的全部浏览器（IE6/7除外），可作为 PC 端后台系统与前台界面的速成开发方案。</p><p>GitHub：<a href="https://github.com/sentsin/layui/" target="_blank" rel="noopener">https://github.com/sentsin/layui/</a></p><h5 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h5><p>中文官网：<a href="http://www.bootcss.com/" target="_blank" rel="noopener">http://www.bootcss.com/</a><br>描述：简洁、直观、强悍的前端开发框架，让web开发更迅速、简单。</p><p>GitHub地址：<a href="https://github.com/twbs/bootstrap" target="_blank" rel="noopener">https://github.com/twbs/bootstrap</a></p><h5 id="jQuery-UI"><a href="#jQuery-UI" class="headerlink" title="jQuery UI"></a>jQuery UI</h5><p>官方网址：<a href="http://jqueryui.com/" target="_blank" rel="noopener">http://jqueryui.com/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;收集前端UI框架 包括移动端 PC端的官网&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="UI" scheme="http://yoursite.com/tags/UI/"/>
    
  </entry>
  
  <entry>
    <title>网络安全之攻守道</title>
    <link href="http://yoursite.com/2020/03/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B9%8B%E6%94%BB%E5%AE%88%E9%81%93/"/>
    <id>http://yoursite.com/2020/03/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B9%8B%E6%94%BB%E5%AE%88%E9%81%93/</id>
    <published>2020-03-30T00:40:51.000Z</published>
    <updated>2020-03-30T08:27:30.645Z</updated>
    
    <content type="html"><![CDATA[<p>网络安全，就是攻守之间的对抗</p><a id="more"></a><blockquote><p>学习地址指路 <a href="https://www.bilibili.com/video/BV1yW411q7GF" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1yW411q7GF</a></p></blockquote><h5 id="Http-传输数据存在的问题"><a href="#Http-传输数据存在的问题" class="headerlink" title="Http 传输数据存在的问题"></a>Http 传输数据存在的问题</h5><p>http协议传输，超文本传输协议HTTP协议被用于在Web浏览器和网络服务器之间传递信息。HTTP协议以明文方式发送内容，不提供任何方式的数据加密。所以如果黑客截取了Web浏览器和网站服务器之间的传输报文，就可以直接读取重要信息（密码 账号 卡号等）。</p><h5 id="Https-简介"><a href="#Https-简介" class="headerlink" title="Https 简介"></a>Https 简介</h5><p>https协议，安全套接字层超文本传输协议HTTPS。是在HTTP的基础上加了SSL（Secure，Sockets，Layer，安全套接字层）。SSL依靠证书来验证服务器的身份，为浏览器和服务器之间的通信加密。</p><img src="/2020/03/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B9%8B%E6%94%BB%E5%AE%88%E9%81%93/w1.png" class><h5 id="Https-和Http-的区别"><a href="#Https-和Http-的区别" class="headerlink" title="Https 和Http 的区别"></a>Https 和Http 的区别</h5><ol><li>https协议需要到 ca 申请证书，一般都要收费</li><li>http是超文本传输协议，信息是明文传输，连接很简单，https协议是由SSL+HTTP协议构建的 可进行 加密传输、身份认证的网络协议。安全性更高</li><li>http 和 https 使用的是完全 不同 的连接方式，用的端口不一样。前者是 80 端口，后者是 443</li></ol><h5 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a><a href="https://baike.sogou.com/v214573.htm?fromTitle=ssl" target="_blank" rel="noopener">SSL</a></h5><ol><li><p>定义</p><p>SSL(Secure Sockets Layer<a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=7628534&ss_c=ssc.citia" target="_blank" rel="noopener">安全套接层</a>,及其继任者<a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=25967&ss_c=ssc.citiao.link" target="_blank" rel="noopener">传输层安全</a>（<a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=101608365&ss_c=ssc.citiao.link" target="_blank" rel="noopener">Transport</a> Layer Security，TLS）是为网络通信提供安全及<a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=340077&ss_c=ssc.citiao.link" target="_blank" rel="noopener">数据完整性</a>的一种安全协议。TLS与SSL在传输层与<a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=16954&ss_c=ssc.citiao.link" target="_blank" rel="noopener">应用层</a>之间对网络连接进行加密。</p></li><li><p>作用</p><p>认证用户和服务器，确保数据发送到正确的 客户机 和 服务器；</p><p>加密数据以防止数据中途被窃取；</p><p>维护数据的完整性，确保数据在传输过程中不被改变。</p></li><li><p>服务器类型</p><ol><li><p>Tomcat 5.x</p></li><li><p>Nginx</p></li><li><p>IIS</p></li><li><p>Apache 2.x</p></li><li><p>IBM HTTP SERVER 6.0</p></li></ol></li></ol><h5 id="SSL-安全加密方式"><a href="#SSL-安全加密方式" class="headerlink" title="SSL 安全加密方式"></a>SSL 安全加密方式</h5><p>了解加密方式，分为对称加密和非对称加密</p><ol><li>对称加密(Symmetric Cryptography)<ul><li>原理：加密算法是公开的，靠的是密钥来加密数据；使用一个密钥加密，使用相同的密钥解密</li><li>常用对称加密算法：DES,  3DES， AES(破解难度大)</li><li>注意：在传输加密数据之前，需要传递密钥</li><li><img src="/2020/03/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B9%8B%E6%94%BB%E5%AE%88%E9%81%93/w4.png" class></li><li><img src="/2020/03/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B9%8B%E6%94%BB%E5%AE%88%E9%81%93/w2.png" class></li></ul></li><li>对称加密优缺点<ul><li>优点：计算量较小，加密和解密的速度比较快，适合加密比较大的数据</li><li>缺点：密钥的传输容易泄露；一个用户需要对应一个密钥，服务器管理密钥比较麻烦</li></ul></li><li>非对称加密<ul><li>原理：算法公开，一个公钥(public key)和一个私钥(private key)。 公钥加密只能私钥解密；私钥加密只能公钥解密，加密和解密的钥匙不同，即非对称加密</li><li>常用非对称加密算法：RSA</li><li>注意：公钥私钥需要加密算法生成</li><li><img src="/2020/03/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B9%8B%E6%94%BB%E5%AE%88%E9%81%93/w3.png" class></li></ul></li><li>非对称加密优缺点<ul><li>优点：加密和解密使用不同钥匙，可以传输公钥，数据传输是安全的</li><li>缺点：计算量大，加密解密速度较慢</li></ul></li></ol><h5 id="Https-传输"><a href="#Https-传输" class="headerlink" title="Https 传输"></a>Https 传输</h5><p>Https加密、解密及验证过程，两种加密方式结合使用</p><p>先使用非对称加密，服务器传输公钥 SSL数字证书；浏览器生成随机码，通过公钥传输给服务器。服务器通过私钥解开随机码。</p><p>将随机码作为密钥，使用对称加密(速度快)，将用户的重要信息通过随机码也就是密钥加密传过去。服务器之前已经用私钥解开了随机码（密钥），所以服务器用随机码（密钥）解开重要信息。</p><img src="/2020/03/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B9%8B%E6%94%BB%E5%AE%88%E9%81%93/w5.png" class><h5 id="服务器实现Https-协议"><a href="#服务器实现Https-协议" class="headerlink" title="服务器实现Https 协议"></a>服务器实现Https 协议</h5><ol><li><p>配置</p><ul><li><p>生成密钥库</p><p>确保环境变量配置了%JAVA_HOME%\bin, 因为生成密钥库是使用 jdk 中的 keytool工具</p><p>进入dos命令运行如下命令：</p><p>keytool -genkeypair -alias test-cyq -validity 3650 -keyalg RSA -dname \</p><p>123456</p></li><li><p>配置tomcat 启用https 协议并指定密钥库</p><p>进入server.xml ，将http配置注释掉，打开https，并配置https两个属性，指定密钥库的位置和密钥库的密码</p></li></ul></li><li><p>SSL 证书种类</p><p>域名型 DVSSL</p><p>企业型 OVSSL</p><p>增强型 EVSSL</p></li></ol><h5 id="Https-优缺点"><a href="#Https-优缺点" class="headerlink" title="Https 优缺点"></a>Https 优缺点</h5><p>优点：安全性高</p><p>缺点：收费，也不是绝对安全，耗电耗资源</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网络安全，就是攻守之间的对抗&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="网络安全" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>前端需要注意的SEO</title>
    <link href="http://yoursite.com/2020/03/29/%E5%89%8D%E7%AB%AF%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84SEO/"/>
    <id>http://yoursite.com/2020/03/29/%E5%89%8D%E7%AB%AF%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84SEO/</id>
    <published>2020-03-29T08:27:58.000Z</published>
    <updated>2020-03-29T08:33:21.720Z</updated>
    
    <content type="html"><![CDATA[<p>SEO (搜索引擎优化)</p><a id="more"></a><ul><li>合理的<code>title</code>、<code>description</code>、<code>keywords</code>：搜索对着三项的权重逐个减小，<code>title</code>值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面<code>title</code>要有所不同；<code>description</code>把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面<code>description</code>有所不同；<code>keywords</code>列举出重要关键词即可</li><li>语义化的<code>HTML</code>代码，符合W3C规范：语义化代码让搜索引擎容易理解网页</li><li>重要内容<code>HTML</code>代码放在最前：搜索引擎抓取<code>HTML</code>顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取</li><li>重要内容不要用<code>js</code>输出：爬虫不会执行js获取内容</li><li>少用<code>iframe</code>：搜索引擎不会抓取<code>iframe</code>中的内容</li><li>非装饰性图片必须加<code>alt</code></li><li>提高网站速度：网站速度是搜索引擎排序的一个重要指标</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SEO (搜索引擎优化)&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="SEO" scheme="http://yoursite.com/tags/SEO/"/>
    
  </entry>
  
  <entry>
    <title>Ajax和JSON</title>
    <link href="http://yoursite.com/2020/03/29/Ajax%E5%92%8CJSON/"/>
    <id>http://yoursite.com/2020/03/29/Ajax%E5%92%8CJSON/</id>
    <published>2020-03-29T08:09:26.000Z</published>
    <updated>2020-04-05T04:06:46.378Z</updated>
    
    <content type="html"><![CDATA[<p>ajax and json</p><a id="more"></a><h5 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h5><blockquote><p>Ajax（Asynchronous <a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=2484&ss_c=ssc.citiao.link" target="_blank" rel="noopener">JavaScript</a> and XML），用于创建更好更快以及交互性更强的<a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=159605&ss_c=ssc.citiao.link" target="_blank" rel="noopener">Web应用程序</a>的技术，与传统的Web应用相比，Ajax通过浏览器与服务器进行少量的数据交换就可以实现网页的异步更新，在不重新加载整个网页的情况下，即可对网页进行更新。</p></blockquote><h5 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h5><blockquote><p>JSON(JavaScriptObject Notation, JS 对象简谱) 是一种<a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=7988600&ss_c=ssc.citiao.link" target="_blank" rel="noopener">轻量级</a>的数据交换格式，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。JSON（常用于数据交互）和XML（常用于文件配置）可读性不相上下。</p></blockquote><p>在JS语言中，一切都是对象，因此任何JS支持的类型，都可以通过JSON来表示，例如字符串、数字、对象数组等。</p><ul><li>对象表示为键值对</li><li>数据由逗号分隔</li><li>花括号保存对象</li><li>方括号保存数组</li></ul><p>JSON是JS对象的字符串表示法，它使用文本表示一个JS对象的信息，本质是一个<strong>字符串</strong></p><h5 id="JSON和JS对象互转"><a href="#JSON和JS对象互转" class="headerlink" title="JSON和JS对象互转"></a>JSON和JS对象互转</h5><p>从JSON字符串转换为JS对象，使用JSON.parse()方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">JSON</span>.parse(<span class="string">'&#123;"a":"hello","b":"world"&#125;'</span>)</span><br></pre></td></tr></table></figure><p>从JS对象转换为JSON字符串，使用JSON.stringify()方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> json = <span class="built_in">JSON</span>.stringify(&#123;<span class="string">"a"</span>:<span class="string">"hello"</span>,<span class="string">"b"</span>:<span class="string">"world"</span>&#125;)</span><br></pre></td></tr></table></figure><h5 id="jQuery-parseJSON-函数"><a href="#jQuery-parseJSON-函数" class="headerlink" title="jQuery.parseJSON()函数"></a>jQuery.parseJSON()函数</h5><p>用于将格式完好的JSON字符串转为与之对应的JavaScript对象。</p><p>所谓”格式完好”，就是要求指定的字符串必须符合严格的JSON格式，例如：属性名称必须加双引号、字符串值也必须用双引号。</p><p>如果传入一个格式不”完好”的JSON字符串将抛出一个JS异常，</p><p>例如：以下字符串均符合JSON格式，但它们不是格式完好的JSON字符串(因此会抛出异常)：</p><p>// 以下均是字符串值，省略了两侧的引号，以便于展现内容</p><p>{id: 1} // id是属性名称，必须加双引号<br>{‘id’: 1} // id是属性名称，必须用双引号(不能用单引号)<br>{“name”: ‘CodePlayer’} // name属性的值是字符串，必须用双引号(不能用单引号)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ajax and json&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="json ajax" scheme="http://yoursite.com/tags/json-ajax/"/>
    
  </entry>
  
  <entry>
    <title>JWT认证</title>
    <link href="http://yoursite.com/2020/03/29/JWT%E8%AE%A4%E8%AF%81/"/>
    <id>http://yoursite.com/2020/03/29/JWT%E8%AE%A4%E8%AF%81/</id>
    <published>2020-03-29T03:33:39.000Z</published>
    <updated>2020-03-29T08:02:17.973Z</updated>
    
    <content type="html"><![CDATA[<p>JSON Web Token（JWT）</p><a id="more"></a><hr><blockquote><p>学习文档转自 <a href="https://www.cnblogs.com/haha12/p/11796456.html" target="_blank" rel="noopener">https://www.cnblogs.com/haha12/p/11796456.html</a></p></blockquote><hr><h5 id="JWT简介"><a href="#JWT简介" class="headerlink" title="JWT简介"></a>JWT简介</h5><p>JSON Web Token（JWT）是一个开放的标准（RFC 7519），它定义了一个紧凑且自包含的方式，用于在各方之间作为JSON对象安全地传输信息。由于此信息是经过数字签名的，因此可以被验证和信任。</p><h5 id="JWT认证和session认证的区别"><a href="#JWT认证和session认证的区别" class="headerlink" title="JWT认证和session认证的区别"></a>JWT认证和session认证的区别</h5><ol><li><p>session认证</p><p>http协议是一种无状态的协议，而这就意味着如果用户向我们的应用提供了用户名和密码来进行用户认证，那么下一次请求时，用户还要再一次进行用户认证才行，因为根据http协议，我们并不能知道是哪个用户发送的请求，所以为了让我们的应用能识别是哪个用户发出的，我们只能在服务器存储一份用户登陆的信息，这份登陆信息会在响应时传递给浏览器，告诉其保存为cookie，以便下次请求时发送给我们的应用，这样我们的应用个就能识别请求来自哪个用户了，这就是传统的基于sessino认证。</p></li><li><p>JWT认证</p><p>基于token的鉴权机制类似于http协议也是无状态的，它不需要在服务端去保留用户的认证信息或会话信息。这也就意味着JWT认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利。</p></li><li><p>JWT认证流程</p><img src="/2020/03/29/JWT%E8%AE%A4%E8%AF%81/j1.png" class><p>认证流程如下：</p><ol><li>用户使用账号和密码发出post请求；</li><li>服务器使用私钥创建一个jwt；</li><li>服务器返回这个jwt给浏览器；</li><li>浏览器将该jwt串在请求头中像服务器发送请求；</li><li>服务器验证该jwt；</li><li>返回响应的资源给浏览器。</li></ol></li><li><p>JWT组成</p><img src="/2020/03/29/JWT%E8%AE%A4%E8%AF%81/j2.png" class><p>从上图可以看到，JWT含有三部分：头部（header）、载荷（payload）、签名（signature）。</p><p>1.头部</p><p>JWT的头部有两部分信息：</p><ul><li>声明类型，这里是JWT</li><li>声明加密的算法，通常直接使用HMAC SHA256</li></ul><p>头部示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"alg"</span>: <span class="string">"HS256"</span>,</span><br><span class="line">  <span class="string">"typ"</span>: <span class="string">"JWT"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>头部一般使用base64加密，加密后密文：eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9</p><p>2.载荷</p><p>该部分一般存放一些有效的信息。JWT的标准定义包含五个字段：</p><ul><li>iss：该JWT的签发者</li><li>sub: 该JWT所面向的用户</li><li>aud: 接收该JWT的一方</li><li>exp(expires): 什么时候过期，这里是一个Unix时间戳</li><li>iat(issued at): 在什么时候签发的</li></ul><p>载荷示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"sub"</span>: <span class="string">"1234567890"</span>,</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"Java碎碎念"</span>,</span><br><span class="line">  <span class="string">"iat"</span>: <span class="number">1516239022</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.签名</p><p>前面两部分都是使用Base64进行编码的，即前端可以解开知道里面的信息。signature 需要使用编码后的header和payload以及我们提供的一个密钥，然后使用header中指定的签名算法（HS256）进行签名。签名的作用是保证 JWT 没有被篡改过。</p><p>三个部分通过.连接在一起就是我们的 JWT 了，所以我们生成的JWT如下：</p><p><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkphdmHnoo7noo7lv7UiLCJpYXQiOjE1MTYyMzkwMjJ9.LLJIkhJs6SVYlzn3n8fThQmhGutjTDI3RURTLtHV4ls</code></p><p>注意：密钥就是用来进行JWT的签发和JWT的验证，所以，它就是你服务端的私钥，在任何场景都不应该泄露出去。</p></li><li><p>JWT使用场景</p><p>JWT主要使用场景如下：</p><ul><li>授权</li></ul><p>这是JWT使用最多的场景，一旦用户登录，每个后续的请求将包括JWT，从而允许用户访问该令牌允许的路由、服务和资源。</p><ul><li>信息交换：JSON</li></ul><p>JWT可以用在各方之间安全地传输信息，因为JWT可以进行签名，所以您可以确定发件人是他们所说的人。另外，由于签名是使用标头和有效负载计算的，因此您还可以验证内容是否未被篡改。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JSON Web Token（JWT）&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="验证" scheme="http://yoursite.com/tags/%E9%AA%8C%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>Django Vuejs</title>
    <link href="http://yoursite.com/2020/03/28/Django-Vuejs/"/>
    <id>http://yoursite.com/2020/03/28/Django-Vuejs/</id>
    <published>2020-03-28T13:44:40.000Z</published>
    <updated>2020-03-29T03:42:57.097Z</updated>
    
    <content type="html"><![CDATA[<p>django with vuejs</p><a id="more"></a><hr><blockquote><p>博客：<a href="https://zhuanlan.zhihu.com/p/25080236" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25080236</a></p><p>github：<a href="https://github.com/tmpbook/django-with-vuejs" target="_blank" rel="noopener">https://github.com/tmpbook/django-with-vuejs</a></p></blockquote><hr><img src="/2020/03/28/Django-Vuejs/d1.png" class>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;django with vuejs&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Django" scheme="http://yoursite.com/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>jQuery</title>
    <link href="http://yoursite.com/2020/03/27/jQuery/"/>
    <id>http://yoursite.com/2020/03/27/jQuery/</id>
    <published>2020-03-27T11:27:50.000Z</published>
    <updated>2020-03-29T03:47:18.161Z</updated>
    
    <content type="html"><![CDATA[<p>jquery基础整合</p><a id="more"></a><blockquote><p>学习文档转自黑马教程</p></blockquote><p>使用javascript开发过程中，有许多的缺点：</p><ol><li>查找元素的方法单一，麻烦。</li><li>遍历数组很麻烦，通常要嵌套一大堆的for循环。</li><li>有兼容性问题。</li><li>想要实现简单的动画效果，也很麻烦</li><li>代码冗余。</li></ol><h2 id="体验jquery的使用"><a href="#体验jquery的使用" class="headerlink" title="体验jquery的使用"></a>体验jquery的使用</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 1. 查找元素的方法多种多样，非常灵活</span></span><br><span class="line"><span class="comment">* 2. 拥有隐式迭代特性，因此不再需要手写for循环了。</span></span><br><span class="line"><span class="comment">* 3. 完全没有兼容性问题。</span></span><br><span class="line"><span class="comment">* 4. 实现动画非常简单，而且功能更加的强大。</span></span><br><span class="line"><span class="comment">* 5. 代码简单、粗暴。</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">"#btn1"</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        $(<span class="string">"div"</span>).show(<span class="number">200</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    $(<span class="string">"#btn2"</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        $(<span class="string">"div"</span>).text(<span class="string">"我是内容"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="jquery到底是什么"><a href="#jquery到底是什么" class="headerlink" title="jquery到底是什么"></a>jquery到底是什么</h2><blockquote><p>jQuery的官网 <a href="http://jquery.com/" target="_blank" rel="noopener">http://jquery.com/</a><br>jQuery就是一个js库，使用jQuery的话，会比使用JavaScript更简单。</p></blockquote><p><strong>What is jQuery?</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jQuery is a fast, small, and feature-rich JavaScript library. </span><br><span class="line">It makes things like HTML document traversal and manipulation, </span><br><span class="line">event handling, animation, and Ajax </span><br><span class="line">much simpler with an easy-to-use API that works across a multitude of browsers. </span><br><span class="line">With a combination of versatility and extensibility, </span><br><span class="line">jQuery has changed the way that millions of people write JavaScript.</span><br></pre></td></tr></table></figure><p>js库：把一些常用到的方法写到一个单独的js文件，使用的时候直接去引用这js文件就可以了。<br>（animate.js、common.js）</p><p>我们知道了，jQuery其实就是一个js文件，里面封装了一大堆的方法方便我们的开发，<br>其实就是一个加强版的common.js，因此我们学习jQuery，其实就是学习jQuery这个js文件中封装的一大堆方法。</p><h2 id="jquery的版本问题"><a href="#jquery的版本问题" class="headerlink" title="jquery的版本问题"></a>jquery的版本问题</h2><blockquote><p>官网下载地址：<a href="http://jquery.com/download/" target="_blank" rel="noopener">http://jquery.com/download/</a><br>jQuery版本有很多，分为1.x 2.x 3.x<br>1.x和2.x版本jquery都不再更新版本了，现在只更新3.x版本。</p></blockquote><p>大版本分类：</p><ul><li>1.x版本：能够兼容IE678浏览器</li><li>2.x版本：不能兼容IE678浏览器</li><li>3.x版本：不能兼容IE678浏览器，更加的精简（在国内不流行，因为国内使用jQuery的主要目的就是兼容IE678）</li></ul><p>关于压缩版和未压缩版：  </p><ul><li>jquery-1.12.4.min.js:压缩版本，适用于生产环境，因为文件比较小，去除了注释、换行、空格等东西，但是基本没有颗阅读性。</li><li>jquery-1.12.4.js:未压缩版本，适用于学习与开发环境，源码清晰，易阅读。</li></ul><h2 id="jquery的入口函数"><a href="#jquery的入口函数" class="headerlink" title="jquery的入口函数"></a>jquery的入口函数</h2><p>使用jQuery的三个步骤：</p><ol><li>引入jQuery文件</li><li>入口函数</li><li>功能实现</li></ol><p>关于jQuery的入口函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种写法</span></span><br><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//第二种写法</span></span><br><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>jQuery入口函数与js入口函数的对比：</p><ol><li>JavaScript的入口函数要等到页面中所有资源（包括图片、文件）加载完成才开始执行。</li><li>jQuery的入口函数只会等待文档树加载完成就开始执行，并不会等待图片、文件的加载。</li></ol><h2 id="jq对象和dom对象-重要"><a href="#jq对象和dom对象-重要" class="headerlink" title="jq对象和dom对象(重要)"></a>jq对象和dom对象(重要)</h2><ol><li>DOM对象：使用JavaScript中的方法获取页面中的元素返回的对象就是dom对象。</li><li>jQuery对象：jquery对象就是使用jquery的方法获取页面中的元素返回的对象就是jQuery对象。</li><li>jQuery对象其实就是DOM对象的包装集<strong>包装了DOM对象的集合（伪数组）</strong></li><li>DOM对象与jQuery对象的方法不能混用。</li></ol><p>DOM对象转换成jQuery对象：【联想记忆：花钱】</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $obj = $(domObj);</span><br><span class="line"><span class="comment">// $(document).ready(function()&#123;&#125;);就是典型的DOM对象转jQuery对象</span></span><br></pre></td></tr></table></figure><p>jQuery对象转换成DOM对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $li = $(<span class="string">"li"</span>);</span><br><span class="line"><span class="comment">//第一种方法（推荐使用）</span></span><br><span class="line">$li[<span class="number">0</span>]</span><br><span class="line"><span class="comment">//第二种方法</span></span><br><span class="line">$li.get(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="jquery选择器"><a href="#jquery选择器" class="headerlink" title="jquery选择器"></a>jquery选择器</h2><h3 id="什么是jQuery选择器"><a href="#什么是jQuery选择器" class="headerlink" title="什么是jQuery选择器"></a>什么是jQuery选择器</h3><ul><li>jQuery选择器是jQuery为我们提供的一组方法，让我们更加方便的获取到页面中的元素。<br>注意：jQuery选择器返回的是jQuery对象。</li><li>jQuery选择器有很多，基本兼容了CSS1到CSS3所有的选择器，并且jQuery还添加了很多扩展性的选择器。<br>【查看jQuery文档】</li><li>jQuery选择器虽然很多，但是选择器之间可以相互替代，就是说获取一个元素，你会有很多种方法获取到。<br>所以我们平时真正能用到的只是少数的最常用的选择器。</li></ul><h3 id="基本选择器"><a href="#基本选择器" class="headerlink" title="基本选择器"></a>基本选择器</h3><table><thead><tr><th>名称</th><th>用法</th><th align="left">描述</th></tr></thead><tbody><tr><td>ID选择器</td><td>$(“#id”);</td><td align="left">获取指定ID的元素</td></tr><tr><td>类选择器</td><td>$(“.class”);</td><td align="left">获取同一类class的元素</td></tr><tr><td>标签选择器</td><td>$(“div”);</td><td align="left">获取同一类标签的所有元素</td></tr><tr><td>并集选择器</td><td>$(“div,p,li”);</td><td align="left">使用逗号分隔，只要符合条件之一就可。</td></tr><tr><td>交集选择器</td><td>$(“div.redClass”);</td><td align="left">获取class为redClass的div元素</td></tr></tbody></table><blockquote><p>总结：跟css的选择器用法一模一样。</p></blockquote><h3 id="层级选择器"><a href="#层级选择器" class="headerlink" title="层级选择器"></a>层级选择器</h3><table><thead><tr><th>名称</th><th>用法</th><th align="left">描述</th></tr></thead><tbody><tr><td>子代选择器</td><td>$(“ul&gt;li”);</td><td align="left">使用&gt;号，获取儿子层级的元素，注意，并不会获取孙子层级的元素</td></tr><tr><td>后代选择器</td><td>$(“ul li”);</td><td align="left">使用空格，代表后代选择器，获取ul下的所有li元素，包括孙子等</td></tr></tbody></table><blockquote><p>总结：跟css的选择器用法一模一样。</p></blockquote><h3 id="过滤选择器"><a href="#过滤选择器" class="headerlink" title="过滤选择器"></a>过滤选择器</h3><table><thead><tr><th>名称</th><th>用法</th><th align="left">描述</th></tr></thead><tbody><tr><td>:eq（index）</td><td>$(“li:eq(2)”).css(“color”, ”red”);</td><td align="left">获取到的li元素中，选择索引号为2的元素，索引号index从0开始。</td></tr><tr><td>:odd</td><td>$(“li:odd”).css(“color”, ”red”);</td><td align="left">获取到的li元素中，选择索引号为奇数的元素</td></tr><tr><td>:even</td><td>$(“li:even”).css(“color”, ”red”);</td><td align="left">获取到的li元素中，选择索引号为偶数的元素</td></tr></tbody></table><blockquote><p>总结：这类选择器都带冒号</p></blockquote><h3 id="筛选选择器-方法"><a href="#筛选选择器-方法" class="headerlink" title="筛选选择器(方法)"></a>筛选选择器(方法)</h3><table><thead><tr><th>名称</th><th>用法</th><th>描述</th></tr></thead><tbody><tr><td>children(selector)</td><td>$(“ul”).children(“li”)</td><td>相当于$(“ul&gt;li”)，子类选择器</td></tr><tr><td>find(selector)</td><td>$(“ul”).find(“li”);</td><td>相当于$(“ul li”),后代选择器</td></tr><tr><td>siblings(selector)</td><td>$(“#first”).siblings(“li”);</td><td>查找兄弟节点，不包括自己本身。</td></tr><tr><td>parent()</td><td>$(“#first”).parent();</td><td>查找父亲</td></tr><tr><td>eq(index)</td><td>$(“li”).eq(2);</td><td>相当于$(“li:eq(2)”),index从0开始</td></tr><tr><td>next()</td><td>$(“li”).next()</td><td>找下一个兄弟</td></tr><tr><td>prev()</td><td>$(“li”).prev()</td><td>找上一次兄弟</td></tr></tbody></table><blockquote><p>总结：筛选选择器的功能与过滤选择器有点类似，但是用法不一样，筛选选择器主要是方法。</p></blockquote><p>【案例：下拉菜单】<br>【案例：突出展示】<br>【案例：手风琴】<br>【案例：淘宝精品】</p><h2 id="元素设置"><a href="#元素设置" class="headerlink" title="元素设置"></a>元素设置</h2><h3 id="样式设置"><a href="#样式设置" class="headerlink" title="样式设置"></a>样式设置</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*1.设置一个样式*/</span></span><br><span class="line"><span class="comment">//两个参数  设置的样式属性,具体样式</span></span><br><span class="line">$(<span class="string">'li'</span>).css(<span class="string">'color'</span>,<span class="string">'red'</span>);</span><br><span class="line"><span class="comment">//传入对象（设置的样式属性:具体样式）</span></span><br><span class="line">$(<span class="string">'li'</span>).css(&#123;<span class="string">'color'</span>:<span class="string">'red'</span>&#125;);</span><br><span class="line"><span class="comment">/*2.设置多个样式*/</span></span><br><span class="line">$(<span class="string">'li'</span>).css(&#123;</span><br><span class="line">    <span class="string">'color'</span>:<span class="string">'green'</span>,</span><br><span class="line">    <span class="string">'font-size'</span>:<span class="string">'20px'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="类名设置"><a href="#类名设置" class="headerlink" title="类名设置"></a>类名设置</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*1.添加一个类*/</span></span><br><span class="line">$(<span class="string">'li'</span>).addClass(<span class="string">'now'</span>);</span><br><span class="line"><span class="comment">/*2.删除一个类*/</span></span><br><span class="line">$(<span class="string">'li'</span>).removeClass(<span class="string">'now'</span>);</span><br><span class="line"><span class="comment">/*3.切换一个类  有就删除没有就添加*/</span></span><br><span class="line">$(<span class="string">'li'</span>).toggleClass(<span class="string">'now'</span>);</span><br><span class="line"><span class="comment">/*4.匹配一个类  判断是否包含某个类  如果包含返回true否知返回false*/</span></span><br><span class="line">$(<span class="string">'li'</span>).hasClass(<span class="string">'now'</span>);</span><br></pre></td></tr></table></figure><p>对应案例：<code>案例-《tab切换》</code></p><h3 id="属性设置"><a href="#属性设置" class="headerlink" title="属性设置"></a>属性设置</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*1.获取属性*/</span></span><br><span class="line">$(<span class="string">'li'</span>).attr(<span class="string">'name'</span>);</span><br><span class="line"><span class="comment">/*2.设置属性*/</span></span><br><span class="line">$(<span class="string">'li'</span>).attr(<span class="string">'name'</span>,<span class="string">'tom'</span>);</span><br><span class="line"><span class="comment">/*3.设置多个属性*/</span></span><br><span class="line">$(<span class="string">'li'</span>).attr(&#123;</span><br><span class="line">    <span class="string">'name'</span>:<span class="string">'tom'</span>,</span><br><span class="line">    <span class="string">'age'</span>:<span class="string">'18'</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/*4.删除属性*/</span></span><br><span class="line">$(<span class="string">'li'</span>).removeAttr(<span class="string">'name'</span>);</span><br></pre></td></tr></table></figure><p>对应案例：<code>案例-《美女相册》</code></p><h3 id="prop方法"><a href="#prop方法" class="headerlink" title="prop方法"></a>prop方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*对于布尔类型的属性，不要attr方法，应该用prop方法 prop用法跟attr方法一样。*/</span></span><br><span class="line">$(<span class="string">"#checkbox"</span>).prop(<span class="string">"checked"</span>);</span><br><span class="line">$(<span class="string">"#checkbox"</span>).prop(<span class="string">"checked"</span>, <span class="literal">true</span>);</span><br><span class="line">$(<span class="string">"#checkbox"</span>).prop(<span class="string">"checked"</span>, <span class="literal">false</span>);</span><br><span class="line">$(<span class="string">"#checkbox"</span>).removeProp(<span class="string">"checked"</span>);</span><br></pre></td></tr></table></figure><p>对应案例：<code>案例-《表格全选》</code></p><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><h3 id="基本动画"><a href="#基本动画" class="headerlink" title="基本动画"></a>基本动画</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*注意：动画的本质是改变容器的大小和透明度*/</span></span><br><span class="line"><span class="comment">/*注意：如果不传参数是看不到动画*/</span></span><br><span class="line"><span class="comment">/*注意：可传入特殊的字符  fast normal slow*/</span></span><br><span class="line"><span class="comment">/*注意：可传入数字 单位毫秒*/</span></span><br><span class="line"><span class="comment">/*1.展示动画*/</span></span><br><span class="line">$(<span class="string">'li'</span>).show();</span><br><span class="line"><span class="comment">/*2.隐藏动画*/</span></span><br><span class="line">$(<span class="string">'li'</span>).hide();</span><br><span class="line"><span class="comment">/*3.切换展示和隐藏*/</span></span><br><span class="line">$(<span class="string">'li'</span>).toggle();</span><br></pre></td></tr></table></figure><h3 id="滑入滑出"><a href="#滑入滑出" class="headerlink" title="滑入滑出"></a>滑入滑出</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*注意：动画的本质是改变容器的高度*/</span></span><br><span class="line"><span class="comment">/*1.滑入动画*/</span></span><br><span class="line">$(<span class="string">'li'</span>).slideDown();</span><br><span class="line"><span class="comment">/*2.滑出动画*/</span></span><br><span class="line">$(<span class="string">'li'</span>).slideUp();</span><br><span class="line"><span class="comment">/*3.切换滑入滑出*/</span></span><br><span class="line">$(<span class="string">'li'</span>).slideToggle();</span><br></pre></td></tr></table></figure><p>对应案例：<code>案例-《下拉菜单》</code></p><h3 id="淡入淡出"><a href="#淡入淡出" class="headerlink" title="淡入淡出"></a>淡入淡出</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*注意：动画的本质是改变容器的透明度*/</span></span><br><span class="line"><span class="comment">/*1.淡入动画*/</span></span><br><span class="line">$(<span class="string">'li'</span>).fadeIn();</span><br><span class="line"><span class="comment">/*2.淡出动画*/</span></span><br><span class="line">$(<span class="string">'li'</span>).fadeOut();</span><br><span class="line"><span class="comment">/*3.切换淡入淡出*/</span></span><br><span class="line">$(<span class="string">'li'</span>).fadeToggle();</span><br><span class="line">$(<span class="string">'li'</span>).fadeTo(<span class="string">'speed'</span>,<span class="string">'opacity'</span>);</span><br></pre></td></tr></table></figure><p>对应案例：<code>案例-《轮播图》</code></p><h3 id="自定义动画"><a href="#自定义动画" class="headerlink" title="自定义动画"></a>自定义动画</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 自定义动画</span></span><br><span class="line"><span class="comment">* 参数1：需要做动画的属性</span></span><br><span class="line"><span class="comment">* 参数2：需要执行动画的总时长</span></span><br><span class="line"><span class="comment">* 参数3：执行动画的时候的速度</span></span><br><span class="line"><span class="comment">* 参数4：执行动画完成之后的回调函数</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">$(<span class="string">'#box1'</span>).animate(&#123;<span class="attr">left</span>:<span class="number">800</span>&#125;,<span class="number">5000</span>);</span><br><span class="line">$(<span class="string">'#box2'</span>).animate(&#123;<span class="attr">left</span>:<span class="number">800</span>&#125;,<span class="number">5000</span>,<span class="string">'linear'</span>);</span><br><span class="line">$(<span class="string">'#box3'</span>).animate(&#123;<span class="attr">left</span>:<span class="number">800</span>&#125;,<span class="number">5000</span>,<span class="string">'swing'</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'动画执行完成'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>对应案例：<code>案例-《手风琴菜单》</code></p><h3 id="动画队列"><a href="#动画队列" class="headerlink" title="动画队列"></a>动画队列</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">jQuery中有个动画队列的机制。</span></span><br><span class="line"><span class="comment">当我们对一个对象添加多次动画效果时后添加的动作就会被放入这个动画队列中，  </span></span><br><span class="line"><span class="comment">等前面的动画完成后再开始执行。</span></span><br><span class="line"><span class="comment">可是用户的操作往往都比动画快，  </span></span><br><span class="line"><span class="comment">如果用户对一个对象频繁操作时不处理动画队列就会造成队列堆积，</span></span><br><span class="line"><span class="comment">影响到效果。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="stop使用"><a href="#stop使用" class="headerlink" title="stop使用"></a>stop使用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*1.停止当前动画  如果动画队列当中还有动画立即执行*/</span></span><br><span class="line"><span class="comment">//$('div').stop();</span></span><br><span class="line"><span class="comment">/*2.和stop()效果一致  说明这是默认设置*/</span></span><br><span class="line"><span class="comment">//$('div').stop(false,false);</span></span><br><span class="line"><span class="comment">/*3.停止当前动画  清除动画队列*/</span></span><br><span class="line"><span class="comment">//$('div').stop(true,false);</span></span><br><span class="line"><span class="comment">/*4.停止当前动画并且到结束位置  清除了动画队列*/</span></span><br><span class="line"><span class="comment">//$('div').stop(true,true);</span></span><br><span class="line"><span class="comment">/*5.停止当前动画并且到结束位置  如果动画队列当中还有动画立即执行*/</span></span><br><span class="line">$(<span class="string">'div'</span>).stop(<span class="literal">false</span>,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>对应案例：<code>案例-《音乐导航》</code><br>对应案例：<code>案例-《工具栏》</code></p><h2 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h2><h3 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*创建节点*/</span></span><br><span class="line"><span class="keyword">var</span> $a = $(<span class="string">'&lt;a href="http://www.baidu.com" target="_blank"&gt;百度1&lt;/a&gt;'</span>);</span><br></pre></td></tr></table></figure><h3 id="克隆节点"><a href="#克隆节点" class="headerlink" title="克隆节点"></a>克隆节点</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*如果想克隆事件  false  true克隆事件*/</span></span><br><span class="line"><span class="keyword">var</span> $cloneP = $(<span class="string">'p'</span>).clone(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h3 id="添加-amp-移动节点"><a href="#添加-amp-移动节点" class="headerlink" title="添加&amp;移动节点"></a>添加&amp;移动节点</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*追加自身的最后面  传对象和html格式代码*/</span></span><br><span class="line">$(<span class="string">'#box'</span>).append(<span class="string">'&lt;a href="http://www.baidu.com" target="_blank"&gt;&lt;b&gt;百度3&lt;/b&gt;&lt;/a&gt;'</span>);</span><br><span class="line">$(<span class="string">'#box'</span>).append($(<span class="string">'a'</span>));</span><br><span class="line"><span class="comment">/*追加到目标元素最后面  传目标元素的选择器或者对象*/</span></span><br><span class="line">$(<span class="string">'&lt;a href="http://www.baidu.com" target="_blank"&gt;&lt;b&gt;百度3&lt;/b&gt;&lt;/a&gt;'</span>).appendTo($(<span class="string">'#box'</span>));</span><br><span class="line">$(<span class="string">'a'</span>).appendTo(<span class="string">'#box'</span>);</span><br><span class="line"></span><br><span class="line">prepend();</span><br><span class="line">prependTo();</span><br><span class="line">after();</span><br><span class="line">before();</span><br></pre></td></tr></table></figure><h3 id="删除节点-amp-清空节点"><a href="#删除节点-amp-清空节点" class="headerlink" title="删除节点&amp;清空节点"></a>删除节点&amp;清空节点</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*1.清空box里面的元素*/</span></span><br><span class="line"><span class="comment">/* 清理门户 */</span></span><br><span class="line">$(<span class="string">'#box'</span>).empty();</span><br><span class="line"><span class="comment">/*2.删除某个元素*/</span></span><br><span class="line"><span class="comment">/* 自杀 */</span></span><br><span class="line">$(<span class="string">'#box'</span>).remove();</span><br></pre></td></tr></table></figure><p>【案例-《弹幕》】</p><h2 id="jQuery特殊属性操作"><a href="#jQuery特殊属性操作" class="headerlink" title="jQuery特殊属性操作"></a>jQuery特殊属性操作</h2><h3 id="val方法"><a href="#val方法" class="headerlink" title="val方法"></a>val方法</h3><blockquote><p>val方法用于设置和获取表单元素的值，例如input、textarea的值</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置值</span></span><br><span class="line">$(<span class="string">"#name"</span>).val(<span class="string">'张三'</span>);</span><br><span class="line"><span class="comment">//获取值</span></span><br><span class="line">$(<span class="string">"#name"</span>).val();</span><br></pre></td></tr></table></figure><h3 id="html方法与text方法"><a href="#html方法与text方法" class="headerlink" title="html方法与text方法"></a>html方法与text方法</h3><blockquote><p>html方法相当于innerHTML  text方法相当于innerText</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置内容</span></span><br><span class="line">$(<span class="string">'div'</span>).html(<span class="string">'&lt;span&gt;这是一段内容&lt;/span&gt;'</span>);</span><br><span class="line"><span class="comment">//获取内容</span></span><br><span class="line">$(<span class="string">'div'</span>).html()</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置内容</span></span><br><span class="line">$(<span class="string">'div'</span>).text(<span class="string">'&lt;span&gt;这是一段内容&lt;/span&gt;'</span>);</span><br><span class="line"><span class="comment">//获取内容</span></span><br><span class="line">$(<span class="string">'div'</span>).text()</span><br></pre></td></tr></table></figure><p>区别：html方法会识别html标签，text方法会那内容直接当成字符串，并不会识别html标签。</p><h3 id="width方法与height方法"><a href="#width方法与height方法" class="headerlink" title="width方法与height方法"></a>width方法与height方法</h3><blockquote><p>设置或者获取高度</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//带参数表示设置高度</span></span><br><span class="line">$(<span class="string">'img'</span>).height(<span class="number">200</span>);</span><br><span class="line"><span class="comment">//不带参数获取高度</span></span><br><span class="line">$(<span class="string">'img'</span>).height();</span><br></pre></td></tr></table></figure><p>获取网页的可视区宽高</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取可视区宽度</span></span><br><span class="line">$(<span class="built_in">window</span>).width();</span><br><span class="line"><span class="comment">//获取可视区高度</span></span><br><span class="line">$(<span class="built_in">window</span>).height();</span><br></pre></td></tr></table></figure><h3 id="scrollTop与scrollLeft"><a href="#scrollTop与scrollLeft" class="headerlink" title="scrollTop与scrollLeft"></a>scrollTop与scrollLeft</h3><blockquote><p>设置或者获取垂直滚动条的位置</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取页面被卷曲的高度</span></span><br><span class="line">$(<span class="built_in">window</span>).scrollTop();</span><br><span class="line"><span class="comment">//获取页面被卷曲的宽度</span></span><br><span class="line">$(<span class="built_in">window</span>).scrollLeft();</span><br></pre></td></tr></table></figure><h3 id="offset方法与position方法"><a href="#offset方法与position方法" class="headerlink" title="offset方法与position方法"></a>offset方法与position方法</h3><blockquote><p>offset方法获取元素距离document的位置，position方法获取的是元素距离有定位的父元素的位置。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取元素距离document的位置,返回值为对象：&#123;left:100, top:100&#125;</span></span><br><span class="line">$(selector).offset();</span><br><span class="line"><span class="comment">//获取相对于其最近的有定位的父元素的位置。</span></span><br><span class="line">$(selector).position();</span><br></pre></td></tr></table></figure><h2 id="jQuery事件机制"><a href="#jQuery事件机制" class="headerlink" title="jQuery事件机制"></a>jQuery事件机制</h2><blockquote><p>JavaScript中已经学习过了事件，但是jQuery对JavaScript事件进行了封装，增加并扩展了事件处理机制。jQuery不仅提供了更加优雅的事件处理语法，而且极大的增强了事件的处理能力。</p></blockquote><h3 id="jQuery事件发展历程-了解"><a href="#jQuery事件发展历程-了解" class="headerlink" title="jQuery事件发展历程(了解)"></a>jQuery事件发展历程(了解)</h3><p>简单事件绑定&gt;&gt;bind事件绑定&gt;&gt;delegate事件绑定&gt;&gt;on事件绑定(推荐)</p><blockquote><p>简单事件注册</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">click(handler)<span class="comment">//单击事件</span></span><br><span class="line">mouseenter(handler)<span class="comment">//鼠标进入事件</span></span><br><span class="line">mouseleave(handler)<span class="comment">//鼠标离开事件</span></span><br></pre></td></tr></table></figure><p>缺点：不能同时注册多个事件</p><blockquote><p>bind方式注册事件</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个参数：事件类型</span></span><br><span class="line"><span class="comment">//第二个参数：事件处理程序</span></span><br><span class="line">$(<span class="string">"p"</span>).bind(<span class="string">"click mouseenter"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//事件响应方法</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>缺点：不支持动态事件绑定</p><blockquote><p>delegate注册委托事件</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个参数：selector，要绑定事件的元素</span></span><br><span class="line"><span class="comment">// 第二个参数：事件类型</span></span><br><span class="line"><span class="comment">// 第三个参数：事件处理函数</span></span><br><span class="line">$(<span class="string">".parentBox"</span>).delegate(<span class="string">"p"</span>, <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//为 .parentBox下面的所有的p标签绑定事件</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>缺点：只能注册委托事件，因此注册时间需要记得方法太多了</p><blockquote><p>on注册事件</p></blockquote><h3 id="on注册事件-重点"><a href="#on注册事件-重点" class="headerlink" title="on注册事件(重点)"></a>on注册事件(重点)</h3><blockquote><p>jQuery1.7之后，jQuery用on统一了所有事件的处理方法。</p><p>最现代的方式，兼容zepto(移动端类似jQuery的一个库)，强烈建议使用。</p></blockquote><p>on注册简单事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示给$(selector)绑定事件，并且由自己触发，不支持动态绑定。</span></span><br><span class="line">$(selector).on( <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;);</span><br></pre></td></tr></table></figure><p>on注册委托事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示给$(selector)绑定代理事件，当必须是它的内部元素span才能触发这个事件，支持动态绑定</span></span><br><span class="line">$(selector).on( <span class="string">"click"</span>,<span class="string">'span'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;);</span><br></pre></td></tr></table></figure><p>on注册事件的语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个参数：events，绑定事件的名称可以是由空格分隔的多个事件（标准事件或者自定义事件）</span></span><br><span class="line"><span class="comment">// 第二个参数：selector, 执行事件的后代元素（可选），如果没有后代元素，那么事件将有自己执行。</span></span><br><span class="line"><span class="comment">// 第三个参数：data，传递给处理函数的数据，事件触发的时候通过event.data来使用（不常使用）</span></span><br><span class="line"><span class="comment">// 第四个参数：handler，事件处理函数</span></span><br><span class="line">$(selector).on(events,[selector],[data],handler);</span><br></pre></td></tr></table></figure><h3 id="事件解绑"><a href="#事件解绑" class="headerlink" title="事件解绑"></a>事件解绑</h3><blockquote><p>unbind方式（不用）</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(selector).unbind(); <span class="comment">//解绑所有的事件</span></span><br><span class="line">$(selector).unbind(<span class="string">"click"</span>); <span class="comment">//解绑指定的事件</span></span><br></pre></td></tr></table></figure><blockquote><p>undelegate方式（不用）</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$( selector ).undelegate(); <span class="comment">//解绑所有的delegate事件</span></span><br><span class="line">$( selector).undelegate( <span class="string">'click'</span> ); <span class="comment">//解绑所有的click事件</span></span><br></pre></td></tr></table></figure><blockquote><p>off方式（推荐）</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解绑匹配元素的所有事件</span></span><br><span class="line">$(selector).off();</span><br><span class="line"><span class="comment">// 解绑匹配元素的所有click事件</span></span><br><span class="line">$(selector).off(<span class="string">"click"</span>);</span><br></pre></td></tr></table></figure><h3 id="触发事件"><a href="#触发事件" class="headerlink" title="触发事件"></a>触发事件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(selector).click(); <span class="comment">//触发 click事件</span></span><br><span class="line">$(selector).trigger(<span class="string">"click"</span>);</span><br></pre></td></tr></table></figure><h3 id="jQuery事件对象"><a href="#jQuery事件对象" class="headerlink" title="jQuery事件对象"></a>jQuery事件对象</h3><p>jQuery事件对象其实就是js事件对象的一个封装，处理了兼容性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//screenX和screenY对应屏幕最左上角的值</span></span><br><span class="line"><span class="comment">//clientX和clientY距离页面左上角的位置（忽视滚动条）</span></span><br><span class="line"><span class="comment">//pageX和pageY距离页面最顶部的左上角的位置（会计算滚动条的距离）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//event.keyCode按下的键盘代码</span></span><br><span class="line"><span class="comment">//event.data存储绑定事件时传递的附加数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//event.stopPropagation()阻止事件冒泡行为</span></span><br><span class="line"><span class="comment">//event.preventDefault()阻止浏览器默认行为</span></span><br><span class="line"><span class="comment">//return false:既能阻止事件冒泡，又能阻止浏览器默认行为。</span></span><br></pre></td></tr></table></figure><h2 id="jQuery补充知识点"><a href="#jQuery补充知识点" class="headerlink" title="jQuery补充知识点"></a>jQuery补充知识点</h2><h3 id="链式编程"><a href="#链式编程" class="headerlink" title="链式编程"></a>链式编程</h3><blockquote><p>通常情况下，只有设置操作才能把链式编程延续下去。因为获取操作的时候，会返回获取到的相应的值，无法返回 jQuery对象。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">end(); <span class="comment">// 筛选选择器会改变jQuery对象的DOM对象，想要回复到上一次的状态，并且返回匹配元素之前的状态。</span></span><br></pre></td></tr></table></figure><p>【案例：五角星评分案例.html】</p><h3 id="each方法"><a href="#each方法" class="headerlink" title="each方法"></a>each方法</h3><blockquote><p>jQuery的隐式迭代会对所有的DOM对象设置相同的值，但是如果我们需要给每一个对象设置不同的值的时候，就需要自己进行迭代了。</p></blockquote><p>作用：遍历jQuery对象集合，为每个匹配的元素执行一个函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数一表示当前元素在所有匹配元素中的索引号</span></span><br><span class="line"><span class="comment">// 参数二表示当前元素（DOM对象）</span></span><br><span class="line">$(selector).each(<span class="function"><span class="keyword">function</span>(<span class="params">index,element</span>)</span>&#123;&#125;);</span><br></pre></td></tr></table></figure><p>【案例：不同的透明度.html】</p><h3 id="多库共存"><a href="#多库共存" class="headerlink" title="多库共存"></a>多库共存</h3><blockquote><p>jQuery使用$作为标示符，但是如果与其他框架中的$冲突时，jQuery可以释放$符的控制权.</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = $.noConflict();<span class="comment">//释放$的控制权,并且把$的能力给了c</span></span><br></pre></td></tr></table></figure><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h3><blockquote><p>插件：jquery不可能包含所有的功能，我们可以通过插件扩展jquery的功能。</p><p>jQuery有着丰富的插件，使用这些插件能给jQuery提供一些额外的功能。</p></blockquote><ol><li>jquery.color.js</li></ol><blockquote><p>animate不支持颜色的渐变，但是使用了jquery.color.js后，就可以支持颜色的渐变了。</p></blockquote><p>使用插件的步骤</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 引入jQuery文件</span></span><br><span class="line"><span class="comment">//2. 引入插件（如果有用到css的话，需要引入css）</span></span><br><span class="line"><span class="comment">//3. 使用插件</span></span><br></pre></td></tr></table></figure><ol start="2"><li>jquery.lazyload.js</li></ol><p>懒加载插件</p><h3 id="jquery-ui-js插件"><a href="#jquery-ui-js插件" class="headerlink" title="jquery.ui.js插件"></a>jquery.ui.js插件</h3><p>jQueryUI专指由jQuery官方维护的UI方向的插件。</p><p>官方API：<a href="http://api.jqueryui.com/category/all/" target="_blank" rel="noopener">http://api.jqueryui.com/category/all/</a></p><p>其他教程：<a href="http://www.runoob.com/jqueryui/jqueryui-tutorial.html" target="_blank" rel="noopener">jQueryUI教程</a></p><p>基本使用:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.引入jQueryUI的样式文件</span></span><br><span class="line"><span class="comment">//2.引入jQuery</span></span><br><span class="line"><span class="comment">//3.引入jQueryUI的js文件</span></span><br><span class="line"><span class="comment">//4.使用jQueryUI功能</span></span><br></pre></td></tr></table></figure><p>使用jquery.ui.js手风琴菜单</p><h2 id="制作jquery插件"><a href="#制作jquery插件" class="headerlink" title="制作jquery插件"></a>制作jquery插件</h2><blockquote><p>原理：jquery插件其实说白了就是给jquery对象增加一个新的方法，让jquery对象拥有某一个功能。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过给$.fn添加方法就能够扩展jquery对象</span></span><br><span class="line">$.fn. pluginName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;jquery基础整合&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="jQuery" scheme="http://yoursite.com/tags/jQuery/"/>
    
  </entry>
  
  <entry>
    <title>React 4</title>
    <link href="http://yoursite.com/2020/03/26/React-4/"/>
    <id>http://yoursite.com/2020/03/26/React-4/</id>
    <published>2020-03-26T13:32:53.000Z</published>
    <updated>2020-03-27T06:03:30.615Z</updated>
    
    <content type="html"><![CDATA[<h4 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h4><a id="more"></a><ul><li><p>概念：在组件创建、到加载到页面上运行、以及组件被销毁的过程中，总是伴随着各种各样的事件，这些在组件特定时期，触发的事件，统称为 组件的生命周期；</p></li><li><p>组件生命周期分为三部分：</p><ul><li><strong>组件创建阶段</strong>：组件创建阶段的生命周期函数，有一个显著的特点：创建阶段的生命周期函数，在组件的一辈子中，只执行一次；</li></ul><blockquote><p>componentWillMount: 组件将要被挂载，此时还没有开始渲染虚拟DOM<br>render：第一次开始渲染真正的虚拟DOM，当render执行完，内存中就有了完整的虚拟DOM了<br>componentDidMount: 组件完成了挂载，此时，组件已经显示到了页面上，当这个方法执行完，组件就进入都了 运行中 的状态</p></blockquote><ul><li><strong>组件运行阶段</strong>：也有一个显著的特点，根据组件的state和props的改变，有选择性的触发0次或多次；</li></ul><blockquote><p>componentWillReceiveProps: 组件将要接收新属性，此时，只要这个方法被触发，就证明父组件为当前子组件传递了新的属性值；<br>shouldComponentUpdate: 组件是否需要被更新，此时，组件尚未被更新，但是，state 和 props 肯定是最新的<br>componentWillUpdate: 组件将要被更新，此时，尚未开始更新，内存中的虚拟DOM树还是旧的<br>render: 此时，又要重新根据最新的 state 和 props 重新渲染一棵内存中的 虚拟DOM树，当 render 调用完毕，内存中的旧DOM树，已经被新DOM树替换了！此时页面还是旧的<br>componentDidUpdate: 此时，页面又被重新渲染了，state 和 虚拟DOM 和 页面已经完全保持同步</p></blockquote><ul><li><strong>组件销毁阶段</strong>：也有一个显著的特点，一辈子只执行一次；</li></ul><blockquote><p>componentWillUnmount: 组件将要被卸载，此时组件还可以正常使用；</p></blockquote></li></ul><p><a href="https://cn.vuejs.org/v2/guide/instance.html#生命周期图示" target="_blank" rel="noopener">vue中的生命周期图</a><br><a href="http://www.race604.com/react-native-component-lifecycle/" target="_blank" rel="noopener">React Native 中组件的生命周期</a></p><img src="/2020/03/26/React-4/React%E4%B8%AD%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" class><h5 id="defaultProps"><a href="#defaultProps" class="headerlink" title="defaultProps"></a>defaultProps</h5><blockquote><p>在组件创建之前，会先初始化默认的props属性，这是全局调用一次，严格地来说，这不是组件的生命周期的一部分。在组件被创建并加载候，首先调用 constructor 构造器中的 this.state = {}，来初始化组件的状态。</p></blockquote><p>React生命周期的回调函数总结成表格如下：</p><img src="/2020/03/26/React-4/React%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%A1%A8%E6%A0%BC.png" class><ul><li><p>Mounting：</p><ul><li>constructor()</li><li>componentWillMount()</li><li>render()</li><li>componentDidMount()</li></ul></li><li><p>Updating：</p><ul><li>componentWillReceiveProps(nextProps)</li><li>shouldComponentUpdate(nextProps, nextState)</li><li>componentWillUpdate(nextProps, nextState)</li><li>render()</li><li>componentDidUpdate(prevProps, prevState)</li></ul></li><li><p>Unmounting：</p><ul><li>componentWillUnmount()</li></ul></li></ul><h4 id="通过Counter计数器的小案例-了解生命周期函数"><a href="#通过Counter计数器的小案例-了解生命周期函数" class="headerlink" title="通过Counter计数器的小案例 - 了解生命周期函数"></a>通过Counter计数器的小案例 - 了解生命周期函数</h4><ol><li>给组件设置默认属性：</li><li>给属性进行类型校验，需要先运行<code>cnpm i prop-types --save</code></li></ol><h4 id="组件初始化时生命周期事件总结"><a href="#组件初始化时生命周期事件总结" class="headerlink" title="组件初始化时生命周期事件总结"></a>组件初始化时生命周期事件总结</h4><ol><li>componentWillMount：</li><li>render：</li><li>componentDidMount：</li><li>注意：在render函数中，不能调用<code>setState()</code>方法</li></ol><h4 id="通过原生的方式获取元素并绑定事件"><a href="#通过原生的方式获取元素并绑定事件" class="headerlink" title="通过原生的方式获取元素并绑定事件"></a>通过原生的方式获取元素并绑定事件</h4><h4 id="React中使用ref属性获取DOM元素引用"><a href="#React中使用ref属性获取DOM元素引用" class="headerlink" title="React中使用ref属性获取DOM元素引用"></a>React中使用ref属性获取DOM元素引用</h4><h4 id="使用React中的事件，绑定count自增"><a href="#使用React中的事件，绑定count自增" class="headerlink" title="使用React中的事件，绑定count自增"></a>使用React中的事件，绑定count自增</h4><h4 id="组件运行中事件的对比"><a href="#组件运行中事件的对比" class="headerlink" title="组件运行中事件的对比"></a>组件运行中事件的对比</h4><ol><li>shouldComponentUpdate：</li><li>componentWillUpdate：</li><li>render：</li><li>componentDidUpdate：</li></ol><h4 id="绑定this并传参的三种方式"><a href="#绑定this并传参的三种方式" class="headerlink" title="绑定this并传参的三种方式"></a>绑定this并传参的三种方式</h4><ol><li>在事件中绑定this并传参：</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"button"</span> value=<span class="string">"在事件中绑定this并传参"</span> onClick=&#123;<span class="keyword">this</span>.handleMsg1.bind(<span class="keyword">this</span>, <span class="string">'🍕'</span>, <span class="string">'🍟'</span>)&#125; /&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在事件中绑定this并传参</span></span><br><span class="line">handleMsg1(arg1, arg2) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 此时this是个null</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        msg: <span class="string">'在事件中绑定this并传参：'</span> + arg1 + arg2</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>在构造函数中绑定this并传参:</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改构造函数中的代码：</span></span><br><span class="line"><span class="keyword">this</span>.handleMsg2 = <span class="keyword">this</span>.handleMsg2.bind(<span class="keyword">this</span>, <span class="string">'🚗'</span>, <span class="string">'🚚'</span>);</span><br><span class="line"></span><br><span class="line">&lt;input type=<span class="string">"button"</span> value=<span class="string">"在构造函数中绑定this并传参"</span> onClick=&#123;<span class="keyword">this</span>.handleMsg2&#125; /&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在构造函数中绑定this并传参</span></span><br><span class="line">handleMsg2(arg1, arg2) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        msg: <span class="string">'在构造函数中绑定this并传参：'</span> + arg1 + arg2</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>用箭头函数绑定this并传参：</p><p>箭头函数 本身就是一个 匿名的 function函数</p><p>function默认的this，谁调用这个function，this就指向谁</p><p>但箭头函数 this指向 外层 上下文</p></li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    &lt;input type=<span class="string">"button"</span> value=<span class="string">"用箭头函数绑定this并传参"</span> onClick=&#123;() =&gt; &#123; <span class="keyword">this</span>.handleMsg3(<span class="string">'👩'</span>, <span class="string">'👰'</span>) &#125;&#125; /&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用箭头函数绑定this并传参</span></span><br><span class="line">        handleMsg3(arg1, arg2) &#123;</span><br><span class="line">            <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">                msg: <span class="string">'用箭头函数绑定this并传参：'</span> + arg1 + arg2</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// ----------------------------------------------------------------- //</span></span><br><span class="line"></span><br><span class="line">handleMsg3 = <span class="function">(<span class="params">arg1, arg2</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">                msg: <span class="string">'用箭头函数绑定this并传参：'</span> + arg1 + arg2</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h4 id="绑定文本框与state中的值"><a href="#绑定文本框与state中的值" class="headerlink" title="绑定文本框与state中的值"></a>绑定文本框与state中的值</h4><ol><li>在Vue.js中，默认可以通过<code>v-model</code>指令，将表单控件和我们的<code>data</code>上面的属性进行双向数据绑定，数据变化和页面之间的变化是同步的！</li><li>在React.js中，默认没有提供双向数据绑定这一功能，默认的，只能把<code>state</code>之上的数据同步到界面的控件上，但是不能默认实现把界面上数据的改变，同步到<code>state</code>之上，需要程序员手动调用相关的事件，来进行逆向的数据传输！</li><li>绑定文本框和state的值：</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="comment">/*只要将value属性，和state上的状态进行绑定，那么，这个表单元素就变成了受控表单元素，这时候，如果没有调用相关的事件，是无法手动修改表单元素中的值的*/</span>&#125;</span><br><span class="line">&lt;input style=&#123;&#123; <span class="attr">width</span>: <span class="string">'100%'</span> &#125;&#125; ref=<span class="string">"txt"</span> type=<span class="string">"text"</span> value=&#123;<span class="keyword">this</span>.state.msg&#125; onChange=&#123;<span class="keyword">this</span>.handleTextChange&#125; /&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是文本框内容改变时候的处理函数</span></span><br><span class="line">handleTextChange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        msg: <span class="keyword">this</span>.refs.txt.value</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2020/03/26/React-4/%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A.png" class><ol start="4"><li><p>注意 <code>setState</code>的一个问题：</p><p>在 <code>setState</code>， 只会把 对应的 state 状态更新，而不会 覆盖其他的state状态</p><p><code>this.setState</code>  方法的执行 是异步的</p></li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存最新的state状态值，在保存的时候，是异步地进行保存的，所以，如果想要获取最新的，刚刚保存的那个状态，需要通过回掉函数的形式去获取最新state</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    msg: <span class="keyword">this</span>.refs.txt.value</span><br><span class="line">    <span class="comment">// msg: e.target.value</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取最新的state状态值</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.msg);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="发表评论案例"><a href="#发表评论案例" class="headerlink" title="发表评论案例"></a>发表评论案例</h4><h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><h5 id="context特性"><a href="#context特性" class="headerlink" title="context特性"></a>context特性</h5><p>记住一串单词组合<code>getChildContextTypes</code><br>前3个、后3个、后两个<br>一个方法、两个静态属性</p><h4 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h4><p><a href="https://facebook.github.io/react/docs/typechecking-with-proptypes.html" target="_blank" rel="noopener">类型校验</a><br><a href="https://reactjs.org/docs/animation.html#high-level-api-reactcsstransitiongroup" target="_blank" rel="noopener">Animation Add-Ons</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;组件的生命周期&quot;&gt;&lt;a href=&quot;#组件的生命周期&quot; class=&quot;headerlink&quot; title=&quot;组件的生命周期&quot;&gt;&lt;/a&gt;组件的生命周期&lt;/h4&gt;
    
    </summary>
    
    
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>ES6-class关键字02</title>
    <link href="http://yoursite.com/2020/03/25/ES6-class%E5%85%B3%E9%94%AE%E5%AD%9702/"/>
    <id>http://yoursite.com/2020/03/25/ES6-class%E5%85%B3%E9%94%AE%E5%AD%9702/</id>
    <published>2020-03-25T14:12:12.000Z</published>
    <updated>2020-03-27T04:42:17.342Z</updated>
    
    <content type="html"><![CDATA[<h4 id="class关键字-继承"><a href="#class关键字-继承" class="headerlink" title="class关键字(继承)"></a>class关键字(继承)</h4><a id="more"></a><p>class-继承</p><p>语法： class 子类 extends 父类 {}</p><p>父类 Person</p><p>子类 American</p><p>子类 Chinese</p><h5 id="继承公共实例属性"><a href="#继承公共实例属性" class="headerlink" title="继承公共实例属性"></a>继承公共实例属性</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把父类 理解成 原型对象 prototype</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name, age)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在class类中，使用extends 关键字，实现子类继承父类</span></span><br><span class="line"><span class="comment">// 语法： class 子类 extends 父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">American</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a1 = <span class="keyword">new</span> American(<span class="string">'Jack'</span>, <span class="number">20</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c1 = <span class="keyword">new</span> Chinese(<span class="string">'张三'</span>, <span class="number">22</span>)</span><br><span class="line"><span class="built_in">console</span>.log(c1)</span><br></pre></td></tr></table></figure><h5 id="继承公共实例方法"><a href="#继承公共实例方法" class="headerlink" title="继承公共实例方法"></a>继承公共实例方法</h5><p>子类通过extends 关键字继承了父类，那么子类的 constructor 构造函数中，必须先调用一下 super() </p><p>super是一个函数 其实就是父类的 构造器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name, age)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实例方法</span></span><br><span class="line">    sayHello()&#123;</span><br><span class="line">        consolo.log(<span class="string">'大家好'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">American</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name, age)&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a1 = <span class="keyword">new</span> American(<span class="string">'Jack'</span>, <span class="number">20</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a1)</span><br><span class="line"><span class="built_in">console</span>.log(a1.sayHello)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name, age, IDNumber)&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, age)</span><br><span class="line">        <span class="keyword">this</span>.IDNumber = IDNumber<span class="comment">//挂载子类独有的实例属性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c1 = <span class="keyword">new</span> Chinese(<span class="string">'张三'</span>, <span class="number">22</span>, <span class="string">'130020*****'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(c1)</span><br><span class="line"><span class="built_in">console</span>.log(c1.sayHello)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;class关键字-继承&quot;&gt;&lt;a href=&quot;#class关键字-继承&quot; class=&quot;headerlink&quot; title=&quot;class关键字(继承)&quot;&gt;&lt;/a&gt;class关键字(继承)&lt;/h4&gt;
    
    </summary>
    
    
    
      <category term="es6" scheme="http://yoursite.com/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>ES6-class关键字01</title>
    <link href="http://yoursite.com/2020/03/25/ES6-class%E5%85%B3%E9%94%AE%E5%AD%9701/"/>
    <id>http://yoursite.com/2020/03/25/ES6-class%E5%85%B3%E9%94%AE%E5%AD%9701/</id>
    <published>2020-03-25T10:44:46.000Z</published>
    <updated>2020-03-27T04:41:10.566Z</updated>
    
    <content type="html"><![CDATA[<h4 id="class关键字"><a href="#class关键字" class="headerlink" title="class关键字"></a>class关键字</h4><a id="more"></a><p>class关键字，是实现面向对象编程的新形式</p><p>静态属性：通过构造函数，直接访问到的属性，叫做静态属性</p><p>实例属性：通过 new 出来的实例 访问到的属性，叫做 实例属性</p><h5 id="传统"><a href="#传统" class="headerlink" title="传统"></a>传统</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// info属性 直接挂在给构造函数Person，所以info是静态属性</span></span><br><span class="line">Person.info = <span class="string">'aaaaa'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态方法</span></span><br><span class="line">Person.show = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'这是 Person 的静态 show方法'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将方法say挂在到Person的原型对象上，成为了实例方法</span></span><br><span class="line">Person.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'这是 Person 的实例方法'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Person(<span class="string">'xiaoyi'</span>, <span class="number">18</span>)</span><br><span class="line"><span class="comment">// 通过 new 出来的实例 访问到的属性，叫做 实例属性</span></span><br><span class="line"><span class="built_in">console</span>.log(p1)</span><br><span class="line"><span class="built_in">console</span>.log(p1.name)</span><br><span class="line"><span class="built_in">console</span>.log(p1.age)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 实例对象 .出来的方法，就叫实例方法</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.say)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态方法 和 属性，只能由构造函数访问，实例对象不能访问</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.info)</span><br><span class="line"><span class="built_in">console</span>.log(Person.show)</span><br></pre></td></tr></table></figure><h5 id="class创建"><a href="#class创建" class="headerlink" title="class创建"></a>class创建</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 每一个类中，都有一个构造器（或隐藏）；每当new 这个类的时候，必然会优先执行 构造器中的代码</span></span><br><span class="line">    <span class="keyword">constructor</span>(name ,age)&#123;</span><br><span class="line">        <span class="comment">// 实例属性</span></span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">        <span class="keyword">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在class内部，通过static修饰的属性，就是静态属性</span></span><br><span class="line">    <span class="keyword">static</span> info = <span class="string">'aaaaa'</span></span><br><span class="line"><span class="comment">// 静态方法</span></span><br><span class="line"><span class="keyword">static</span> show()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'这是 Animal 的静态方法'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这也是挂在到原型对象上的一个实例方法，同say</span></span><br><span class="line"><span class="comment">// 经常会使用到实例方法</span></span><br><span class="line">see()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'这是 Animal 的实例方法'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a1 = <span class="keyword">new</span> Animal(<span class="string">'milu,10)</span></span><br><span class="line"><span class="string">console.log(a1)</span></span><br><span class="line"><span class="string">console.log(a1.name)</span></span><br><span class="line"><span class="string">console.log(a1.age)</span></span><br><span class="line"><span class="string">console.log(a1.see)</span></span><br><span class="line"><span class="string">console.log(Animal.info)</span></span><br><span class="line"><span class="string">console.log(Animal.show)</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><ol><li>在class的 { } 区间内，只能写 构造器、实例方法、静态方法和静态属性，其中 实例属性 在构造器中写</li><li>class 关键字的内部 ，还是用原来的方法实现的，所以我们把class关键字，称作 语法糖</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;class关键字&quot;&gt;&lt;a href=&quot;#class关键字&quot; class=&quot;headerlink&quot; title=&quot;class关键字&quot;&gt;&lt;/a&gt;class关键字&lt;/h4&gt;
    
    </summary>
    
    
    
      <category term="es6" scheme="http://yoursite.com/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>ES6-展开运算符</title>
    <link href="http://yoursite.com/2020/03/25/ES6-%E5%B1%95%E5%BC%80%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>http://yoursite.com/2020/03/25/ES6-%E5%B1%95%E5%BC%80%E8%BF%90%E7%AE%97%E7%AC%A6/</id>
    <published>2020-03-25T09:17:20.000Z</published>
    <updated>2020-03-27T04:41:23.821Z</updated>
    
    <content type="html"><![CDATA[<h4 id="展开运算符（spread-operator）"><a href="#展开运算符（spread-operator）" class="headerlink" title="展开运算符（spread operator）"></a>展开运算符（spread operator）</h4><a id="more"></a><p>展开运算符，允许一个表达式在某处展开。展开运算符在多个参数（用于函数调用）或多个元素（用于数组字面量）或者多个变量（用于解构赋值）的地方可以使用。</p><p>展开运算符不能用在对象当中，因为目前展开运算符只能在可遍历对象（iterables）可用。iterables的实现是依靠[Symbol.iterator]函数，而目前只有Array,Set,String内置[Symbol.iterator]方法，而Object尚未内置该方法，因此无法使用展开运算符。不过ES7草案当中已经加入了对象展开运算符特性。</p><h5 id="函数调用中使用展开运算符"><a href="#函数调用中使用展开运算符" class="headerlink" title="函数调用中使用展开运算符"></a>函数调用中使用展开运算符</h5><p>我们使用…展开运算符就可以把args直接传递给test()函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a,b,c</span>) </span>&#123; &#125;</span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line">test(...args);</span><br></pre></td></tr></table></figure><h5 id="数组字面量中使用展开运算符"><a href="#数组字面量中使用展开运算符" class="headerlink" title="数组字面量中使用展开运算符"></a>数组字面量中使用展开运算符</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">var</span> arr2=[...arr1,<span class="string">'d'</span>,<span class="string">'e'</span>]; <span class="comment">//['a','b','c','d','e']</span></span><br></pre></td></tr></table></figure><p>展开运算符也可以用在push函数中，可以不用再用apply()函数来合并两个数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">var</span> arr2=[<span class="string">'d'</span>,<span class="string">'e'</span>];</span><br><span class="line">arr1.push(...arr2); <span class="comment">//['a','b','c','d','e']</span></span><br></pre></td></tr></table></figure><h5 id="用于解构赋值"><a href="#用于解构赋值" class="headerlink" title="用于解构赋值"></a>用于解构赋值</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [arg1,arg2,...arg3] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">arg1 <span class="comment">//1</span></span><br><span class="line">arg2 <span class="comment">//2</span></span><br><span class="line">arg3 <span class="comment">//['3','4']</span></span><br></pre></td></tr></table></figure><p>展开运算符在解构赋值中的作用跟之前的作用看上去是相反的，将多个数组项组合成了一个新数组。</p><p>不过要注意，解构赋值中展开运算符只能用在最后</p><h5 id="类数组对象变成数组"><a href="#类数组对象变成数组" class="headerlink" title="类数组对象变成数组"></a>类数组对象变成数组</h5><p>展开运算符可以将一个类数组对象变成一个真正的数组对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list=<span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>);</span><br><span class="line"><span class="keyword">var</span> arr=[..list];</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;展开运算符（spread-operator）&quot;&gt;&lt;a href=&quot;#展开运算符（spread-operator）&quot; class=&quot;headerlink&quot; title=&quot;展开运算符（spread operator）&quot;&gt;&lt;/a&gt;展开运算符（spread operator）&lt;/h4&gt;
    
    </summary>
    
    
    
      <category term="es6" scheme="http://yoursite.com/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>React 3</title>
    <link href="http://yoursite.com/2020/03/24/React-3/"/>
    <id>http://yoursite.com/2020/03/24/React-3/</id>
    <published>2020-03-24T09:44:33.000Z</published>
    <updated>2020-03-29T03:41:32.675Z</updated>
    
    <content type="html"><![CDATA[<h4 id="React（转载）"><a href="#React（转载）" class="headerlink" title="React（转载）"></a>React（转载）</h4><a id="more"></a><blockquote><p>学习文档转自黑马教程</p></blockquote><h4 id="ReactJS简介"><a href="#ReactJS简介" class="headerlink" title="ReactJS简介"></a>ReactJS简介</h4><ul><li>React 起源于 Facebook 的内部项目，因为该公司对市场上所有 JavaScript MVC 框架，都不满意，就决定自己写一套，用来架设 Instagram 的网站。做出来以后，发现这套东西很好用，<strong>就在2013年5月开源了</strong>。</li><li>由于 React 的设计思想极其独特，属于革命性创新，性能出众，代码逻辑却非常简单。所以，越来越多的人开始关注和使用，认为它可能是将来 Web 开发的主流工具。</li><li>library</li><li>Framework</li></ul><h4 id="前端三大主流框架"><a href="#前端三大主流框架" class="headerlink" title="前端三大主流框架"></a>前端三大主流框架</h4><ul><li>Angular.js：出来最早的前端框架，学习曲线比较陡，NG1学起来比较麻烦，NG2开始，进行了一系列的改革，也开始启用组件化了；在NG中，也支持使用TS（TypeScript）进行编程；</li><li>Vue.js：最火的一门前端框架，它是中国人开发的，对我我们来说，文档要友好一些；</li><li>React.js：最流行的一门框架，因为它的设计很优秀；</li><li>windowsPhone 7    7.5   8   10</li></ul><h4 id="React与vue-js的对比"><a href="#React与vue-js的对比" class="headerlink" title="React与vue.js的对比"></a>React与vue.js的对比</h4><h5 id="组件化方面"><a href="#组件化方面" class="headerlink" title="组件化方面"></a>组件化方面</h5><ol><li><p>什么是模块化：从 <strong>代码</strong> 的角度，去分析问题，把我们编程时候的业务逻辑，分割到不同的模块中来进行开发，这样能够<strong>方便代码的重用</strong>；</p></li><li><p>什么是组件化：从 <strong>UI</strong> 的角度，去分析问题，把一个页面，拆分为一些互不相干的小组件，随着我们项目的开发，我们手里的组件会越来越多，最后，我们如果要实现一个页面，可能直接把现有的组件拿过来进行拼接，就能快速得到一个完整的页面， 这样方<strong>便了UI元素的重用</strong>；<strong>组件是元素的集合体</strong>；</p></li><li><p>组件化的好处：</p></li><li><p>Vue是如何实现组件化的：.vue 组件模板文件，浏览器不识别这样的.vue文件，所以，在运行前，会把 .vue 预先编译成真正的组件；</p><ul><li>template： UI结构</li><li>script： 业务逻辑和数据</li><li>style： UI的样式</li></ul></li><li><p>React如何实现组件化：在React中实现组件化的时候，根本没有 像 .vue 这样的模板文件，而是，直接使用JS代码的形式，去创建任何你想要的组件；</p><ul><li>React中的组件，都是直接在 js 文件中定义的；</li><li>React的组件，并没有把一个组件 拆分为 三部分（结构、样式、业务逻辑），而是全部使用JS来实现一个组件的；（也就是说：结构、样式、业务逻辑是混合在JS里面一起编写出来的）</li></ul></li></ol><h5 id="开发团队方面"><a href="#开发团队方面" class="headerlink" title="开发团队方面"></a>开发团队方面</h5><ul><li>React是由FaceBook前端官方团队进行维护和更新的；因此，React的维护开发团队，技术实力比较雄厚；</li><li>Vue：第一版，主要是有作者 尤雨溪 专门进行维护的，当 Vue更新到 2.x 版本后，也有了一个小团队进行相关的维护和开发；</li></ul><h5 id="社区方面"><a href="#社区方面" class="headerlink" title="社区方面"></a>社区方面</h5><ul><li>在社区方面，React由于诞生的较早，所以社区比较强大，一些常见的问题、坑、最优解决方案，文档、博客在社区中都是可以很方便就能找到的；</li><li>Vue是近两年才诞生开源出来的，所以，它的社区相对于React来说，要小巧一些，所以，可能有的一些坑，没人踩过；</li></ul><h5 id="移动APP开发体验方面"><a href="#移动APP开发体验方面" class="headerlink" title="移动APP开发体验方面"></a>移动APP开发体验方面</h5><ul><li>Vue，结合 Weex 这门技术，提供了 迁移到 移动端App开发的体验（Weex，目前只是一个 小的玩具， 并没有很成功的 大案例；）</li><li>React，结合 ReactNative，也提供了无缝迁移到 移动App的开发体验（RN用的最多，也是最火最流行的）；</li></ul><h4 id="为什么要学习React"><a href="#为什么要学习React" class="headerlink" title="为什么要学习React"></a>为什么要学习React</h4><ol><li>设计很优秀，是基于组件化的，方便我们UI代码的重用；</li><li>开发团队实力强悍，不必担心短更的情况；</li><li>社区强大，很多问题都能找到对应的解决方案；</li><li>提供了无缝转到 ReactNative 上的开发体验，让我们技术能力得到了拓展；增强了我们的核心竞争力</li></ol><h4 id="React中几个核心的概念"><a href="#React中几个核心的概念" class="headerlink" title="React中几个核心的概念"></a>React中几个核心的概念</h4><h5 id="虚拟DOM（Virtual-Document-Object-Model）"><a href="#虚拟DOM（Virtual-Document-Object-Model）" class="headerlink" title="虚拟DOM（Virtual Document Object Model）"></a>虚拟DOM（Virtual Document Object Model）</h5><ul><li>DOM的本质是什么：就是用JS表示的UI元素</li><li>DOM和虚拟DOM的区别：<ul><li>DOM是由浏览器中的JS提供功能，所以我们只能人为的使用 浏览器提供的固定的API来操作DOM对象；</li><li>虚拟DOM：并不是由浏览器提供的，而是我们程序员手动模拟实现的，类似于浏览器中的DOM，但是有着本质的区别；</li></ul></li></ul><ul><li>为什么要实现虚拟DOM：</li><li>什么是React中的虚拟DOM：</li><li>虚拟DOM的目的：<img src="/2020/03/24/React-3/%E8%99%9A%E6%8B%9FDOM%E5%BC%95%E5%85%A5%E5%9B%BE%E7%89%87.png" class></li></ul><h5 id="Diff算法"><a href="#Diff算法" class="headerlink" title="Diff算法"></a>Diff算法</h5><ul><li>tree diff:新旧DOM树，逐层对比的方式，就叫做 tree diff,每当我们从前到后，把所有层的节点对比完后，必然能够找到那些 需要被更新的元素；</li><li>component diff：在对比每一层的时候，组件之间的对比，叫做 component diff;当对比组件的时候，如果两个组件的类型相同，则暂时认为这个组件不需要被更新，如果组件的类型不同，则立即将旧组件移除，新建一个组件，替换到被移除的位置；</li><li>element diff:在组件中，每个元素之间也要进行对比，那么，元素级别的对比，叫做 element diff；</li><li>key：key这个属性，可以把 页面上的 DOM节点 和 虚拟DOM中的对象，做一层关联关系；<img src="/2020/03/24/React-3/Diff.png" class></li></ul><h4 id="React项目的创建"><a href="#React项目的创建" class="headerlink" title="React项目的创建"></a>React项目的创建</h4><ol><li><p>运行 <code>cnpm i react react-dom -S</code> 安装包</p><p>1.1 react 这个包，是专门用来创建React组件、创建虛擬DOM、组件生命周期等这些东西的；<br>1.2 react-dom 里面主要封装了和 DOM 操作相关的包，进行DOM操作，最主要的应用场景是 ReactDOM， render()</p></li><li><p>在项目中导入两个相关的包：</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br></pre></td></tr></table></figure><ol start="3"><li><p>使用JS的创建虚拟DOM节点：</p><p>在 react 中，如要要创建 DOM 元素了，只能使用 React 提供的 JS API 来创建，不能【直接】像 Vue 中那样，手写 HTML 元素</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// React.createElement() 方法，用于创建 虚拟DOM 对象，它接收 3个及以上的参数</span></span><br><span class="line">   <span class="comment">// 参数1： 是个字符串类型的参数，表示要创建的元素类型</span></span><br><span class="line">   <span class="comment">// 参数2： 是一个属性对象，表示 创建的这个元素上，有哪些属性</span></span><br><span class="line">   <span class="comment">// 参数3： 从第三个参数的位置开始，后面可以放好多的虚拟DOM对象，这写参数，表示当前元素的子节点</span></span><br><span class="line">   <span class="comment">// &lt;div title="this is a div" id="mydiv"&gt;这是一个div&lt;/div&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> myH1 = React.createElement(<span class="string">'h1'</span>, <span class="literal">null</span>, <span class="string">'这是一个大大的H1'</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> myDiv = React.createElement(<span class="string">'div'</span>, &#123; <span class="attr">title</span>: <span class="string">'this is a div'</span>, <span class="attr">id</span>: <span class="string">'mydiv'</span> &#125;, <span class="string">'这是一个div'</span>, myH1)</span><br></pre></td></tr></table></figure><ol start="4"><li>使用 ReactDOM 把元素渲染到页面指定的容器中：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReactDOM.render('要渲染的虚拟DOM元素', '要渲染到页面上的哪个位置中')</span></span><br><span class="line"><span class="comment">// 注意： ReactDOM.render() 方法的第二个参数，和vue不一样，不接受 "#app" 这样的字符串，而是需要传递一个 原生的 DOM 对象</span></span><br><span class="line">ReactDOM.render(myDiv, <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>))</span><br></pre></td></tr></table></figure><h4 id="JSX语法-配合官方jsx文档"><a href="#JSX语法-配合官方jsx文档" class="headerlink" title="JSX语法 (配合官方jsx文档)"></a>JSX语法 (配合官方jsx文档)</h4><p>​    <em>Babel 是一个 JavaScript 编译器。（把浏览器不认识的语法，编译成浏览器认识的语法。）</em></p><p>​    <em>webpack 是一个现代 JavaScript 应用程序的静态模块打包器。（项目打包）</em></p><ol><li><p>如要要使用 JSX 语法，必须先运行 <code>cnpm i babel-preset-react -D</code>，然后再 <code>.babelrc</code> 中添加 语法配置；</p><p>运行 <code>cnpm i babel-core babel-loader babel-plugin-transform-runtime -D</code></p><p>运行 <code>cnpm i babel-present-env babel-preset-stage -D</code></p></li><li><p>JSX语法的本质：还是以 React.createElement 的形式来实现的，并没有直接把 用户写的 HTML代码，渲染到页面上；</p></li><li><p>如果要在 JSX 语法内部，书写 JS 代码了，那么，所有的JS代码，必须写到 {} 内部；</p><ul><li><p>渲染数字</p></li><li><p>渲染字符串</p></li><li><p>渲染布尔值</p></li><li><p>为属性绑定值</p></li><li><p>渲染jsx元素</p></li><li><p>渲染jsx元素数组</p></li><li><p>将普通字符串数组 转为jsx数组并渲染到页面上</p><p>eg：<code>let a = 10</code></p></li></ul><p>​        <code>&lt;div&gt; {a} &lt;/div&gt;</code></p><p>​        <code>&lt;div&gt; {a+2} &lt;/div&gt;</code>  也可以进行基本的运算</p><img src="/2020/03/24/React-3/r1.png" class></li><li><p>当 编译引擎，在编译JSX代码的时候，如果遇到了<code>&lt;</code>那么就把它当作 HTML代码去编译，如果遇到了 <code>{}</code> 就把 花括号内部的代码当作 普通JS代码去编译；</p></li><li><p>在{}内部，可以写任何符合JS规范的代码；</p></li><li><p>在JSX中，如果要为元素添加<code>class</code>属性了，那么，必须写成<code>className</code>，因为 <code>class</code>在ES6中是一个关键字；和<code>class</code>类似，label标签的 <code>for</code> 属性需要替换为 <code>htmlFor</code>.</p></li><li><p>在JSX创建DOM的时候，所有的节点，必须有唯一的根元素进行包裹；</p></li><li><p>如果要写注释了，注释必须放到 <code>{/* */}</code> 内部</p></li></ol><h4 id="React中：第一种创建组件的方式"><a href="#React中：第一种创建组件的方式" class="headerlink" title="React中：第一种创建组件的方式"></a>React中：第一种创建组件的方式</h4><blockquote><p>使用构造构造函数来创造组件，如果要接收外界传递的数据，需要再 构造函数的参数列表中使用<code>props</code>来接收；必须要向外return一个合法的JSX创建的虚拟DOM</p></blockquote><ul><li><p>创建组件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：组件首字母必须是大写</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">// return null</span></span><br><span class="line"><span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello 组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>为组件传递数据：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用组件，并为组件传递props 数据</span></span><br><span class="line">&lt;Hello name=&#123;dog.name&#125; age=&#123;dog.age&#125; gender=&#123;dog.gender&#125;&gt;&lt;<span class="regexp">/Hello&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 在构造函数中，使用props 形参，接收外界传递过来的数据</span></span><br><span class="line"><span class="regexp">function Hello(props)&#123;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ props.name = 'zs'</span></span><br><span class="line"><span class="regexp">console.log(props)</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 结论：不论是 Vue 还是 React，组建中的props 永远都是只读的；不被重新赋值；</span></span><br><span class="line"><span class="regexp">return &lt;div&gt;Hello 组件----&#123;props.name&#125;----&#123;props.age&#125;----&#123;props.gender&#125;&lt;/</span>div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="父组件向子组件传递数据"><a href="#父组件向子组件传递数据" class="headerlink" title="父组件向子组件传递数据"></a>父组件向子组件传递数据</h5><h5 id="使用-…obj-属性扩散传递数据"><a href="#使用-…obj-属性扩散传递数据" class="headerlink" title="使用(…obj)属性扩散传递数据"></a>使用(…obj)属性扩散传递数据</h5><h5 id="将组件封装到单独的文件中"><a href="#将组件封装到单独的文件中" class="headerlink" title="将组件封装到单独的文件中"></a>将组件封装到单独的文件中</h5><h4 id="React中：第二种创建组件的方式"><a href="#React中：第二种创建组件的方式" class="headerlink" title="React中：第二种创建组件的方式"></a>React中：第二种创建组件的方式</h4><h5 id="了解ES6中class关键字的使用"><a href="#了解ES6中class关键字的使用" class="headerlink" title="了解ES6中class关键字的使用"></a>了解ES6中class关键字的使用</h5><h5 id="基于class关键字创建组件"><a href="#基于class关键字创建组件" class="headerlink" title="基于class关键字创建组件"></a>基于class关键字创建组件</h5><ul><li><p>使用 class 关键字来创建组件</p><p>render 函数的作用： 是渲染 当前组件所对应的 虚拟DOM元素</p><p>类中的 this 指向这个类的实例对象</p></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">       </span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">super</span>()</span><br><span class="line">        <span class="comment">// 这个this.state = &#123;&#125; 相当于vue中的data()&#123;return&#123;&#125;&#125;</span></span><br><span class="line">        <span class="comment">// 这个是可读可写的</span></span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            msg : <span class="string">'大家好！'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 在class创建的组件中，必须定义一个render函数</span></span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="comment">// 在render函数中，必须返回一个null或者符合规范的虚拟DOM元素</span></span><br><span class="line">        <span class="comment">// 在 class关键字创建的组件中，如果想使用 外界传递过来的 props 参数，不需要接收，直接通过 this.props.***</span></span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是用 class 关键字创建的组件！--- &#123; this.props.name &#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span> &#123; this.state.msg &#125; <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 Person 标签,就是 上面Person 类的一个实例对象</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">    name=<span class="string">'zs'</span></span><br><span class="line">    age=<span class="number">22</span></span><br><span class="line">    gender:<span class="string">'男'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//&lt;Person name=&#123;user.name&#125; age=&#123;user.age&#125;&gt;&lt;/Person&gt;</span></span><br><span class="line">&lt;Person &#123;...user&#125;&gt;&lt;<span class="regexp">/Person&gt;</span></span><br></pre></td></tr></table></figure><h4 id="两种创建组件方式的对比"><a href="#两种创建组件方式的对比" class="headerlink" title="两种创建组件方式的对比"></a>两种创建组件方式的对比</h4><blockquote><p>注意：使用class关键字创建的组件，有自己的私有数据和生命周期函数</p><p>​            使用function创建的组件，只有props，没有自己的私有数据和生命周期函数</p></blockquote><ol><li>用构造函数创建出来的组件：专业的名字叫做“无状态组件”</li><li>用class关键字创建出来的组件：专业的名字叫做“有状态组件”</li></ol><blockquote><p>用构造函数创建出来的组件，和用class创建出来的组件，这两种不同的组件之间的<strong>本质区别就是</strong>：有无state属性<br>有状态组件和无状态组件之间的本质区别就是：有无state属性 和 生命周期函数</p></blockquote><p>组件中的 <code>props</code> 和 <code>state/data</code> 之间的区别</p><ul><li>props 中的数据都是外界传递过来的</li><li>state/data 中的数据， 都是组件私有的（通过Ajax 获取回来的数据，一般都是私有数据）</li><li>props 中的数据 都是只读的，不能重新赋值</li><li>state/data 中的数据，都是可读可写的</li></ul><h4 id="一个小案例，巩固有状态组件和无状态组件的使用"><a href="#一个小案例，巩固有状态组件和无状态组件的使用" class="headerlink" title="一个小案例，巩固有状态组件和无状态组件的使用"></a>一个小案例，巩固有状态组件和无状态组件的使用</h4><h5 id="通过for循环生成多个组件"><a href="#通过for循环生成多个组件" class="headerlink" title="通过for循环生成多个组件"></a>通过for循环生成多个组件</h5><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CmtItem</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>评论人： &#123;props.user&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>评论内容： &#123;props.content&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CmtList</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">super</span>()</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;          </span><br><span class="line">            CommentList = [</span><br><span class="line">                &#123; <span class="attr">user</span>: <span class="string">'张三'</span>, <span class="attr">content</span>: <span class="string">'哈哈，沙发'</span> &#125;,</span><br><span class="line">                &#123; <span class="attr">user</span>: <span class="string">'张三2'</span>, <span class="attr">content</span>: <span class="string">'哈哈，板凳'</span> &#125;,</span><br><span class="line">                &#123; <span class="attr">user</span>: <span class="string">'张三3'</span>, <span class="attr">content</span>: <span class="string">'哈哈，凉席'</span> &#125;,</span><br><span class="line">                &#123; <span class="attr">user</span>: <span class="string">'张三4'</span>, <span class="attr">content</span>: <span class="string">'哈哈，砖头'</span> &#125;,</span><br><span class="line">                &#123; <span class="attr">user</span>: <span class="string">'张三5'</span>, <span class="attr">content</span>: <span class="string">'哈哈，楼下山炮'</span> &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">render()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span> 这是评论列表组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">            &#123;this.state.CommentList.map(item =&gt; <span class="tag">&lt;<span class="name">CmtItem</span> &#123;<span class="attr">...item</span>&#125; <span class="attr">key</span>=<span class="string">&#123;item.id&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">CmtItem</span>&gt;</span>)&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用render 函数渲染</span></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">CmtList</span>&gt;</span><span class="tag">&lt;/<span class="name">CmtList</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>))</span><br></pre></td></tr></table></figure><blockquote><p>注意：在webpack.config.js中配置 @ 代表绝对路径./src。</p><p>后面就不用    ./    这种相对路径了</p></blockquote><p>将父组件CmtList、子组件CmtItem抽离为.jsx文件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">CmtItem</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>评论人： &#123;props.user&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>评论内容： &#123;props.content&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 導入 评论项子组件</span></span><br><span class="line"><span class="keyword">import</span> CmtItem <span class="keyword">from</span> <span class="string">'@/components/CmtItem'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">CmtList</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">super</span>()</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;          </span><br><span class="line">            CommentList = [</span><br><span class="line">                &#123; <span class="attr">user</span>: <span class="string">'张三'</span>, <span class="attr">content</span>: <span class="string">'哈哈，沙发'</span> &#125;,</span><br><span class="line">                &#123; <span class="attr">user</span>: <span class="string">'张三2'</span>, <span class="attr">content</span>: <span class="string">'哈哈，板凳'</span> &#125;,</span><br><span class="line">                &#123; <span class="attr">user</span>: <span class="string">'张三3'</span>, <span class="attr">content</span>: <span class="string">'哈哈，凉席'</span> &#125;,</span><br><span class="line">                &#123; <span class="attr">user</span>: <span class="string">'张三4'</span>, <span class="attr">content</span>: <span class="string">'哈哈，砖头'</span> &#125;,</span><br><span class="line">                &#123; <span class="attr">user</span>: <span class="string">'张三5'</span>, <span class="attr">content</span>: <span class="string">'哈哈，楼下山炮'</span> &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">render()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span> 这是评论列表组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">            &#123;this.state.CommentList.map(item =&gt; <span class="tag">&lt;<span class="name">CmtItem</span> &#123;<span class="attr">...item</span>&#125; <span class="attr">key</span>=<span class="string">&#123;item.id&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">CmtItem</span>&gt;</span>)&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> CmtList <span class="keyword">from</span> <span class="string">'@/components/CmtList'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用render 函数渲染</span></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">CmtList</span>&gt;</span><span class="tag">&lt;/<span class="name">CmtList</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>))</span><br></pre></td></tr></table></figure><h5 id="style样式"><a href="#style样式" class="headerlink" title="style样式"></a>style样式</h5><h4 id="使用CSS模块化"><a href="#使用CSS模块化" class="headerlink" title="使用CSS模块化"></a>使用CSS模块化</h4><ol><li><p>可以在webpack.config.js中为css-loader启用模块化：</p><img src="/2020/03/24/React-3/r2.png" class></li><li><p>另外两种方法：</p><img src="/2020/03/24/React-3/r3.png" class></li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>理解React中虚拟DOM的概念<br>理解React中三种Diff算法的概念<br>使用JS中createElement的方式创建虚拟DOM<br>使用ReactDOM.render方法<br>使用JSX语法并理解其本质<br>掌握创建组件的两种方式<br>理解有状态组件和无状态组件的本质区别<br>理解props和state的区别</p><h4 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h4><ul><li><a href="http://www.cnblogs.com/tim100/p/6050514.html" target="_blank" rel="noopener">React数据流和组件间的沟通总结</a></li><li><a href="https://segmentfault.com/q/1010000005876655/a-1020000005876751" target="_blank" rel="noopener">单向数据流和双向绑定各有什么优缺点？</a></li><li><a href="https://www.zhihu.com/question/29504639?sort=created" target="_blank" rel="noopener">怎么更好的理解虚拟DOM?</a></li><li><a href="http://www.css88.com/react/index.html" target="_blank" rel="noopener">React中文文档 - 版本较低</a></li><li><a href="http://blog.csdn.net/yczz/article/details/49886061" target="_blank" rel="noopener">React 源码剖析系列 － 不可思议的 react diff</a></li><li><a href="http://www.infoq.com/cn/articles/react-dom-diff?from=timeline&isappinstalled=0" target="_blank" rel="noopener">深入浅出React（四）：虚拟DOM Diff算法解析</a></li><li><a href="http://www.cocoachina.com/webapp/20150721/12692.html" target="_blank" rel="noopener">一看就懂的ReactJs入门教程（精华版）</a></li><li><a href="http://www.ruanyifeng.com/blog/2016/06/css_modules.html" target="_blank" rel="noopener">CSS Modules 用法教程</a></li><li><a href="http://blog.csdn.net/itzhongzi/article/details/66045880" target="_blank" rel="noopener">将MarkDown转换为HTML页面</a></li><li><a href="https://jingyan.baidu.com/article/0320e2c1c9cf0e1b87507b26.html" target="_blank" rel="noopener">win7命令行 端口占用 查询进程号 杀进程</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;React（转载）&quot;&gt;&lt;a href=&quot;#React（转载）&quot; class=&quot;headerlink&quot; title=&quot;React（转载）&quot;&gt;&lt;/a&gt;React（转载）&lt;/h4&gt;
    
    </summary>
    
    
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>React 2</title>
    <link href="http://yoursite.com/2020/03/24/React-2/"/>
    <id>http://yoursite.com/2020/03/24/React-2/</id>
    <published>2020-03-24T02:20:35.000Z</published>
    <updated>2020-03-24T05:51:56.898Z</updated>
    
    <content type="html"><![CDATA[<h4 id="React中几个核心的概念​"><a href="#React中几个核心的概念​" class="headerlink" title="React中几个核心的概念​"></a>React中几个核心的概念​</h4><a id="more"></a><h5 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h5><p>（为了实现页面中，DOM元素的高效更新）</p><ul><li>DOM的本质：浏览器中的概念，用JS对象来表示 页面上的元素，并提供了操作DOM对象的API</li><li>什么是React中的虚拟DOM：框架中的概念， 用JS对象来模拟页面上的DOM和DOM嵌套</li><li>用JS对象的形式，来模拟页面上DOM嵌套关系。</li><li>提供新旧DOM树</li></ul><h5 id="DOM树的概念"><a href="#DOM树的概念" class="headerlink" title="DOM树的概念"></a>DOM树的概念</h5><p>​    一個网页呈现的过程：</p><ol><li>浏览器请求服务器获取页面HTML代码</li><li>浏览器先在内存中解析DOM结构，并在浏览器内存中，渲染出一颗DOM树</li><li>浏览器把DOM树呈现到页面上</li></ol><h5 id="Diff算法"><a href="#Diff算法" class="headerlink" title="Diff算法"></a>Diff算法</h5><ul><li><p>tree diff： 新旧两个DOM树，逐层对比的过程，就是Tree Diff，当整颗DOM逐层对比完毕，则所有需要被按需更新的元素，必然能够找到；</p></li><li><p>component diff：在进行Tree Diff的时候，每一层中，组件级别的对比，叫做Component Diff；</p><ul><li>如果对比前后，组件的类型相同，则暂时认为此组件不需要被更新；</li><li>对比后，组件类型不同，则需要移除旧组件，创建新组件，并追加到页面上；</li></ul></li><li><p>element diff：在进行组件对比的时候，如果两个组件类型相同，则需要进行元素级别的对比，叫做element diff。</p><img src="/2020/03/24/React-2/diff.png" class><p>​    </p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;React中几个核心的概念​&quot;&gt;&lt;a href=&quot;#React中几个核心的概念​&quot; class=&quot;headerlink&quot; title=&quot;React中几个核心的概念​&quot;&gt;&lt;/a&gt;React中几个核心的概念​&lt;/h4&gt;
    
    </summary>
    
    
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>React 1</title>
    <link href="http://yoursite.com/2020/03/23/React-1/"/>
    <id>http://yoursite.com/2020/03/23/React-1/</id>
    <published>2020-03-23T13:51:20.000Z</published>
    <updated>2020-03-24T02:19:20.696Z</updated>
    
    <content type="html"><![CDATA[<h4 id="React和Vue对比"><a href="#React和Vue对比" class="headerlink" title="React和Vue对比"></a>React和Vue对比</h4><a id="more"></a><h5 id="1-如何实现组件化"><a href="#1-如何实现组件化" class="headerlink" title="1.如何实现组件化"></a>1.如何实现组件化</h5><p>Vue: 通过 <em>.vue</em> 文件，来创建对应的<strong>组件</strong>;（Vue.component() 这也是一种)</p><p>(.vue 这种文件需要有vue-loader去编译（webpack里面的一个loader）)</p><p>eg: Home.vue</p><ul><li>template     结构</li><li>script           行为</li><li>style             样式</li></ul><p>App.js</p><p>import Home from ‘./Home.vue’</p><p>React: 有组件化的概念，但没有像vue这样的组件模板文件；React中，一切都是以JS来表现的；JS知识要合格，ES6和ES7(async await)需了解.</p><h5 id="2-团队"><a href="#2-团队" class="headerlink" title="2.团队"></a>2.团队</h5><p>React是有FaceBook前端官方团队进行维护和更新</p><p>Vue是以尤雨溪为主导的开源小团队</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;React和Vue对比&quot;&gt;&lt;a href=&quot;#React和Vue对比&quot; class=&quot;headerlink&quot; title=&quot;React和Vue对比&quot;&gt;&lt;/a&gt;React和Vue对比&lt;/h4&gt;
    
    </summary>
    
    
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>移动WEB开发之rem适配布局</title>
    <link href="http://yoursite.com/2020/03/23/%E7%A7%BB%E5%8A%A8WEB%E5%BC%80%E5%8F%91%E4%B9%8Brem%E9%80%82%E9%85%8D%E5%B8%83%E5%B1%80/"/>
    <id>http://yoursite.com/2020/03/23/%E7%A7%BB%E5%8A%A8WEB%E5%BC%80%E5%8F%91%E4%B9%8Brem%E9%80%82%E9%85%8D%E5%B8%83%E5%B1%80/</id>
    <published>2020-03-23T10:55:26.000Z</published>
    <updated>2020-03-31T07:10:17.421Z</updated>
    
    <content type="html"><![CDATA[<p>rem 移动开发中重要的一种布局</p><a id="more"></a><h4 id="rem-基础"><a href="#rem-基础" class="headerlink" title="rem 基础"></a>rem 基础</h4><h5 id="rem-单位"><a href="#rem-单位" class="headerlink" title="rem 单位"></a>rem 单位</h5><p>rem（root em）是一个相对单位，类似于em，em是父元素字体大小。em，比如，父元素的字体大小<code>font-size = 12px</code>，子元素中就可以以1em = 12px 用em 来表示单位去设置 宽高大小 等。</p><p>不同的是 rem 的基准是相对于 html 元素的字体大小</p><p>比如，根元素（html）设置font-size = 12px；非根元素width：2rem，则换成px表示就是24px</p><p>rem 优点：可以通过修改html里面的文字大小，来改变页面中元素的大小，可以整体控制</p><h5 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h5><ol><li><p>媒体查询（Media Query）是CSS3新语法</p><ul><li>使用@media 查询，可以针对不同的媒体类型定义不同的样式</li><li>@media 可以针对不同的屏幕尺寸设置不同的样式</li><li>当你重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面</li><li>目前针对很多苹果手机，Android手机，平板等设备都用得到多媒体查询</li></ul></li><li><p>语法规范</p><p>@media mediatype and|not|only （media feature）{CSS-Code；}</p><ul><li><p>用@media开头，注意@符号</p></li><li><p>mediatype 媒体类型</p><table><thead><tr><th>值</th><th>说明</th></tr></thead><tbody><tr><td>all</td><td>用于所有设备</td></tr><tr><td>print</td><td>用于打印机和打印预览</td></tr><tr><td>screen（常用）</td><td>用于电脑屏幕、平板电脑、智能手机</td></tr></tbody></table></li><li><p>关键字 and not only</p><p> and（常用）：可以将多个媒体特性链接到一起，相当于“且”</p><p> not：排除某个媒体类型，相当于“非”</p><p> only：指定某个特性的媒体类型</p></li><li><p>media feature 媒体特性 必须要有小括号包含</p><table><thead><tr><th>值</th><th>说明</th></tr></thead><tbody><tr><td>width</td><td>定义输出设备中页面课件区域的宽度</td></tr><tr><td>min-width</td><td>定于输出设备中页面最小可见区域宽度</td></tr><tr><td>max-width</td><td>定于输出设备中页面最大可见区域宽度</td></tr></tbody></table><p>eg：当宽度小于800px时，body背景色为粉色，当宽度小于400px时，背景色为黄色</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width:</span><span class="number">800px</span>)&#123;</span></span><br><span class="line">       body&#123;</span><br><span class="line">          background-color: pink;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width:</span><span class="number">400px</span>)&#123;</span></span><br><span class="line">       body&#123;</span><br><span class="line">          background-color: yellow;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>媒体查询+rem实现元素动态大小变化</p><p> rem单位是跟着html 根元素字体大小来变化的</p><p> 媒体查询可以根据不同设备宽度来修改样式</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span><span class="number">320px</span>)&#123;</span></span><br><span class="line">        html&#123;</span><br><span class="line"><span class="css">           <span class="selector-tag">font-size</span><span class="selector-pseudo">:50px</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span><span class="number">640px</span>)&#123;</span></span><br><span class="line">        html&#123;</span><br><span class="line"><span class="css">           <span class="selector-tag">font-size</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.top</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">height</span><span class="selector-pseudo">:1rem</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">width</span><span class="selector-pseudo">:.5rem</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">background-color</span><span class="selector-pseudo">:green</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">color</span>:<span class="selector-id">#fff</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">text-align</span><span class="selector-pseudo">:center</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">line-height</span><span class="selector-pseudo">:1rem</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"top"</span>&gt;</span></span><br><span class="line">        購物車</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>引入资源（理解）</p></li></ol><h4 id="rem-适配方案"><a href="#rem-适配方案" class="headerlink" title="rem 适配方案"></a>rem 适配方案</h4><ol><li>让一些不能等比自适应的元素，达到当设备尺寸发生改变的时候，等比例适配当前设备</li><li>使用媒体查询根据不同设备按比例设置html 的字体大小，然后页面元素使用rem 做尺寸单位，当html 字体大小变化，元素尺寸也会发生变化， 从而达到等比缩放的适配</li></ol><h5 id="rem-实际开发适配方案"><a href="#rem-实际开发适配方案" class="headerlink" title="rem 实际开发适配方案"></a>rem 实际开发适配方案</h5><p>① 按照设计稿与设备宽度的比例，动态计算并设置html 根标签的 font-size大小；（媒体查询）</p><p>② CSS中，设计稿元素的宽、高、相对位置等取值，按照同比例换算为rem为单位的值</p><h5 id="rem-适配方案技术使用"><a href="#rem-适配方案技术使用" class="headerlink" title="rem 适配方案技术使用"></a>rem 适配方案技术使用</h5><p>技术方案1：</p><ul><li><p>less</p></li><li><p>媒体查询</p></li><li><p>rem</p><p>设计稿中，常见宽度 750px or 720px；将宽度750px划分为15份，每一份为50px</p><p>通过媒体查询设置，当最小宽度为750px时，将html 的font-size 设置为50px；min-width：320px，font-size：21.33px。这样就能在不同屏幕下，进行等比例缩放</p></li></ul><p>技术方案2(推荐)：</p><ul><li>flexible.js</li><li>rem</li></ul><p>总结：</p><p>两种方案现在都存在</p><p>方案2 更简单，因为flexible.js解决了很大一部分</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;rem 移动开发中重要的一种布局&lt;/p&gt;
    
    </summary>
    
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
      <category term="网页布局" scheme="http://yoursite.com/tags/%E7%BD%91%E9%A1%B5%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title>移动WEB开发之flex布局</title>
    <link href="http://yoursite.com/2020/03/23/%E7%A7%BB%E5%8A%A8WEB%E5%BC%80%E5%8F%91%E4%B9%8Bflex%E5%B8%83%E5%B1%80/"/>
    <id>http://yoursite.com/2020/03/23/%E7%A7%BB%E5%8A%A8WEB%E5%BC%80%E5%8F%91%E4%B9%8Bflex%E5%B8%83%E5%B1%80/</id>
    <published>2020-03-23T10:38:26.000Z</published>
    <updated>2020-03-31T07:10:18.675Z</updated>
    
    <content type="html"><![CDATA[<h4 id="flex弹性布局"><a href="#flex弹性布局" class="headerlink" title="flex弹性布局"></a>flex弹性布局</h4><a id="more"></a><p>操作改变，布局简单，<strong>移动端</strong>应用很广泛</p><p>:fallen_leaf: :balance_scale::ear_of_rice::honey_pot::horse_racing:</p><p>display: flex </p><p>justify-content: center|space-around</p><p>flex: 1</p><p>自适应 平均分配  在移动端比float浮动好用很多</p><ol><li><p>flex是flexible Box的缩写，意为弹性布局，用来为盒装模型提供最大的灵活性，任何一个容器都可以指定为flex布局</p><ul><li>当我们为父盒子设为flex 布局后，子元素的float、clear和vertical-align属性将失效</li><li>伸缩布局 = 弹性布局 = 伸缩盒布局 = flex布局</li></ul></li><li><p>采用flex布局的元素，成为flex容器，它的所有子元素自动成为容器成员，成为flex项目。</p><p>（通过给父盒子添加flex属性，来控制盒子的位置和排列方式）</p></li><li><p>常见父项属性</p><p>以下由6个属性是对父元素设置的</p><ul><li><p>flex-direction：设置<u>主轴</u>的方向</p><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>row</td><td>（默认）从左到右</td></tr><tr><td>row-reverse</td><td>从右到左</td></tr><tr><td>column</td><td>从上到下</td></tr><tr><td>column-reverse</td><td>从下到上</td></tr></tbody></table></li></ul></li></ol><ul><li><p>justify-content：设置<u>主轴</u>上的子元素排列方式</p><p>注意：使用这个属性之前，一定要确定好主轴是哪个</p><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>flex-start</td><td>（默认）从头部开始</td></tr><tr><td>flex-end</td><td>从尾部开始排列，顺序是不变的</td></tr><tr><td>center</td><td>在主轴居中对齐（如果主轴是x轴则居中）<em>最常用</em></td></tr><tr><td>space-around</td><td>平均剩余空间</td></tr><tr><td>space-between</td><td>先两边贴边 再平分剩余空间（重要）</td></tr></tbody></table></li></ul><ul><li><p>flex-wrap：设置子元素是否换行</p><p>注意：默认情况下，项目都排在一条线（轴）上，flex-wrap属性定义flex布局中默认是不换行的</p><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>nowrap</td><td>默认值，不换行</td></tr><tr><td>wrap</td><td>换行</td></tr></tbody></table></li></ul><ul><li><p>align-items：设置<u>侧轴</u>上的子元素排列方式（单行）</p><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>flex-start</td><td>（默认）从上到下</td></tr><tr><td>flex-end</td><td>从下到上</td></tr><tr><td>center</td><td>挤在一起居中（垂直居中）<em>最常用</em></td></tr><tr><td>stretch</td><td>拉伸</td></tr></tbody></table></li></ul><ul><li><p>align-content：设置<u>侧轴</u>上的子元素的排列方式（多行）</p><p>设置子项在侧轴上的排列方式并且只能用于子项出现<strong>换行</strong>的情况（多行），在单行下是没有效果的</p><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>flex-start</td><td>默认值在侧轴的头部开始排列</td></tr><tr><td>flex-end</td><td>在侧轴的尾部开始排列</td></tr><tr><td>center</td><td>在侧轴中间显示</td></tr><tr><td>space-around</td><td>子项在侧轴平分剩余空间</td></tr><tr><td>space-between</td><td>子项在侧轴 先分布在两头，再平分剩余空间</td></tr><tr><td>stretch</td><td>设置子项元素高度平分父元素高度</td></tr></tbody></table></li></ul><ul><li><p>flex-flow ：复合属性，相当于同时设置了flex-direction和flex-wrap</p><p><em>flex-flow ：row wrap；</em></p></li></ul><ol start="4"><li><p>flex布局子项常见属性</p><ul><li><p>flex子项目占的份数</p><p><em>flex ：1 ；</em>  <em>flex ： 2  ；</em></p></li><li><p>align-self控制子项自己在侧轴的排列方式</p></li><li><p>order属性定义子项的排列顺序（前后顺序）</p></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;flex弹性布局&quot;&gt;&lt;a href=&quot;#flex弹性布局&quot; class=&quot;headerlink&quot; title=&quot;flex弹性布局&quot;&gt;&lt;/a&gt;flex弹性布局&lt;/h4&gt;
    
    </summary>
    
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
      <category term="网页布局" scheme="http://yoursite.com/tags/%E7%BD%91%E9%A1%B5%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript03</title>
    <link href="http://yoursite.com/2020/03/18/TypeScript03/"/>
    <id>http://yoursite.com/2020/03/18/TypeScript03/</id>
    <published>2020-03-18T12:01:14.000Z</published>
    <updated>2020-03-27T04:45:31.120Z</updated>
    
    <content type="html"><![CDATA[<h4 id="TypeScript中的类（上）"><a href="#TypeScript中的类（上）" class="headerlink" title="TypeScript中的类（上）"></a>TypeScript中的类（上）</h4><a id="more"></a><p>es5里面的类</p><ol><li><h5 id="最简单的类"><a href="#最简单的类" class="headerlink" title="最简单的类"></a>最简单的类</h5></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'xiaoyi'</span></span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(p)</span><br><span class="line"><span class="built_in">console</span>.log(p.name)</span><br></pre></td></tr></table></figure><ol start="2"><li><h5 id="构造函数和原型链里面增加方法"><a href="#构造函数和原型链里面增加方法" class="headerlink" title="构造函数和原型链里面增加方法"></a>构造函数和原型链里面增加方法</h5></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'xiaoyi'</span>     <span class="comment">/*属性*/</span></span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">20</span></span><br><span class="line">  <span class="keyword">this</span>.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;   <span class="comment">/*实例方法*/</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'在运动'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.sex = <span class="string">'男'</span> <span class="comment">//在原型链上添加一个方法,原型链上面的属性会被多个实例共享</span></span><br><span class="line">Person.prototype.work = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'在工作'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(p.name)</span><br><span class="line"><span class="built_in">console</span>.log(p.sex)</span><br><span class="line">p.run()</span><br><span class="line">p.work()</span><br></pre></td></tr></table></figure><ol start="3"><li><h5 id="类里面的静态方法"><a href="#类里面的静态方法" class="headerlink" title="类里面的静态方法"></a>类里面的静态方法</h5></li><li><h5 id="es5里面的继承，对象冒充实现继承-原型鏈加对象冒充的组合继承模式"><a href="#es5里面的继承，对象冒充实现继承-原型鏈加对象冒充的组合继承模式" class="headerlink" title="es5里面的继承，对象冒充实现继承, 原型鏈加对象冒充的组合继承模式"></a>es5里面的继承，对象冒充实现继承, 原型鏈加对象冒充的组合继承模式</h5></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.name = <span class="string">'xiaoyi'</span> <span class="comment">/*属性*/</span></span><br><span class="line">   <span class="keyword">this</span>.age = <span class="number">20</span></span><br><span class="line">   <span class="keyword">this</span>.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">/*实例方法*/</span></span><br><span class="line">     <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'在运动'</span>)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> Person.prototype.sex = <span class="string">'男'</span> <span class="comment">//在原型链上添加一个方法,原型链上面的属性会被多个实例共享</span></span><br><span class="line"> Person.prototype.work = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'在工作'</span>)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> p = <span class="keyword">new</span> Person()</span><br><span class="line">   <span class="comment">// p.work()</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">// web类继承Person类  原型链加对象冒充的组合继承模式</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">Web</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   Person.call(<span class="keyword">this</span>) <span class="comment">/*改变this指向，对象冒充可以继承构造函数里面的属性和方法*/</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> w = <span class="keyword">new</span> Web()</span><br><span class="line"> w.run() <span class="comment">/*对象冒充可以继承构造函数里面的属性和方法*/</span></span><br><span class="line"> w.work() <span class="comment">/*但不能继承原型链上的属性和方法*/</span></span><br></pre></td></tr></table></figure><ol start="5"><li><h5 id="es5里面的继承，原型链实现继承"><a href="#es5里面的继承，原型链实现继承" class="headerlink" title="es5里面的继承，原型链实现继承"></a>es5里面的继承，原型链实现继承</h5></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'xiaoyi'</span> <span class="comment">/*属性*/</span></span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">20</span></span><br><span class="line">  <span class="keyword">this</span>.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">/*实例方法*/</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'在运动'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sex = <span class="string">'男'</span></span><br><span class="line">Person.prototype.work = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'在工作'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Web</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Web.prototype = <span class="keyword">new</span> Person() <span class="comment">/*原型链实现继承*/</span></span><br><span class="line"><span class="keyword">var</span> w = <span class="keyword">new</span> Web()</span><br><span class="line">w.run()</span><br><span class="line">w.work()</span><br></pre></td></tr></table></figure><ol start="6"><li><h5 id="原型链实现继承的-问题"><a href="#原型链实现继承的-问题" class="headerlink" title="原型链实现继承的 问题"></a>原型链实现继承的 问题</h5></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="keyword">this</span>.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">/*实例方法*/</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'在运动'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.sex = <span class="string">'男'</span></span><br><span class="line">Person.prototype.work = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'在工作'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">'xiaxa'</span>, <span class="number">25</span>)</span><br><span class="line">p.run()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Web</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Web.prototype = <span class="keyword">new</span> Person() <span class="comment">/*原型链实现继承*/</span></span><br><span class="line"><span class="keyword">var</span> w = <span class="keyword">new</span> Web(<span class="string">'xaxaxaxaxa'</span>, <span class="number">26</span>) <span class="comment">/*实例化子类的时候，没法给父类传参*/</span></span><br><span class="line">w.run()</span><br><span class="line">w.work()</span><br></pre></td></tr></table></figure><ol start="7"><li><h5 id="原型链加构造函数的组合继承模式"><a href="#原型链加构造函数的组合继承模式" class="headerlink" title="原型链加构造函数的组合继承模式"></a>原型链加构造函数的组合继承模式</h5></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">​    <span class="keyword">this</span>.name = name</span><br><span class="line">​    <span class="keyword">this</span>.age = age</span><br><span class="line">​    <span class="keyword">this</span>.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">/*实例方法*/</span></span><br><span class="line">​      <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'在运动'</span>)</span><br><span class="line">​    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Person.prototype.sex = <span class="string">'男'</span></span><br><span class="line">  Person.prototype.work = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">​    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'在工作'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">'xiaxa'</span>, <span class="number">25</span>)</span><br><span class="line">  p.run()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// web类继承Person类  原型链加对象冒充的组合继承模式</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Web</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">​    Person.call(<span class="keyword">this</span>, name, age) <span class="comment">/*对象冒充继承，实例化子类可以给父类传参*/</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Web.prototype = <span class="keyword">new</span> Person() <span class="comment">/*原型链实现继承*/</span></span><br><span class="line"><span class="comment">//Web.prototype = Person.prototypr /*也可以*/</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> w = <span class="keyword">new</span> Web(<span class="string">'lily'</span>, <span class="number">26</span>) <span class="comment">/*实例化子类的时候，没法给父类传参*/</span></span><br><span class="line">  w.run()</span><br><span class="line">  w.work()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;TypeScript中的类（上）&quot;&gt;&lt;a href=&quot;#TypeScript中的类（上）&quot; class=&quot;headerlink&quot; title=&quot;TypeScript中的类（上）&quot;&gt;&lt;/a&gt;TypeScript中的类（上）&lt;/h4&gt;
    
    </summary>
    
    
    
      <category term="TS" scheme="http://yoursite.com/tags/TS/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript02</title>
    <link href="http://yoursite.com/2020/03/18/TypeScript02/"/>
    <id>http://yoursite.com/2020/03/18/TypeScript02/</id>
    <published>2020-03-18T08:56:10.000Z</published>
    <updated>2020-03-23T13:33:16.229Z</updated>
    
    <content type="html"><![CDATA[<h4 id="TypeScript中的函数"><a href="#TypeScript中的函数" class="headerlink" title="TypeScript中的函数"></a>TypeScript中的函数</h4><a id="more"></a><h4 id="1-函数的定义"><a href="#1-函数的定义" class="headerlink" title="1. 函数的定义"></a>1. 函数的定义</h4><p>1.1. es5定义函数的方法</p><pre><code><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'run'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 匿名函数 -&gt; 没有函数名，直接返回为变量run2</span></span><br><span class="line"><span class="keyword">var</span> run2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'run2'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>1.2. TS中定义函数的方法</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>):<span class="title">string</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'123'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名函数</span></span><br><span class="line"><span class="keyword">var</span> fun2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>):<span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">123321</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fun2())</span><br></pre></td></tr></table></figure><h4 id="2-函数的传参"><a href="#2-函数的传参" class="headerlink" title="2. 函数的传参"></a>2. 函数的传参</h4><p>2.1.  ts中定义方法传参 —&gt; ``模板字符拼接 es6</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params">name:<span class="built_in">string</span>,age:<span class="built_in">number</span></span>):<span class="title">string</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;name&#125;</span>---<span class="subst">$&#123;age&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getInfo(<span class="string">'xiaoyi'</span>,<span class="number">18</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getInfo2 = <span class="function"><span class="keyword">function</span>(<span class="params">name:<span class="built_in">string</span>,age:<span class="built_in">number</span></span>):<span class="title">string</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;name&#125;</span>---<span class="subst">$&#123;age&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getInfo2(<span class="string">'xiaoyi'</span>,<span class="number">22</span>))</span><br></pre></td></tr></table></figure><p>2.2. 没有返回值的方法</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runddd</span>(<span class="params"></span>): <span class="title">void</span></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'runddd'</span>)</span><br><span class="line">&#125;</span><br><span class="line">runddd()</span><br></pre></td></tr></table></figure><p>3.1. es5中，方法的实参和形参可以不一样，但是ts中必须一样，如果不一样，就需要配置可选参数</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params">name:<span class="built_in">string</span>,age?:<span class="built_in">number</span></span>):<span class="title">string</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(age)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;name&#125;</span>---<span class="subst">$&#123;age&#125;</span>`</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;name&#125;</span>---年龄保密`</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">alert(getInfo(<span class="string">'xiaoyi'</span>,<span class="number">20</span>))</span><br><span class="line"><span class="comment">// 后面加个？就是可选参数</span></span><br><span class="line"><span class="comment">// 注意：可选参数必须配置到参数的最后面 -&gt;即如果age是可以选参数，那么age必须在name后面，即最后面</span></span><br></pre></td></tr></table></figure><ol start="4"><li><p>默认参数</p><p>es5里面没法设置默认参数，es6和ts中都可以设置默认参数</p><p>直接在<em>name:string=’xiaoyi’</em> 在声明参数的时候后面等于一下默认值就可以</p></li><li><p>剩余函数</p></li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a:<span class="built_in">number</span>,b:<span class="built_in">number</span>,c:<span class="built_in">number</span>,d:<span class="built_in">number</span></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> a+b+c+d</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三点运算符es6 接收形参传过来的值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum2</span>(<span class="params">...result:<span class="built_in">number</span>[]</span>):<span class="title">number</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">result.forEach(<span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">sum = sum+element</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum2(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br></pre></td></tr></table></figure><ol start="6"><li><p>函数重载</p><p>Java中方法的重载：重载指的是两个或两个以上同名函数，但它们的参数不一样，这时候会出现重载的情况</p><p>typescript中的重载：通过为同一个函数提供多个函数类型定义来试下多种功能的目的</p><p>es5中出现同名方法,下面的会替换上面的方法</p><p>TS中：</p> <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params">name:<span class="built_in">string</span></span>):<span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params">age:<span class="built_in">number</span></span>):<span class="title">string</span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params">str:<span class="built_in">any</span></span>):<span class="title">any</span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"> <span class="title">if</span>(<span class="params"><span class="keyword">typeof</span> str === '<span class="built_in">string</span>'</span>)</span>&#123;</span></span></span><br><span class="line"><span class="function"><span class="function">        <span class="title">return</span> '我叫'+<span class="title">str</span></span></span></span><br><span class="line"><span class="function"><span class="function">    &#125;<span class="title">else</span></span>&#123;</span></span><br><span class="line"><span class="function">        <span class="title">return</span> '我的年龄是'+<span class="title">str</span></span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function"><span class="title">getInfo</span>(<span class="params">'小易'</span>) √</span></span><br></pre></td></tr></table></figure></li><li><p>箭头函数 es6 :this指向问题  箭头函数里面的this指向上下文</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;TypeScript中的函数&quot;&gt;&lt;a href=&quot;#TypeScript中的函数&quot; class=&quot;headerlink&quot; title=&quot;TypeScript中的函数&quot;&gt;&lt;/a&gt;TypeScript中的函数&lt;/h4&gt;
    
    </summary>
    
    
    
      <category term="TS" scheme="http://yoursite.com/tags/TS/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript01</title>
    <link href="http://yoursite.com/2020/03/17/TypeScript01/"/>
    <id>http://yoursite.com/2020/03/17/TypeScript01/</id>
    <published>2020-03-17T05:39:31.000Z</published>
    <updated>2020-03-27T04:44:16.474Z</updated>
    
    <content type="html"><![CDATA[<h4 id="TypeScript-基础"><a href="#TypeScript-基础" class="headerlink" title="TypeScript 基础"></a>TypeScript 基础</h4><a id="more"></a><p>Typescript 是微软推出的一门语言，是JavaScript的超集，包含ES567</p><p>新增了类型系统和完整的面向对象</p><h4 id="第一章-TypeScript-基础"><a href="#第一章-TypeScript-基础" class="headerlink" title="第一章 TypeScript 基础"></a>第一章 TypeScript 基础</h4><h4 id="01-TypeScript-环境安装"><a href="#01-TypeScript-环境安装" class="headerlink" title="01.TypeScript 环境安装"></a>01.TypeScript 环境安装</h4><ol><li><p>需要一个工具，将ts代码转换为浏览器或者nodejs识别的js代码，就需要ts环境（npm，nodejs的包管理器，用npm下载ts环境；网上下载安装nodejs，cmd node -v 查看）-&gt;cmd中 tsc -v 查看</p><ul><li>全局安装： <em>npm i -g typescript</em></li><li>校验typescript： <em>tsc -v</em></li><li>tsc的作用：<em>负责将ts代码转为浏览器、nodejs识别的js代码</em></li></ul></li><li><p>第一个ts程序</p><ul><li><p>在后缀名为.ts文件中写typescript代码</p></li><li><p>使用tsc工具将typescript代码编译为浏览器、nodejs识别的js代码</p></li><li><p>在浏览器或者nodejs中执行js代码</p><p><em>ts -&gt; js -&gt; html scprit标签引入</em></p></li></ul></li><li><p>在nodejs中执行typescript代码</p><ul><li>执行tsc转换过后的js代码   <em>node xxx.js</em></li></ul></li><li><p>ts-node ： 自动将ts代码转换为js代码，并将其在nodejs中执行</p><ul><li>安装 <em>npm i -g ts-node</em></li><li>使用 <em>ts-node xxx.ts</em>文件名</li></ul></li><li><p>vscode配置自动编译（功能同4）</p><ul><li>tsc –init 生成tsconfig.json 改”outDir”:’./js’</li><li>终端-运行任务-监视tsconfig.json</li></ul></li></ol><h4 id="02-TypeScript-数据类型-变量"><a href="#02-TypeScript-数据类型-变量" class="headerlink" title="02. TypeScript 数据类型 | 变量"></a>02. TypeScript 数据类型 | 变量</h4><ol><li><p>在JavaScript中，变量中可以存储任意类型的数据</p><p><em>var a = 10； a = “jack” ； a=true；</em></p></li><li><p>但是在TS语法规定：在声明变量的时候，必须制定变量的类型</p></li><li><p>声明变量的语法： </p><p><u>let 变量名：变量类型</u></p><p><em>let age： number</em></p><p><em>let myName： String</em></p></li><li><p>变量的类型一旦指定后，这个变量只能存储这个类型的数据</p><p><em>age = 18</em>； 这样可以的</p><p><em>age = “jack”</em> 错误 -&gt; 因为上面age指定了类型为number</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> flag: boolean = <span class="literal">true</span></span><br><span class="line">flag = <span class="literal">false</span></span><br><span class="line"><span class="built_in">console</span>.log(flag)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str: string = <span class="string">''</span></span><br><span class="line">str = <span class="string">'12300'</span></span><br><span class="line"><span class="built_in">console</span>.log(str)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr:number[]=[<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr2:<span class="built_in">Array</span>&lt;number&gt;=[<span class="number">33</span>,<span class="number">22</span>,<span class="number">11</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr3:string[]=[<span class="string">'1'</span>,<span class="string">'2str'</span>,<span class="string">'3str'</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr3)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr4:object[]=[&#123;<span class="attr">name</span>:<span class="string">'hall'</span>,<span class="attr">age</span>:<span class="string">'18'</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">'xun'</span>,<span class="attr">age</span>:<span class="string">'19'</span>&#125;]</span><br><span class="line"><span class="built_in">console</span>.log(arr4)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元组类型</span></span><br><span class="line"><span class="keyword">var</span> arr5:[number,string]=[<span class="number">123</span>,<span class="string">'this is str'</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr5)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚舉类型，使用单词就能够知道单纯的数字表示什么意思。易读</span></span><br><span class="line">enum Flag &#123;success=<span class="number">1</span>,error=<span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">let</span> s:Flag=Flag.success</span><br><span class="line"><span class="built_in">console</span>.log(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任意类型</span></span><br><span class="line"><span class="keyword">var</span> num:any=<span class="number">123</span></span><br><span class="line">num=<span class="string">'str'</span></span><br><span class="line">num=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined null 类型</span></span><br><span class="line"><span class="keyword">var</span> a:<span class="literal">undefined</span></span><br><span class="line">a=<span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b:<span class="literal">null</span></span><br><span class="line">b=<span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c:never</span><br><span class="line"><span class="comment">// c='122' 报错 c是never类型，从不使用类型</span></span><br><span class="line"><span class="comment">// 抛出异常，不常用</span></span><br><span class="line">c=<span class="function">(<span class="params">(</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'错误'</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;TypeScript-基础&quot;&gt;&lt;a href=&quot;#TypeScript-基础&quot; class=&quot;headerlink&quot; title=&quot;TypeScript 基础&quot;&gt;&lt;/a&gt;TypeScript 基础&lt;/h4&gt;
    
    </summary>
    
    
    
      <category term="TS" scheme="http://yoursite.com/tags/TS/"/>
    
  </entry>
  
</feed>
