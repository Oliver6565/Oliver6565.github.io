<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>费罗里的图书馆</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-06-28T02:09:16.472Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Oliver</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Fifth 选择结构程序设计</title>
    <link href="http://yoursite.com/2020/06/28/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/2020/06/28/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</id>
    <published>2020-06-28T01:35:43.000Z</published>
    <updated>2020-06-28T02:09:16.472Z</updated>
    
    <content type="html"><![CDATA[<p>关系运算符和关系表达式、逻辑运算符和逻辑表达式、if语句、switch语句</p><a id="more"></a><h4 id="考点1-关系运算符和关系表达式"><a href="#考点1-关系运算符和关系表达式" class="headerlink" title="考点1 关系运算符和关系表达式"></a>考点1 关系运算符和关系表达式</h4><h5 id="关系运算符及其优先次序"><a href="#关系运算符及其优先次序" class="headerlink" title="关系运算符及其优先次序"></a>关系运算符及其优先次序</h5><ul><li><p>&lt;、&lt;=、&gt;、&gt;=；优先级相同（高）</p></li><li><p>==、!=；优先级相同（低）</p><p>说明：关系运算符的优先级低于算术运算符 + - * / %</p><p>高于赋值运算符 = 。</p></li></ul><h5 id="关系表达式"><a href="#关系表达式" class="headerlink" title="关系表达式"></a>关系表达式</h5><ul><li><p>用关系运算符将两个表达式连接起来的式子，称关系表达式。</p><p>eg：a&gt;b, a+b&gt;b+c, (a=3)&gt;(b=5), ‘a’&lt;’b’, (a&gt;b)&gt;(b&lt;c)</p></li><li><p>关系表达式的值是一个<strong>逻辑值</strong>，即“真” “假”。</p><p>eg：a&gt;b的值为“真”，那么关系表达式的值为1；1代表真,0代表假。</p></li></ul><h4 id="考点2-逻辑运算符和逻辑表达式"><a href="#考点2-逻辑运算符和逻辑表达式" class="headerlink" title="考点2 逻辑运算符和逻辑表达式"></a>考点2 逻辑运算符和逻辑表达式</h4><h5 id="逻辑运算符及其优先次序"><a href="#逻辑运算符及其优先次序" class="headerlink" title="逻辑运算符及其优先次序"></a>逻辑运算符及其优先次序</h5><ul><li><p>&amp;&amp;  AND</p></li><li><p>|| OR</p></li><li><p>！ NOT</p><p>优先次序：&amp;&amp; 和 || 低于关系运算符；！高于算术运算符。</p></li></ul><h5 id="逻辑表达式"><a href="#逻辑表达式" class="headerlink" title="逻辑表达式"></a>逻辑表达式</h5><ul><li><p>用逻辑运算符将关系表达式或逻辑量连接起来的式子就是逻辑表达式。逻辑表达式的值也是一个<strong>逻辑值</strong>，即“真” “假”</p><p>eg：5&gt;3&amp;&amp;8&lt;4-!0</p><p>5&gt;3为真1  4-!0为3 8&lt;3为假0 最后 1并0 为0</p></li><li><p><strong>！！！</strong>在逻辑表达式的求解中，并不是所有的逻辑运算符都要被执行</p><ul><li><p>a&amp;&amp;b&amp;&amp;c，只有a为真时，才需要判断b的值，只有a和b的值都为真时，才需要判断c的值。</p></li><li><p>a||b||c，只要a为真，就不判断b和c的值，只有a为假，才判断b。a和b都为假，才判断c。</p><p>eg：(m=a&gt;b)&amp;&amp;(n=c&gt;d)</p><p>当 a = 1，b = 2，c = 3，d = 4，m和n的原值为1时，由于a&gt;b为假0，所以m=0，那么整个表达式为0，后面不用执行计算，即最后m=0，n=1。</p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关系运算符和关系表达式、逻辑运算符和逻辑表达式、if语句、switch语句&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="考研" scheme="http://yoursite.com/tags/%E8%80%83%E7%A0%94/"/>
    
  </entry>
  
  <entry>
    <title>Fourth C语句概述</title>
    <link href="http://yoursite.com/2020/06/27/%E7%AC%AC%E5%9B%9B%E7%AB%A0-C%E8%AF%AD%E5%8F%A5%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/2020/06/27/%E7%AC%AC%E5%9B%9B%E7%AB%A0-C%E8%AF%AD%E5%8F%A5%E6%A6%82%E8%BF%B0/</id>
    <published>2020-06-27T04:26:15.000Z</published>
    <updated>2021-01-12T08:51:07.623Z</updated>
    
    <content type="html"><![CDATA[<p>基础，输入输出，格式输出</p><a id="more"></a><h4 id="考点1-C语言概述"><a href="#考点1-C语言概述" class="headerlink" title="考点1 C语言概述"></a>考点1 C语言概述</h4><p>一个C程序可以由若干个源程序文件组成</p><p>一个源文件可以由若干个函数和预处理命令以及全局变量声明组成</p><p>一个函数由函数首部和函数体组成</p><p>函数体由数据声明和执行语句组成</p><img src="/2020/06/27/%E7%AC%AC%E5%9B%9B%E7%AB%A0-C%E8%AF%AD%E5%8F%A5%E6%A6%82%E8%BF%B0/C%E7%A8%8B%E5%BA%8F.svg" class><p>C语句的5种类型：</p><img src="/2020/06/27/%E7%AC%AC%E5%9B%9B%E7%AB%A0-C%E8%AF%AD%E5%8F%A5%E6%A6%82%E8%BF%B0/C%E8%AF%AD%E5%8F%A5.svg" class><h4 id="考点2-赋值语句"><a href="#考点2-赋值语句" class="headerlink" title="考点2 赋值语句"></a>考点2 赋值语句</h4><ul><li><p>赋值语句 = 赋值表达式 + ；</p><p>a = 100 赋值语句</p><p>a = 100；赋值表达式</p></li><li><p>条件中不能含有赋值符号，但是赋值表达式可以包含于条件表达式中：</p><p>if (a=b)  t = a; 错误</p><p>if ((a=b)=&gt;0) t = a; <strong>正确</strong></p></li></ul><h4 id="考点3-数据输入输出概念以及C语言中的实现"><a href="#考点3-数据输入输出概念以及C语言中的实现" class="headerlink" title="考点3 数据输入输出概念以及C语言中的实现"></a>考点3 数据输入输出概念以及C语言中的实现</h4><ul><li><p>输出：从计算机向外部输出设备（显示器、打印机）</p></li><li><p>输入；从输入设备（键盘 鼠标 扫描仪）向计算机输入数据</p></li><li><p>C语言本身不提供输入数据语句；是由C函数库中的函数来实现的</p></li><li><p>使用库函数时，需要用预编译命令 “#include” 将有关的 “头文件” 包含到用户源文件中</p></li></ul><h4 id="考点4-字符数据的输入输出"><a href="#考点4-字符数据的输入输出" class="headerlink" title="考点4 字符数据的输入输出"></a>考点4 字符数据的输入输出</h4><ul><li><p>字符输出函数</p><p>一般形式：putchar(c)  （c为字符型变量 char c；或整型变量）</p><p>函数作用： 向终端输出一个字符</p></li><li><p>字符输入函数</p><p>一般形式：getchar(c)</p><p>函数作用：从终端（或系统隐含指定的输入设备）输入一个字符</p><p>函数值：从输入设备得到的字符</p></li></ul><h4 id="考点5-格式输入与输出"><a href="#考点5-格式输入与输出" class="headerlink" title="考点5 格式输入与输出"></a>考点5 格式输入与输出</h4><ul><li><p>格式输出函数</p><p>一般格式：printf（格式控制，输出表列）。</p><p>函数作用：向终端（或系统隐含指定的输出设备）输出若干个任意类型的数据。</p></li><li><p>格式控制 格式符：</p><img src="/2020/06/27/%E7%AC%AC%E5%9B%9B%E7%AB%A0-C%E8%AF%AD%E5%8F%A5%E6%A6%82%E8%BF%B0/%E6%A0%BC%E5%BC%8F%E6%8E%A7%E5%88%B6.svg" class></li><li><p>几种常见的格式符的修饰符：</p><p>L：用于长整型整数，可以加在格式符d o x u前面；</p><p>M（代表一个正整数）：数据<strong>最小宽度</strong>；</p><p>N（代表一个正整数）：对实数，表示<strong>输出n位小数</strong>；对字符串，表示<strong>截取的字符个数</strong></p><p>—：输出的数字或字符在域内向左靠</p></li><li><p>d格式符</p><ul><li><p>%d：按十进制整型数据的实际长度输出</p></li><li><p>%md；m为指定的输出字段宽度</p><p>如果数据位数小于m，则左端补以空格</p><p>如果数据位数大于m，则按实际位数输出；</p></li><li><p>%ld：输出长整型数据</p></li></ul></li><li><p>o格式符</p><p>输出的数值不带符号，符号位作为八进制数的一部分输出，不会出现负的十六进制数。</p></li><li><p>x格式符</p><p>以十六进制形式输出整数，同样不会出现负的十六进制数。</p></li><li><p>u格式符</p><p>用来输出unsigned型数据，一个有符号整数int型也可以用%u格式输出；</p><p>一个unsigned型数据也可以用%d格式输出</p><p>unsigned型数据也可以用%o %x格式输出</p></li><li><p>c格式符：输出一个字符</p><p>如：char d = ‘a’;</p><p>​        printf(“%c”,d);</p><p>输出字符’a’.</p><p>一个整数，只要他的值在0~255范围内，可以用“%c”使之按字符形式输出，在输出前，系统会将该整数作为ASCII码转换成响应的字符。一个字符数据也可以用整数形式输出。</p><p>eg1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> a = <span class="number">65535</span>;<span class="keyword">int</span> b = <span class="number">-2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%d,%o,%x,%u\n"</span>,a,a,a,a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"b=%d,%o,%x,%u\n"</span>,b,b,b,b);</span><br><span class="line">&#125;</span><br><span class="line">运行结果：</span><br><span class="line">    a=<span class="number">-1</span>,<span class="number">177777</span>,ffff,<span class="number">65535</span></span><br><span class="line">    b=<span class="number">-2</span>,<span class="number">177776</span>,fffe,<span class="number">65534</span></span><br></pre></td></tr></table></figure><p>eg2:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">'a'</span>; <span class="comment">// 字符a对应的ASCII码为97</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">97</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c,%d\n"</span>,c,c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c,%d\n"</span>,i,i);</span><br><span class="line">&#125;</span><br><span class="line">运行结果： </span><br><span class="line">    a,<span class="number">97</span></span><br><span class="line">    a,<span class="number">97</span></span><br></pre></td></tr></table></figure></li><li><p>s格式符：输出字符串</p><ul><li><p>%s </p><p>printf（“%s”，“CHINA”）</p><p>输出字符串 ”CHINA“（不包括双引号）</p></li><li><p>%ms</p><p>输出的字符串占m列（控制字符串宽度），若串长度大于m，则全部输出，若串长度小于m，则左补空格</p></li><li><p>%-ms</p><p>同理上面，但字符串向左靠，右补空格</p></li><li><p>%m.ns</p><p>输出占m列，只取字符串中左端n个字符 输出在m列的右侧，左补空格</p></li><li><p>%-m.ns</p><p>n个字符输出在m列的左侧，右补空格</p></li><li><p>若n &gt;m ,m自动取n值</p></li></ul><p>eg3：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%3s,%7.2s,%.4s,%-5.3s\n"</span>,<span class="string">"CHINA"</span>,<span class="string">"CHINA"</span>,<span class="string">"CHINA"</span>,<span class="string">"CHINA"</span>);</span><br><span class="line">&#125;</span><br><span class="line">运行结果：</span><br><span class="line">    CHINA,     CH,CHIN,CHI  ;</span><br></pre></td></tr></table></figure></li><li><p>f格式符：以小数形式输出实数（包括单双精度）</p><ul><li><p>%f</p><p>不指定字段宽度，由系统自动指定字段宽度，使整数部分全部输出，并输出6位小数。应当注意，在输出的数字中，并非全部数字都是有效数字。<strong>单精度实数</strong>的有效数位一般为<strong>7位</strong>。</p></li><li><p>%m.nf</p><p>指定输出的数据共占m列，其中有n个小数，如果数值长度小于m，则左端补空格。</p></li><li><p>%-m.nf</p><p>输出值向左端靠，右端补空格</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> f = <span class="number">123.456</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%f,%10f,%10.2f,.2f%,%-10.2f\n"</span>,f,f,f,f,f);</span><br><span class="line">&#125;</span><br><span class="line">运行结果：</span><br><span class="line">    <span class="number">123.455994</span>,<span class="number">123.455994</span>,    <span class="number">123.46</span>,<span class="number">123.46</span>,<span class="number">123.46</span>    ;</span><br></pre></td></tr></table></figure></li><li><p>e格式符：以指数形式输出实数</p><ul><li><p>%e 不指定输出数据所占的宽度和数字部分的小数位数</p><p>printf(“%e”,123.256);</p><p>输出：</p><p><u>1.234560</u> <u>e+002</u>（8列+5列）</p><p>所输出的实数共占13列宽度（注：不同系统的规定略有不同）</p></li><li><p>%m.ne和%-m.ne</p><p>m、n和—字符的含义与前面相同，此处n指拟输出的数据的小数部分（又称尾数）的小数尾数</p><p>f = 123.456</p><p>printf(“%e,%10e,%10.2e,%.2e,%-10.2e”,f,f,f,f,f);</p><p>输出：</p><p>1.234560e+002, 1.234560e+002, 1.23e+002 (5+5列，左补空格),</p><p>1.23e+002 (4+5列), 1.23e+002 ;(4+6列，右补空格)</p><p><u>说明</u>：未指定n，自动使n = 6</p></li></ul></li><li><p>g格式符：用来输出实数</p><p>根据数值的大小，自动选f格式或e格式，选择占宽度较小的一种，且不输出无意义的零</p><p><u>说明</u>：用%f格式输出占10列，用%e格式输出占13列</p></li></ul><p>注：除了X E G外，其他格式符必须用小写，可以在<code>printf</code>函数中的“格式控制”字符串中包含转义字符。</p><p>一个格式说明必须以 % 开头，以9个格式字符之一为结束，中间可以插入附加格式字符。想输出百分号%，那应该在格式控制字符串中用两个%表示。</p><ul><li><p>格式输入函数</p><p>一般格式：scanf（格式控制，地址列表）。</p><p>函数作用：按照变量在内存的地址将变量值存进去。</p><p>地址表列：是由若干个地址组成的表列，可以是变量的地址，或字符串的首地址</p></li><li><p>使用scanf函数时注意的问题：</p><ol><li>scanf函数中的“格式控制”后面应当是变量地址 &amp;a..要加地址运算符，而不是变量名。</li><li>如果在“格式控制”字符串中除了格式说明以外还有其他字符，则在输入数据时在对应位置应输入与这些字符相同的字符。</li><li>在用“%c” 格式输入字符时，空格字符和“转义字符”都作为有效字符输入</li><li>在输入数据时，遇以下情况时，认为该数据结束<ul><li>遇空格，或按回车 或Tab</li><li>按指定的宽度结束 %3d，只取3列</li><li>遇非法输入</li></ul></li></ol></li></ul><h4 id="主要知识点"><a href="#主要知识点" class="headerlink" title="主要知识点"></a>主要知识点</h4><p>字符数据的输入输出函数</p><p>格式输入输出函数：9个格式控制符的使用</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基础，输入输出，格式输出&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="考研" scheme="http://yoursite.com/tags/%E8%80%83%E7%A0%94/"/>
    
  </entry>
  
  <entry>
    <title>Third 数据类型、运算符和表达式</title>
    <link href="http://yoursite.com/2020/06/24/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/06/24/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2020-06-24T03:36:01.000Z</published>
    <updated>2021-01-12T03:24:20.740Z</updated>
    
    <content type="html"><![CDATA[<p>第三章 数据类型、运算符和表达式</p><a id="more"></a><h4 id="考点1-C的数据类型"><a href="#考点1-C的数据类型" class="headerlink" title="考点1 C的数据类型"></a>考点1 C的数据类型</h4><img src="/2020/06/24/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.svg" class><h4 id="考点2-常量与变量"><a href="#考点2-常量与变量" class="headerlink" title="考点2 常量与变量"></a>考点2 常量与变量</h4><ol><li><p>常量</p><ul><li>常量：在程序运行过程中，其值不能被改变的量</li><li><strong>字面常量</strong>：直观上就是常量</li><li><strong>const 修饰的常变量</strong>：本质是变量，但具有常量的属性</li><li><strong>#define 定义的常量</strong></li><li><strong>枚举常量</strong></li></ul></li><li><p>变量</p><ul><li>代表内存中具有特定属性的一个存储单元，用来存放数据，在程序运行期间，值是可以改变的。</li><li><strong>变量名</strong>实际上是一个以一个名字<strong>代表</strong>的<strong>一个地址</strong>，在对程序编译连接时，由编译系统给每一个变量名分配对应的内存地址。</li><li>从变量中取值，实际上是通过<strong>变量名</strong>找到相应的<strong>内存地址</strong>，从该<strong>存储单元</strong>中读取数据。</li><li><strong>变量命名规则</strong>：<strong>字母、数字、下划线</strong>三种字符组成，第一个字符不能为数字！<u>关键字不能被命名！</u></li></ul></li></ol><h4 id="考点3-整型数据"><a href="#考点3-整型数据" class="headerlink" title="考点3 整型数据"></a>考点3 整型数据</h4><ol><li><p>整型常量的表示方法</p><ul><li>十进制整数。如：123，-54，4</li><li>八进制整数。</li><li>十六进制整数。</li></ul></li><li><p>整型变量</p><ul><li><p>整型数据在内存中存放形式：以二进制形式存放</p><p>如int i； // 定义为整型变量</p><p>i = 10；  // 给 i 赋以整数10</p><blockquote><p>注意：不同的编译系统为整型数据分配的字节是不同的 2 / 4 B</p></blockquote></li><li><p>整型变量的分类：</p><ul><li><p>有符号基本整型    （signed）int</p></li><li><p>有符号短整型   （signed）short （int）</p></li><li><p>有符号长整型   （signed）long（int）</p></li><li><p>无符号基本整型    unsigned int</p></li><li><p>无符号短整型    unsigned  short（int）</p></li><li><p>无符号长整型    unsigned long（int）</p><blockquote><p>注意：括号表示其中的内容是可选的；不同种类的整型数据可以进行算术运算</p></blockquote></li></ul></li><li><p>整型变量的定义：</p><p>C规则所有用到的变量都必须在程序中定义，即“强制类型定义”</p><p>eg：int a，b；（指定变量a、b为整型）</p><p>unsigned short c，d；（指定变量c、d为无符号短整型）</p></li></ul></li><li><p>整型常量类型</p><ul><li>一个整数，如果其值在-32768~+32767范围内，为它是int型，它可以赋值给 int 型和long int 型变量。</li><li>一个整数，如果其值超过了上述范围，在-2147483648~+2147483647范围内，则认为它为长整型，赋值给long int型变量</li><li>一个整常量后面加一个字母U 或 u，认为是unsigned int 类型。在内存中按unsigned int规定的方式存放（存储单元中最高位不作为符号位，而用来存储数据）</li><li>一个整常量后面加一个字母L 或 l，即认为是long int类型</li></ul></li></ol><h4 id="考点4-浮点型数据运行"><a href="#考点4-浮点型数据运行" class="headerlink" title="考点4 浮点型数据运行"></a>考点4 浮点型数据运行</h4><ol><li><p>浮点型常量的表示方法</p><p>两种表示形式：小数 0.123；指数 3e-3</p><blockquote><p>注意：字母e或者E之前必须有数字，且e后面的指数必须为整数</p></blockquote></li><li><p>浮点型变量</p><ul><li>浮点型数据在内存中的存放形式：一个浮点型数据一般在内存中<strong>占4个字节</strong>，32bit。与整数数据存储方式不同，浮点型数据按照<strong>指数形式</strong>存储。系统把浮点型数据分为小数部分和指数部分</li><li>三种分类：单精度float；双精度double；长双精度long double</li><li>浮点型数据的舍入误差；浮点型只能保证有效数字为7位，所以避免一个很大的数和一个很小的数直接相加或相减，不然会“丢失”小的数</li></ul></li><li><p>浮点型常量的类型</p><p>C编译系统将浮点型常作为双精度double来处理</p></li></ol><h4 id="考点5-字符型数据"><a href="#考点5-字符型数据" class="headerlink" title="考点5 字符型数据"></a>考点5 字符型数据</h4><ol><li><p>字符常量</p><ul><li>用<strong>单引号</strong>包含的一个字符，就叫做字符常量</li><li>只能包含一个字符</li><li>有些以“\”开头的特殊字符称为<strong>转义字符</strong><ul><li>\n 换行</li><li>\t 横向跳格</li><li>\r 回车</li><li>\\ 反斜杠</li><li>\ddd ddd代表1到3位八进制数字表示字符</li><li>\xhh hh表示1到2位十六进制数字表示字符</li></ul></li></ul></li><li><p>字符变量</p><p>字符型变量用来存放字符常量，注意只能放一个字符</p><p>字符变量的定义形式如下：</p><p>char c1，c2;</p><p>可以用 c1 = ‘a’；c2 = ‘b’；来赋值；</p><p>一个字符变量在内存中占一个字节；</p></li><li><p>字符串常量</p><p>字符串常量是一对双引号括起来的字符序列</p><p>“How do you do” “hello” “a”</p><p>不能把一个字符串常量赋值给一个字符变量</p><p>C规定以字符 <strong>‘\0’ 作为字符串结束标志</strong>。这个结束标志是会和字符串数据存到内存中的，占一个bit</p></li></ol><h4 id="考点6-变量赋初值"><a href="#考点6-变量赋初值" class="headerlink" title="考点6 变量赋初值"></a>考点6 变量赋初值</h4><ol><li><p>C语言运行在定义变量的同时，使变量初始化</p><p>int a = 1；</p><p>float f = 3.56；</p><p>char c = ‘a’；  //指定c为字符变量，初值为‘a’</p></li></ol><h4 id="考点7-各类数值型数据间的混合运算"><a href="#考点7-各类数值型数据间的混合运算" class="headerlink" title="考点7 各类数值型数据间的混合运算"></a>考点7 各类数值型数据间的混合运算</h4><p>整型（包括int short long）、浮点型（包括float、double）可以混合运算。在进行运算时，不同类型的数据，要先转换成同一类型，再计算。是由系统自动转换的。</p><h4 id="考点8-算数运算符和算数表达式"><a href="#考点8-算数运算符和算数表达式" class="headerlink" title="考点8 算数运算符和算数表达式"></a>考点8 算数运算符和算数表达式</h4><ol><li><p>C的运算符有以下几类：</p><ul><li>算数运算符：+-*/%</li><li>关系运算符：&gt;，&lt;，==，&gt;=，&lt;=，！=</li><li>逻辑运算符：！&amp;&amp; ||</li><li>位运算符：&lt;&lt;&gt;&gt; ~ | ^ &amp;</li><li>赋值运算符：=</li><li>条件运算符：？：</li><li>逗号运算符：，</li><li>指针运算符：* &amp;</li><li>求字节数运算符：sizeof</li><li>强制类型转换运算符：（类型）</li><li>分量运算符：.-&gt;</li><li>下标运算符： []</li><li>其他：函数调用</li></ul></li><li><p>算数表达式和运算符的优先级</p></li><li><p>强制类型转换</p><p> (int)x；(float)(a+b)</p></li><li><p>自增自减</p></li></ol><h4 id="考点9-赋值运算符和赋值表达式"><a href="#考点9-赋值运算符和赋值表达式" class="headerlink" title="考点9 赋值运算符和赋值表达式"></a>考点9 赋值运算符和赋值表达式</h4><p>=</p><p>a = 3 ；将3赋值给变量a；也可以将一个表达式赋值给变量a</p><p>如果赋值运算两侧类型不一致，但都是数值型或字符型时，在赋值时要进行类转换</p><ul><li><p>将浮点型数据（单/双精度）赋值给整型变量时，舍弃浮点数的小数部分；即如果i为int型，那么i = 3.56，那么i的值最终为3，以整数形式存储在整型变量中</p></li><li><p>将整型数据赋值给单、双精度变量时，数值不变，但是以浮点数形式存储到变量中（有效位边长，内存分配的地址空间不同）</p></li><li><p>double赋值给float，注意数值范围不能溢出</p></li><li><p>%u 是输出无符号数时所用的格式符。如果b为正值，且在0-32767之前，则复制后数据不变</p></li><li><p>一个表达式有有一个值 ：a = 1+ 2；a = （b = 5）和 a = b = 5等价</p><p>其中变量可以作为左值</p><p>表达式不能作为左值</p><p>赋值表达式可以在左值</p><p>常变量也不能作为左值</p></li></ul><h4 id="考点10-逗号运算符和逗号表达式"><a href="#考点10-逗号运算符和逗号表达式" class="headerlink" title="考点10 逗号运算符和逗号表达式"></a>考点10 逗号运算符和逗号表达式</h4><p>顺序求值运算符</p><p>一般形式：表达式1，表达式2</p><p>先求表达式1，再求表达式2，整个逗号表达式的值是<strong>表达式2的最终结果</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第三章 数据类型、运算符和表达式&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="考研" scheme="http://yoursite.com/tags/%E8%80%83%E7%A0%94/"/>
    
  </entry>
  
  <entry>
    <title>Second 算法</title>
    <link href="http://yoursite.com/2020/06/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/06/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%AE%97%E6%B3%95/</id>
    <published>2020-06-24T01:05:36.000Z</published>
    <updated>2021-01-12T03:12:07.306Z</updated>
    
    <content type="html"><![CDATA[<p>第二章 算法</p><a id="more"></a><h4 id="考点1-算法的概念"><a href="#考点1-算法的概念" class="headerlink" title="考点1 算法的概念"></a>考点1 算法的概念</h4><ul><li><p>对数据的描述：数据结构</p></li><li><p>对操作的描述：算法; (解决某个事件的步骤！)</p></li><li><p><strong>程序 = 数据结构 + 算法</strong></p></li><li><p>计算机算法可分为两大类：数值运算算法和非数值运算</p></li></ul><blockquote><p>经典两个例题：</p><p>判断闰年： 能被4整除，但不能被100整除 || 能被100整除，又能被400整除</p><p>判断是否为素数 n(n&gt;=3)：将n 作为被除数，将2 到 根号n 各个整数轮流作为除数，如果都不能被整除，则n 为素数</p></blockquote><h4 id="考点2-算法的5大特性"><a href="#考点2-算法的5大特性" class="headerlink" title="考点2 算法的5大特性"></a>考点2 算法的5大特性</h4><p>一个算法应该具有5个特性（只有满足5个特性的，才叫做算法！）</p><ul><li>有穷性：有限步骤，有限时间</li><li>确定性</li><li>有效性：被除数不为0等</li><li>有输入</li><li>有输出</li></ul><h4 id="考点3-算法的表示"><a href="#考点3-算法的表示" class="headerlink" title="考点3 算法的表示"></a>考点3 算法的表示</h4><ul><li><p>用<strong>自然语言</strong>表示算法 OUT</p></li><li><p>用<strong>流程图</strong>表示算法；（流程图要会画！！很重要的）</p><p>包括：起止框、处理框、判断框、输入输出框、流程线、连接点、注释框</p><p>优点：用流程图表示算法要比文字描述算法逻辑清晰，易于理解</p><p>一个流程图包括以下几部分：</p><ul><li><p>表示响应操作的框；</p></li><li><p>带箭头的流程线</p></li><li><p>框内外必要的文字说明</p></li></ul></li><li><p><strong>三种基本结构</strong></p><p>顺序结构、选择结构、循环结构</p></li><li><p>用<strong>N-S流程图</strong>表示算法</p></li><li><p>用<strong>伪代码</strong>表示算法</p></li><li><p>用<strong>计算机语言</strong>表示算法 C语言</p><ul><li>概念：计算机无法识别流程图和伪代码。只有用计算机语言编写的程序才能被计算机执行。因此在用流程图或伪代码描述出一个算法后，还要讲他转换成计算机语言程序。</li><li>特點：用计算机语言表示算法必须严格遵循所用的语言和语法规则</li><li>用处：要完成一件工作，包括设计算法和实现算法两个部分，设计算法的目的是为了实现算法。</li></ul></li></ul><h4 id="考点4-结构化程序设计方法"><a href="#考点4-结构化程序设计方法" class="headerlink" title="考点4 结构化程序设计方法"></a>考点4 结构化程序设计方法</h4><ul><li><p>一个结构化程序：用三中基本结构组成的程序必然是结构化的程序，便于编写、便于阅读、修改和维护。</p></li><li><p><strong>基本思路</strong>：把复杂问题求解过程分阶段进行，每个阶段出的问题都要简单明了</p></li><li><p>采取以下两种方法实现结构化的程序：</p><ul><li>自顶向下，逐步细化；（常用这个）</li><li>自下而上，逐步积累；</li></ul></li></ul><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>主要知识点：<strong>算法的表示</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第二章 算法&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="考研" scheme="http://yoursite.com/tags/%E8%80%83%E7%A0%94/"/>
    
  </entry>
  
  <entry>
    <title>First 考情分析</title>
    <link href="http://yoursite.com/2020/06/23/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%80%83%E6%83%85%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2020/06/23/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%80%83%E6%83%85%E5%88%86%E6%9E%90/</id>
    <published>2020-06-23T01:08:25.000Z</published>
    <updated>2021-01-12T03:08:09.345Z</updated>
    
    <content type="html"><![CDATA[<p>考情分析、复习方法和概述 + 第一章</p><a id="more"></a><h4 id="考情分析"><a href="#考情分析" class="headerlink" title="考情分析"></a>考情分析</h4><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>算法的概述及其表示</td><td>预处理命令</td></tr><tr><td><strong>数据类型、运算符与表达式</strong></td><td><strong>结构体</strong>、共同体、枚举类型</td></tr><tr><td><strong>程序设计结构</strong></td><td>位运算、位段</td></tr><tr><td><strong>数组</strong></td><td><strong>文件</strong></td></tr><tr><td><strong>函数</strong></td><td></td></tr><tr><td><strong>指针</strong></td><td></td></tr></tbody></table><h4 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h4><ul><li><p>认真复习每个知识点，掌握C语言规则</p><p>例如：针对字符数组和字符指针变量</p></li><li><p>对于容易混淆的知识点，善于归纳和总结</p><p>例如：有关整型的数据类型</p><table><thead><tr><th>定义</th><th>含义</th></tr></thead><tbody><tr><td>int p;</td><td>定义整型变量p</td></tr><tr><td>int *p;</td><td>p为指向整型数据的指针变量</td></tr><tr><td>int p[n];</td><td>定义整型数组p，它有n个元素</td></tr><tr><td>int *p[n];</td><td>定义指针数组p，它由n个指向整型数据的指针元素组成</td></tr><tr><td>int (*p)[n];</td><td>p为指向含n个元素的以为数组的指针变量</td></tr><tr><td>int p();</td><td>p为返回整函数值的函数</td></tr><tr><td>int *p();</td><td>p为返回一个指针的函数，该指针指向整型数据</td></tr><tr><td>int (*p)();</td><td>p为指向函数的指针，该函数返回一个整型值</td></tr><tr><td>int **p;</td><td>p是一个指针变量，它指向一个指向整型数据的指针变量</td></tr></tbody></table></li><li><p>培养认真分析的习惯，建立地址分配模型</p></li></ul><h4 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h4><h5 id="C语言的历史背景"><a href="#C语言的历史背景" class="headerlink" title="C语言的历史背景"></a>C语言的历史背景</h5><p>高级语言</p><h5 id="C语言的特点"><a href="#C语言的特点" class="headerlink" title="C语言的特点"></a>C语言的特点</h5><ul><li>语言简介、紧凑、使用方便、灵活。32个关键字、9个控制语句</li><li>34种运算符</li><li>数据类型丰富，具有现代语言的各种数据结构</li><li>具有结构化的控制语句，是完全模块化和结构化的语言</li><li>语法限制不严格，程序设计自由度大</li><li>允许直接访问物理地址，能进行位操作，能实现汇编语言的大部分功能，可直接对硬件进行操作</li><li>目标代码质量高，程序执行效率高</li><li>程序可移植性好。基本不用修改就用于各种型号的计算机和各种操作系统</li></ul><h5 id="简单的C语言程序"><a href="#简单的C语言程序" class="headerlink" title="简单的C语言程序"></a>简单的C语言程序</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#includ <span class="meta-string">&lt;stdio.h&gt;/*文件包含*/</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span><span class="comment">/*主函数*/</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">/*函数体开始*/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"This is a C program.\n"</span>);<span class="comment">/*输出语句*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">/*函数体结束*/</span></span><br></pre></td></tr></table></figure><p>说明：main-主函数名，void-函数类型</p><p>每个C程序必须有一个主函数main，且程序执行首先从main开始，与main函数的位置无关</p><p>{}是函数开始和结束的标志，不可省</p><p>每个C语句以分号结束</p><p>使用标准库函数是应在程序开头添加：#include &lt;stdio.h&gt;</p><h5 id="运行C程序的步骤"><a href="#运行C程序的步骤" class="headerlink" title="运行C程序的步骤"></a>运行C程序的步骤</h5><ul><li>上机输入与编辑源程序</li><li>对源程序进行编译</li><li>与库函数连接</li><li>运行可执行目标程序</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;考情分析、复习方法和概述 + 第一章&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="考研" scheme="http://yoursite.com/tags/%E8%80%83%E7%A0%94/"/>
    
  </entry>
  
  <entry>
    <title>计网5</title>
    <link href="http://yoursite.com/2020/05/07/%E8%AE%A1%E7%BD%915/"/>
    <id>http://yoursite.com/2020/05/07/%E8%AE%A1%E7%BD%915/</id>
    <published>2020-05-07T05:28:03.000Z</published>
    <updated>2021-01-12T10:09:17.621Z</updated>
    
    <content type="html"><![CDATA[<p><strong>数据链路层</strong> 第五节 数据链路层的功能 + 组帧 +差错控制</p><a id="more"></a><h4 id="数据链路层的功能（考纲）"><a href="#数据链路层的功能（考纲）" class="headerlink" title="数据链路层的功能（考纲）"></a>数据链路层的功能（考纲）</h4><p>数据链路层（小秘） 使用下层 物理层的服务，并提供服务给上层 网络层。这三层是通信子网；主要作用，加强物理层传输原始比特流的功能，将物理层（傻子）提供的可能出差错的链路改造成逻辑上无差错的数据链路，使之对网络层（boss）表现为一条无差错链路。</p><h5 id="为网络层提供服务"><a href="#为网络层提供服务" class="headerlink" title="为网络层提供服务"></a>为网络层提供服务</h5><ol><li><p>无确认的无连接服务</p><p>机器发送数据帧时不需先建立链路连接，收到帧也不用确认，对丢失的帧，链路层也不重发（真随缘发送）。适用于实时通信或误码率较低的通信信道，如以太网：通信质量好，有线传输链路。</p></li><li><p>有确认的无连接服务</p><p>机器发送数据帧时不需先建立链路连接，收到帧要发回确认。丢失帧重传。误码率高的比如无线传输。</p></li><li><p>有确认的面向连接服务</p><p>帧传输三阶段：建立数据链、传输帧、释放数据链路。</p><p>注：不存在无确认的面向连接服务。</p></li></ol><h5 id="链路管理"><a href="#链路管理" class="headerlink" title="链路管理"></a>链路管理</h5><p>数据链路层连接的“建立、维持、释放”过程称为链路管理。主要用于有确认的面向连接服务。</p><h5 id="帧定界、帧同步与透明传输"><a href="#帧定界、帧同步与透明传输" class="headerlink" title="帧定界、帧同步与透明传输"></a>帧定界、帧同步与透明传输</h5><p><a href="https://blog.csdn.net/cainv89/article/details/50603699?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">https://blog.csdn.net/cainv89/article/details/50603699?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase</a></p><p>我们需要对网络层（boss）的<strong>分组封装成帧</strong>，以帧传输。将一段数据的<strong>前后</strong>分别添加首部、尾部就构成帧。首尾部包含很多<strong>控制信息</strong>，主要作用是确定帧的界限，即<strong>帧定界</strong>。<strong>帧同步</strong>：接收方能从接收到的二进制比特流中区分出帧的起始与终止。</p><p><strong>透明传输</strong>：不管所传输的数据是什么样的比特组合，都应当能在链路上传送。</p><h5 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h5><p>控制发送速率。（大题必考！！！后面会有流量控制与可靠传输机制详细讲解，<u>停等协议</u>和<u>滑动窗口协议</u>）。发送方发送速度大于接收方接收速度，控制发送方的发送速率。</p><h4 id="组帧（考纲）"><a href="#组帧（考纲）" class="headerlink" title="组帧（考纲）"></a>组帧（考纲）</h4><p>将比特组合成帧，以帧为单位传输，为了在出错时只发送帧，而不是全部比特数据。</p><h4 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h4><p>差错检测防止差错的无效数据帧，浪费网络资源</p><h5 id="检错编码"><a href="#检错编码" class="headerlink" title="检错编码"></a>检错编码</h5><h5 id="纠错编码"><a href="#纠错编码" class="headerlink" title="纠错编码"></a>纠错编码</h5><p>海明码</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;数据链路层&lt;/strong&gt; 第五节 数据链路层的功能 + 组帧 +差错控制&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="考研803" scheme="http://yoursite.com/tags/%E8%80%83%E7%A0%94803/"/>
    
  </entry>
  
  <entry>
    <title>计网4</title>
    <link href="http://yoursite.com/2020/05/07/%E8%AE%A1%E7%BD%914/"/>
    <id>http://yoursite.com/2020/05/07/%E8%AE%A1%E7%BD%914/</id>
    <published>2020-05-07T04:25:30.000Z</published>
    <updated>2021-01-12T10:09:11.575Z</updated>
    
    <content type="html"><![CDATA[<p><strong>物理层</strong> 第四节 传输介质与物理层设备</p><a id="more"></a><h4 id="双绞线、同轴电缆、光纤与无线传输介质"><a href="#双绞线、同轴电缆、光纤与无线传输介质" class="headerlink" title="双绞线、同轴电缆、光纤与无线传输介质"></a>双绞线、同轴电缆、光纤与无线传输介质</h4><p>传输介质，又称传输媒体，是发送设备和接收设备之间的物理通路，并非物理层的设备！！！。传输介质可分为<strong>导向传输介质</strong>和<strong>非导向传输介质</strong>。导向传输：电磁波被导向沿着固体媒介(铜线或光纤)传播；非导向传输：传输介质是空气、真空或海水。</p><h5 id="双绞线"><a href="#双绞线" class="headerlink" title="双绞线"></a>双绞线</h5><ol><li>最常用的古老传输介质，两根采用一定规则并排绞合、相互绝缘的铜导线组成。</li><li>绞合减少对相邻导线电磁干扰。无层的双绞线是(UTP)，双绞线外面加一层金属丝编织成的屏蔽层，这就是屏蔽双绞线(STP)。</li><li>双绞线便宜，在局域网和传统电话网中普遍使用。双绞线带宽取决于铜线粗细和传输距离。模拟传输和数字传输都可以使用双绞线，通信距离一般几千米到数十千米。距离太远，模拟传输需要用<strong>放大器放大</strong>衰减信号；数字传输需要用<strong>中继器</strong>将失真的信号<strong>整形</strong>。</li></ol><h5 id="同轴电缆"><a href="#同轴电缆" class="headerlink" title="同轴电缆"></a>同轴电缆</h5><ol><li>同轴电缆由内导体、绝缘层、网状编织层屏蔽层和塑料外层构成。共用一个轴心。按特性阻抗数值的不同，分为两类：基带同轴电缆传输基带数字信号，用于局域网；宽带同轴电缆传输宽带信号，用于有线电视系统。</li><li>外导体屏蔽层，良好抗干扰特性，广泛用于传输较高速率的数据，其传输距离更远，比双绞线贵。</li></ol><h5 id="光纤（考纲）"><a href="#光纤（考纲）" class="headerlink" title="光纤（考纲）"></a>光纤（考纲）</h5><ol><li>光纤通信利用光导纤维（简称光纤）传递光脉冲来通信。有光脉冲为1，无光脉冲为0。光纤通信系统的带宽范围极大。</li><li>光纤由<strong>纤芯</strong>（实心）和包层组成，光波通过纤芯进行传导，包层较纤芯有较低的折射率。当光纤从高折射率介质射向低折射率介质，其折射角大于入射角。如果入射角足够大，会形成全反射，即光线碰到包层时会折射回纤芯，这个过程不断重复，光沿着光纤传输下去。</li><li>两种光纤：<ul><li><strong>多模光纤</strong>：入射角不同，形成多束光纤传输。光源是发光二极管。光脉冲在多模光纤传输逐渐展宽，易失真，只适合短距离传输。</li><li><strong>单模光纤</strong>：光纤直径减小到一个光波长度，光纤就像一根波导，可使光纤一直向前传播，不会产生过多反射。光源是定向性好的激光二极管，制作成本高，衰减小，适合远距离传输。</li></ul></li></ol><p>光纤特点：</p><ul><li>传输损耗小，中继距离长，对远距离传输特别经济</li><li>抗雷电和电磁干扰好</li><li>无串音干扰，保密性好</li><li>体积小，重量轻</li></ul><h5 id="无线传输介质"><a href="#无线传输介质" class="headerlink" title="无线传输介质"></a>无线传输介质</h5><ol><li>无线电波：信号向所有方向扩散；广泛用于通信领域：无线手机通信、计算机网络中的无线局域网（WLAN）等。</li><li>微波、红外线和激光：高频率带宽；信号固定方向传播，直线；卫星通信使用微波信号。</li></ol><h4 id="物理层接口的特性"><a href="#物理层接口的特性" class="headerlink" title="物理层接口的特性"></a>物理层接口的特性</h4><p>主要任务：确定与传输媒体的接口有关的一些特性：</p><p>机械特性、电器特性、功能特性、规程特性</p><h4 id="中继器"><a href="#中继器" class="headerlink" title="中继器"></a>中继器</h4><ol><li>中继器，又称转发器。主要功能，将信号整形并放大再转发出去，信号再生。放大器是放大模拟信号，中继器整形数字信号。</li><li>具有5-4-3规则</li></ol><h4 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h4><ol><li>集线器（Hub）实质上是一个多端口的中继器，也工作在物理层。由Hub组成的网络是共享式网络，但逻辑上仍是一个总线网。Hub只能在半双工状态下工作。</li><li>对信号进行放大后发到其他所有端口。</li><li>星型拓扑结构的中间就是集线器。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;物理层&lt;/strong&gt; 第四节 传输介质与物理层设备&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="考研803" scheme="http://yoursite.com/tags/%E8%80%83%E7%A0%94803/"/>
    
  </entry>
  
  <entry>
    <title>计网3</title>
    <link href="http://yoursite.com/2020/05/06/%E8%AE%A1%E7%BD%913/"/>
    <id>http://yoursite.com/2020/05/06/%E8%AE%A1%E7%BD%913/</id>
    <published>2020-05-06T12:22:33.000Z</published>
    <updated>2021-01-12T10:09:01.728Z</updated>
    
    <content type="html"><![CDATA[<p><strong>物理层</strong> 第三节 通信基础：基本概念、奈奎斯特定理香浓定理、编码与调制</p><a id="more"></a><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><h5 id="数据、信号与码元"><a href="#数据、信号与码元" class="headerlink" title="数据、信号与码元"></a>数据、信号与码元</h5><p>通信的目的是传递消息。</p><ol><li><strong>数据</strong>是指传送信息的实体。<strong>信号</strong>是指数据的<strong>电气或电磁</strong>表现，是数据在传输过程中的存在形式。数据和信号都可以用“模拟的”和“数字的”来修饰。<ul><li>连续变化的数据（或信号）称为<strong>模拟数据</strong>（模拟信号）；</li><li>取值仅允许为有限的几个离散数值的数据（或信号）称为<strong>数字数据</strong>（数字信号）；</li></ul></li><li>数据的传输方式可分为串行传输、并行传输。<ul><li><strong>串行传输</strong>是指：一个一个的比特按照时间顺序传输（对经济考虑，远距离通信通常采用串行传输）；</li><li><strong>并行传输</strong>是指：多个比特通过多条通信信道同时传输；速度快，费用高，适用于近距离，用于计算机内部数据传输；</li></ul></li><li><strong>码元</strong>：是指用一个固定时长的信号波形（数字脉冲）表示一位k进制数字，代表不同离散数值的基本波形，是<strong>数字通信</strong>中<strong>数字信号</strong>的计量单位，这个时长内的信号称为k进制码元，而该<strong>时长</strong>称为<strong>码元宽度</strong>。1码元可以携带多个比特的信息量。eg：在使用二进制编码时，只有两种不同的码元：一种代表0状态，一种代表1状态；在使用四进制编码时，2bit位可以表示四种码元：00 01 10 11；使用n进制编码，就有n中码元，即有 <em>2的x次方 = n</em> ，x个bit来表示。</li></ol><h5 id="信源、信道与信宿"><a href="#信源、信道与信宿" class="headerlink" title="信源、信道与信宿"></a>信源、信道与信宿</h5><ol><li><strong>数据通信</strong>是指数字计算机或其他数字终端之间的通信。一个数据通信系统主要划分为信源、信道和信宿三部分。</li><li><strong>信源</strong>是产生和发送数据的源头。<strong>信宿</strong>是接收数据的终点，它们通常都是计算机或其他数字终端转置。需要通过<strong>变换器</strong>（调制解调器）转换成合适于在<strong>信道</strong>上传输的信号，也需要反转换器转成原始信息。</li><li>信道与电路不等同，<strong>信道</strong>是信号的<strong>传输媒介</strong>。<strong>噪声源</strong>是信道上的噪声（对信号的干扰）。</li><li>信道分为<strong>模拟信道</strong>和<strong>数字信道</strong>；也可分为<strong>无线信道</strong>和<strong>有线信道</strong>。</li><li>信道上传送信号有基带信号和宽带信号。<ul><li><strong>基带信号</strong>：将数字信号 1 和 0 直接用不同电压表示，然后传到数字信道上（基带传输）；</li><li><strong>宽带信号</strong>：将基带信号进行调制形成频分复用模拟信号，然后传到模拟信道上（宽带传输）；</li></ul></li><li>通信双方信息交互方式，可分为三种基本方式：<ul><li>单工通信：无线电、广播、电视广播</li><li>半双工：任何一方不能同时发送和接收信息</li><li>全双工</li></ul></li><li>信道的极限容量是指信道的<strong>最高码元传输速率</strong>或信道的极限信息传输速率。</li></ol><h5 id="速率、波特和带宽"><a href="#速率、波特和带宽" class="headerlink" title="速率、波特和带宽"></a>速率、波特和带宽</h5><ol><li><p>速率也称数据率，指数据传输速率，表示单位时间内传输的数据量<em>（s = vt）</em>。</p><ul><li><p><strong>码元传输速率</strong>。又称码元速率、波形速率。表示单位时间数字通信系统所传码元个数（也是脉冲个数或信号变化的次数），单位波特Baud。1 Baud = 1码元 / S。码元可多进制；码元速率与进制数无关。</p></li><li><p><strong>信息传输速率</strong>。又称信息速率，比特率。表示单位时间内数字通信系统传输的二进制码元个数（即比特数），单位比特/秒（b/s）。</p></li><li><p>若一个码元携带n比特的信息量，则M波特率的码元传输速率所对应的信息传输速率为 Mn b/s。</p><p>eg：若一码元携带2bit信息量，则5Baud的码元传输速率对应的信息传输速率为：<u>10 b/s</u>。</p><p>一码元携带2bit，即2*5=10 b/s。</p></li></ul></li><li><p>带宽原指具有的频带宽度，单位hz。在实际网络中，带宽表示最高数据率 b/s。</p></li></ol><h4 id="奈奎斯特定理与香浓定理（考纲）"><a href="#奈奎斯特定理与香浓定理（考纲）" class="headerlink" title="奈奎斯特定理与香浓定理（考纲）"></a>奈奎斯特定理与香浓定理（考纲）</h4><h5 id="奈斯定理"><a href="#奈斯定理" class="headerlink" title="奈斯定理"></a>奈斯定理</h5><ol><li><p>奈奎斯特（Nyquist）定理又称奈氏准则，在理想低通（没有噪声、宽带有限）的信道，极限码元传输速率为2W波特。W是理想低通信道的带宽，单位Hz。若用V表示每个码元离散电平的数目（即多少种不同的码元，即多少进制），则<strong>极限数据率</strong>为：</p><p><u><em>理想低通信道下的极限传输率 = 2Wlog2V b/s</em></u></p></li><li><p>奈氏准则结论：</p><ul><li>任何信道，码元传输速率有上限。超过上限会出现码间串扰。</li><li>信道频带越宽（通过的信号高频分量越多），就可用更高的速率进行码元的有效传输。</li><li>给出了码元传输速率的限制，但未限制每个码元可以对应多少个二进制位。</li></ul><p>提高数据传输速率，就设法使每个码元携带更多个比特的信息量，此时需要采用多元制的调制方法。</p></li></ol><h5 id="香浓定理"><a href="#香浓定理" class="headerlink" title="香浓定理"></a>香浓定理</h5><ol><li><p>香浓（Shannon）定理给出了 带宽受限 且 有高斯白噪音干扰 的信道极限数据传输率，可以做到不产生误差。定理定义为：</p><p><u><em>信道的极限数据传输率 = Wlog2（1+S/N） b/s</em></u></p><p>（W为信道带宽，S/N为信噪比；S为传输信号平均功率，N为信道内部高斯噪声功率）</p><p>单位转换：<u><em>信噪比 = 10log10（S/N）dB</em></u></p></li><li><p>香浓定理结论：</p><ul><li>信道带宽或信道中的信噪比越大，信息极限传输速率越高。</li><li>对一定的传输宽带和一定的噪声比，信息传输速率的上限是确定的。</li><li>只要信息的传输速率低于极限传输速率，就能找方法实现无差错的传输。</li><li>香浓定理得出信息极限传输速率，实际要低很多。</li></ul><p>若S/N没有上限，那么极限信息传输速率也没有上限。虽然实际信噪比有限制的。</p><p>限制了一个码元对应的二进制位数。</p></li></ol><h4 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h4><p>编码 –&gt;数字信号</p><p>调制 –&gt;模拟信号</p><h5 id="数字数据编码为数字信号（考纲）"><a href="#数字数据编码为数字信号（考纲）" class="headerlink" title="数字数据编码为数字信号（考纲）"></a>数字数据编码为数字信号（考纲）</h5><ol><li><p>归零编码</p></li><li><p>非归零编码</p></li><li><p>反向非归零编码</p></li><li><p>曼彻斯特编码（考纲）</p><p><strong>注意</strong>：以太网使用的编码方式就是 曼彻斯特编码。</p></li><li><p>查分曼彻思编码（考纲）</p></li></ol><h5 id="数字数据调制为模拟信号（考纲）"><a href="#数字数据调制为模拟信号（考纲）" class="headerlink" title="数字数据调制为模拟信号（考纲）"></a>数字数据调制为模拟信号（考纲）</h5><p>发送端数字数据调制为模拟信号在模拟信道上传输，在接收端将模拟信号还原为数字信号。对应调制解调器的调制和解调过程。</p><ol><li>调幅</li><li>调频</li><li>调相</li><li>调幅+调相</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;物理层&lt;/strong&gt; 第三节 通信基础：基本概念、奈奎斯特定理香浓定理、编码与调制&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="考研803" scheme="http://yoursite.com/tags/%E8%80%83%E7%A0%94803/"/>
    
  </entry>
  
  <entry>
    <title>计网2</title>
    <link href="http://yoursite.com/2020/05/06/%E8%AE%A1%E7%BD%912/"/>
    <id>http://yoursite.com/2020/05/06/%E8%AE%A1%E7%BD%912/</id>
    <published>2020-05-06T11:03:33.000Z</published>
    <updated>2021-01-12T10:08:54.367Z</updated>
    
    <content type="html"><![CDATA[<p><strong>概述</strong> 第二节 计算机网络体系结构与参考模型</p><a id="more"></a><h4 id="计算机网络分层结构"><a href="#计算机网络分层结构" class="headerlink" title="计算机网络分层结构"></a>计算机网络分层结构</h4><ol><li><p>我们把计算机网络的各层及其协议的集合 称为<strong>网络的体系结构</strong>，是从<strong>功能</strong>上描述计算机网络结构，是计算机网络中的层次、各层的协议及层间接口的集合。体系结构是抽象的，而实现是具体的。</p></li><li><p>分成的五个基本原则：</p><ul><li><p>每层都实现一种相对独立功能，降低大系统复杂度</p></li><li><p>各层之间界面自然清晰，易于理解，相互交流尽可能少</p></li><li><p>各层采用最合适的技术来实现</p></li><li><p>保持下层对上传的独立性，下层单项提供上层服务</p></li><li><p>整个分层结构促进标准化工作</p></li></ul></li><li><p>在计网分层结构中，第n层中的活动元素通常称为<strong>n层实体</strong>。不同及其上的同一层称为<strong>对等层</strong>，同一层的实体称为<strong>对等实体</strong>。n 提供服务给 n+1层。</p></li><li><p>在计网分层结构中，每个报文都分为两部分：数据部分 SDU 和控制信息部分 PCI，SDU+PCI = PDU</p></li><li><p>服务数据单元（SDU）、协议控制信息（PCI）、协议数据单元（PDU）；在各层间传输数据时，把从第n+1层收到的PDU作为第n层的SDU，加上第n层的PCI，变成了第n层的PDU，交给第n-1层作为SDU发送，接收方接收时做相反的处理。</p></li><li><p>物理层的PDU称为<strong>比特</strong>；链路层的PDU称为<strong>帧</strong>、网络层的PDU称为<strong>分组</strong>、传输层的PDU称为<strong>报文</strong>；</p></li></ol><h4 id="计算机网络的协议、接口、服务的概念"><a href="#计算机网络的协议、接口、服务的概念" class="headerlink" title="计算机网络的协议、接口、服务的概念"></a>计算机网络的协议、接口、服务的概念</h4><h5 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h5><ol><li>协议，就是规则的集合。为网络中的数据交换建立的规则、标准、约定称为<strong>网络协议</strong>（Network Protocol）；控制两个或多个对等实体进行通信的规则集合，是<strong>水平的</strong>。不对等实体之间是没有协议的。</li><li>协议由<strong>语法</strong>、<strong>语义</strong>和<strong>同步</strong>三部分组成。语法规定传输数据的格式（比如二进制 01）；语义规定了所要完成的功能，需要发出何种控制信息、完成何种动作、答复；同步规定了执行各操作的条件、时序关系等。</li><li>一个完整的协议通常具有线路管理（建立、释放连接）、差错控制、数据转换等功能。</li></ol><h5 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h5><p>接口时同一结点内相邻两层间交换信息的连接点，是一个系统内部的规定。每层只能为紧邻的层次之间定义接口，不能跨层定义接口。服务访问点（Service Access Point , SAP），服务是通过SAP提供给上层使用的。每个SAP都有一个能够表示它的地址。SAP是一个抽象概念，实际上是一个逻辑接口。</p><h5 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h5><p>服务是指下层为紧邻的上层提供的功能调用，是<strong>垂直的</strong>。对等实体在协议的控制下，使得本层能为上层提供服务。OSI中称为服务原语：请求、指示、响应、证实。</p><p>计算机网络提供的服务可按照以下分类</p><ul><li>面向连接服务与无连接服务</li><li>可靠服务和不可靠服务</li><li>有应答服务和无应答服务</li></ul><h4 id="ISO-OSI参考模型和TCP-IP模型（考纲）"><a href="#ISO-OSI参考模型和TCP-IP模型（考纲）" class="headerlink" title="ISO/OSI参考模型和TCP/IP模型（考纲）"></a>ISO/OSI参考模型和TCP/IP模型（考纲）</h4><p>目的：支持异构网络系统的互联互通。</p><h5 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h5><p>国际标准化组织ISO提出的网络体系结构模型，称为开放系统互联参考模型OSI/RM，简称为OSI参考模型，有7层。</p><img src="/2020/05/06/%E8%AE%A1%E7%BD%912/OSI%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.jpg" class><p>总结下：</p><ol><li>物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流(就是由1、0转化为电流强弱来进行传输，到达目的地后再转化为1、0，也就是我们常说的数模转换与模数转换)。这一层的数据叫做比特。</li><li>数据链路层：定义了如何让格式化数据以进行传输，以及如何让控制对物理介质的访问。这一层通常还提供错误检测和纠正，以确保数据的可靠传输。</li><li>网络层：在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择。Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。</li><li>传输层：定义了一些传输数据的协议和端口号(WWW端口80等)，如：TCP(传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据)，UDP(用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做段。</li><li>会话层：通过传输层(端口号：传输端口与接收端口)建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求(设备之间需要互相认识可以是IP也可以是MAC或者是主机名)。</li><li>表示层：可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换吗(EBCDIC)，而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。</li><li>应用层：是最靠近用户的OSI层。这一层为用户的应用程序(例如电子邮件、文件传输和终端仿真)提供网络服务。</li></ol><h5 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP/IP模型"></a>TCP/IP模型</h5><p>事实标准 4层</p><img src="/2020/05/06/%E8%AE%A1%E7%BD%912/TCPIP%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.jpg" class><p>总结下：</p><ol><li>TCP/IP参考模型是首先由ARPANET所使用的<a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=301274&ss_c=ssc.citiao.link" target="_blank" rel="noopener">网络体系结构</a>。这个体系结构在它的两个主要协议出现以后被称为TCP/IP参考模型(TCP/IP Reference Model)。这一网络协议共分为四层：<a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=166609564&ss_c=ssc.citiao.link" target="_blank" rel="noopener">网络访问层</a>、<a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=62691577&ss_c=ssc.citiao.link" target="_blank" rel="noopener">互联网层</a>、传输层和应用层</li><li>TCP/IP协议不是 TCP和 IP这两个协议的合称，而是指因特网整个TCP/IP协议族。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;概述&lt;/strong&gt; 第二节 计算机网络体系结构与参考模型&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="考研803" scheme="http://yoursite.com/tags/%E8%80%83%E7%A0%94803/"/>
    
  </entry>
  
  <entry>
    <title>计网1</title>
    <link href="http://yoursite.com/2020/05/06/%E8%AE%A1%E7%BD%911/"/>
    <id>http://yoursite.com/2020/05/06/%E8%AE%A1%E7%BD%911/</id>
    <published>2020-05-06T10:10:19.000Z</published>
    <updated>2021-01-12T10:08:32.726Z</updated>
    
    <content type="html"><![CDATA[<p><strong>概述</strong> 第一节 计算机网络体系结构的概述</p><a id="more"></a><h4 id="计算机网络的定义（考纲）"><a href="#计算机网络的定义（考纲）" class="headerlink" title="计算机网络的定义（考纲）"></a>计算机网络的定义（考纲）</h4><p>计算机网络就是一些 <strong>互联的</strong>、<strong>自治的</strong>计算机系统的集合。计算机网络是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现<strong>资源共享</strong>、<strong>信息传递</strong>的系统。</p><h4 id="计算机网络组成"><a href="#计算机网络组成" class="headerlink" title="计算机网络组成"></a>计算机网络组成</h4><img src="/2020/05/06/%E8%AE%A1%E7%BD%911/%E8%AE%A1%E7%BD%91%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86.svg" class><h4 id="计算机网络功能（考纲）"><a href="#计算机网络功能（考纲）" class="headerlink" title="计算机网络功能（考纲）"></a>计算机网络功能（考纲）</h4><p>主要有以下五大功能：</p><ol><li><strong>数据通信</strong>：最基本最重要的功能，实现联网计算机之间的各种信息的传输，并将分散在不同地理位置的计算机联系起来，统一分配、控制、管理。</li><li><strong>资源共享</strong>：资源共享可以是软件共享、数据共享、硬件共享。</li><li>分布式处理</li><li>提高可靠性</li><li>负载均衡：将工作任务均衡地分配给计算机网络中的各台计算机。</li></ol><h4 id="计算机网络分类"><a href="#计算机网络分类" class="headerlink" title="计算机网络分类"></a>计算机网络分类</h4><h5 id="按分布范围分类"><a href="#按分布范围分类" class="headerlink" title="按分布范围分类"></a>按分布范围分类</h5><p>后面会有详细讲解</p><ol><li>广域网（WAN）：远程，因特网核心</li><li>城域网（MAN）：大多采用以太网技术</li><li>局域网（LAN）：传统上，局域网使用广播技术、而广域网使用交换技术；校园网</li><li>个人区域网（PAN）：平板、手机</li></ol><h5 id="按传输技术分类"><a href="#按传输技术分类" class="headerlink" title="按传输技术分类"></a>按传输技术分类</h5><ol><li>广播式网络：所有互联计算机共享一个公共通信信道。局域网基本采用广播式通信技术，广域网中无线、卫星通信网络也采用广播式网络。</li><li>点对点网络：每条物理线路连接一对计算机。</li></ol><h5 id="拓扑结构分类（考纲）"><a href="#拓扑结构分类（考纲）" class="headerlink" title="拓扑结构分类（考纲）"></a>拓扑结构分类（考纲）</h5><p>网络拓扑结构是指由网中<strong>结点</strong>（<u>路由器</u>、<u>主机</u>等）与通信设备（网线）之间的几何关系表示的网络结构，主要指通信子网的拓扑结构。</p><p>（理解每一个拓扑结构的基本概念）：总线型、星型、环形、网状型网络；其中总线型、星型、环形多用于局域网、网状形多用于广域网。</p><h5 id="按使用者分类"><a href="#按使用者分类" class="headerlink" title="按使用者分类"></a>按使用者分类</h5><p>公用网、专用网</p><h5 id="按交换技术分类"><a href="#按交换技术分类" class="headerlink" title="按交换技术分类"></a>按交换技术分类</h5><p>电路交换、报文交换、分组交换</p><h5 id="按传输介质分类"><a href="#按传输介质分类" class="headerlink" title="按传输介质分类"></a>按传输介质分类</h5><p>有线无线</p><h4 id="计算机网络性能指标（考纲）"><a href="#计算机网络性能指标（考纲）" class="headerlink" title="计算机网络性能指标（考纲）"></a>计算机网络性能指标（考纲）</h4><table><thead><tr><th>性能指标</th><th>解释</th></tr></thead><tbody><tr><td>带宽</td><td>“最高数据率” 单位比特/秒（b/s）</td></tr><tr><td>时延</td><td>①.发送时延（传输时延）：<em>发送时延 = 分组长度 / 信道宽度</em>；<br>②.传播时延：电磁波在信道中传播一定的距离需要花费的时间：<em>传播时延 = 信道长度 / 电磁波在信道上的传播速率</em>；<br>③.处理时延 ④.排队时延。<br>总时延：为四个时延相加。</td></tr><tr><td>时延带宽积</td><td><em>时延带宽积 = 传播时延*信道带宽</em></td></tr><tr><td>往返时延</td><td>Round-Trip Time ，RTT，发送端发送数据开始，到发送端收到接收端的确认，总共经历的时延。</td></tr><tr><td>吞吐量</td><td>Throughput，单位时间内通过某个网络（或信道、接口）的数据率，吞吐量受网络额定速率的限制。</td></tr><tr><td>速率</td><td>数据率、比特率；单位为b/s 比特/秒；kb/s、Mb/s、Gb/s 。</td></tr><tr><td>信道利用率</td><td>信道利用率 = 有数据通过时间 / （有+无）数据通过时间</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;概述&lt;/strong&gt; 第一节 计算机网络体系结构的概述&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="考研803" scheme="http://yoursite.com/tags/%E8%80%83%E7%A0%94803/"/>
    
  </entry>
  
  <entry>
    <title>Mockjs</title>
    <link href="http://yoursite.com/2020/04/07/Mockjs/"/>
    <id>http://yoursite.com/2020/04/07/Mockjs/</id>
    <published>2020-04-07T06:57:50.000Z</published>
    <updated>2020-04-07T07:14:21.867Z</updated>
    
    <content type="html"><![CDATA[<p>mockjs 生成随机数据</p><a id="more"></a><blockquote><p>所有内容資料來自<a href="https://www.csdn.net/" target="_blank" rel="noopener"><img src="https://csdnimg.cn/cdn/content-toolbar/csdn-logo_.png?v=20190924.1" alt="img"></a></p></blockquote><p>前后端分离趋势，前端负责数据展示、页面动态效果等，后端负责编写应用程序接口，功页面、第三方等调用。有很多情况是，前端已经写好页面，一直等待后端接口的联调。所以现在就有造价数据的工具mockjs</p><p><strong>jquery 中 使用 mockjs来拦截ajax请求，并返回假数据。</strong></p><h5 id="引入mockjs"><a href="#引入mockjs" class="headerlink" title="引入mockjs"></a>引入mockjs</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Mock = <span class="built_in">require</span>(<span class="string">'mockjs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回字符串</span></span><br><span class="line">Mock.mock(<span class="string">'/api/data'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> Mock.mock(&#123;</span><br><span class="line">        <span class="string">'string|3'</span>: <span class="string">'*'</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回指定范围的整数</span></span><br><span class="line">Mock.mock(<span class="string">'/api/getInteger'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> Mock.mock(&#123;</span><br><span class="line">        <span class="string">'a|1-100'</span>: <span class="number">100</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回随机个数的对象</span></span><br><span class="line">Mock.mock(<span class="string">'/api/getObject'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> Mock.mock(&#123;</span><br><span class="line">        <span class="string">'brand|1-3'</span>: &#123;</span><br><span class="line">            a: <span class="string">'京东'</span>,</span><br><span class="line">            b: <span class="string">'国美'</span>,</span><br><span class="line">            c: <span class="string">'苏宁'</span>,</span><br><span class="line">            d: <span class="string">'当当'</span>,</span><br><span class="line">            e: <span class="string">'天猫'</span>,</span><br><span class="line">            f: <span class="string">'淘宝'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回随机数组</span></span><br><span class="line">Mock.mock(<span class="string">'/api/getArr'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> Mock.mock(&#123;</span><br><span class="line">        <span class="string">'data|1-10'</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="string">'name'</span>: <span class="string">'张三'</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回随机字符</span></span><br><span class="line">Mock.mock(<span class="string">'/api/getRandom1'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> Mock.mock(&#123;</span><br><span class="line">        <span class="string">'random1'</span>: <span class="regexp">/[a-z]&#123;2&#125;[A-Z]&#123;2&#125;[0-9]/</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回随机字符</span></span><br><span class="line">Mock.mock(<span class="string">'/api/getRandom2'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> Mock.mock(&#123;<span class="attr">random2</span>: <span class="string">'@string("lower", 5)'</span>&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回UUID</span></span><br><span class="line">Mock.mock(<span class="string">'/api/getUUID'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">'uuid'</span>: Mock.Random.id()&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"id|+1"</span>: <span class="number">1</span>, <span class="comment">//id的递增</span></span><br><span class="line"><span class="string">"name"</span>: <span class="string">"@cname"</span>, <span class="comment">// 姓名</span></span><br><span class="line"><span class="string">"email"</span>: <span class="string">"@email"</span>, <span class="comment">//邮箱</span></span><br><span class="line"><span class="string">"mobile"</span>: <span class="regexp">/^(13[0-9]|15[012356789]|166|17[3678]|18[0-9]|14[57])[0-9]&#123;8&#125;$/</span>, <span class="comment">//生成手机11位号  可以使用正则表达式</span></span><br><span class="line"><span class="string">"sex"</span>: <span class="string">"@boolean, // 随机boolean</span></span><br><span class="line"><span class="string">"</span>avatar<span class="string">":"</span>@image<span class="string">" // 图片</span></span><br><span class="line"><span class="string">"</span>avatar<span class="string">":"</span>@image(<span class="string">'50x50'</span>,<span class="string">'red'</span>,<span class="string">'#fff'</span>,<span class="string">'文字‘)"</span></span><br></pre></td></tr></table></figure><h5 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"Boolean"</span>: <span class="string">"@boolean"</span>, <span class="comment">// 布尔值</span></span><br><span class="line"><span class="string">"natural"</span>: <span class="string">"@natural"</span>, <span class="comment">// natural( min, max )</span></span><br><span class="line"><span class="string">"integer"</span>: <span class="string">"@integer"</span>, <span class="comment">// integer( min, max )</span></span><br><span class="line"><span class="string">"float"</span>: <span class="string">"@float(22,99,1,2)"</span>, <span class="comment">// float( min, max, dmin, dmax )</span></span><br><span class="line"><span class="string">"string"</span>: <span class="string">"@string"</span>, <span class="comment">//string(type,min,max) lower小写，upper大写，number数字，symbol符号，</span></span><br><span class="line"><span class="string">"range"</span>: <span class="string">"@range"</span>, <span class="comment">//range( start, stop, step ) step为间隔为，最后返回值为数组</span></span><br></pre></td></tr></table></figure><h5 id="時間"><a href="#時間" class="headerlink" title="時間"></a>時間</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"date"</span>: <span class="string">"@date"</span>, <span class="comment">// 日期</span></span><br><span class="line"><span class="string">"time"</span>: <span class="string">"@time"</span>, <span class="comment">// 时间</span></span><br><span class="line"><span class="string">"dataTime"</span>: <span class="string">"@datetime"</span>, <span class="comment">// 日期+时间</span></span><br><span class="line"><span class="string">"Now"</span>: <span class="string">"@now"</span>, <span class="comment">// 当前的日期时间</span></span><br></pre></td></tr></table></figure><h5 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h5><blockquote><p>凡是@后加c就是为中文；例如name为英文，cname则是中文</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"paragraph"</span>: <span class="string">"@cparagraph"</span>, <span class="comment">// 段落</span></span><br><span class="line"><span class="string">"title"</span>:<span class="string">"@ctitle(1,10)"</span>,<span class="comment">//标题，长度为1-10</span></span><br><span class="line"><span class="string">"sentence"</span>: <span class="string">"@csentence"</span>, <span class="comment">//句子</span></span><br><span class="line"><span class="string">"first"</span>: <span class="string">"@cfirst"</span>, <span class="comment">//姓氏</span></span><br></pre></td></tr></table></figure><h5 id="地方"><a href="#地方" class="headerlink" title="地方"></a>地方</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"region"</span>: <span class="string">"@region"</span>, <span class="comment">//方位</span></span><br><span class="line"><span class="string">"province"</span>: <span class="string">"@province"</span>, <span class="comment">//省份 </span></span><br><span class="line"><span class="string">"city"</span>: <span class="string">"@city"</span>, <span class="comment">// 城市 +(true)，可以获取到上一级，例如：@city(true) 可以获取到省市</span></span><br></pre></td></tr></table></figure><h5 id="对象和数组"><a href="#对象和数组" class="headerlink" title="对象和数组"></a>对象和数组</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"city|2-4"</span>: &#123;</span><br><span class="line">    <span class="string">"110000"</span>: <span class="string">"北京市"</span>,</span><br><span class="line">    <span class="string">"120000"</span>: <span class="string">"天津市"</span>,</span><br><span class="line">    <span class="string">"130000"</span>: <span class="string">"河北省"</span>,</span><br><span class="line">    <span class="string">"140000"</span>: <span class="string">"山西省"</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="string">"city|1"</span>: [</span><br><span class="line">    <span class="string">"北京市"</span>,</span><br><span class="line">    <span class="string">"天津市"</span>,</span><br><span class="line">    <span class="string">"河北省"</span>,</span><br><span class="line">    <span class="string">"山西省"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mockjs 生成随机数据&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="mock" scheme="http://yoursite.com/tags/mock/"/>
    
  </entry>
  
  <entry>
    <title>RESTfull</title>
    <link href="http://yoursite.com/2020/04/06/RESTfull/"/>
    <id>http://yoursite.com/2020/04/06/RESTfull/</id>
    <published>2020-04-06T02:26:24.000Z</published>
    <updated>2020-04-06T02:52:12.441Z</updated>
    
    <content type="html"><![CDATA[<p>RESTfull <em>一种软件架构风格、设计风格</em>，不是标准，提供了一组设计原则和约束条件。</p><a id="more"></a><p>主要用于客户端和服务器交互类软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存机制。<a href="https://baike.sogou.com/v73300762.htm?fromTitle=RESTful" target="_blank" rel="noopener">查看词条</a></p><h5 id="原则条件"><a href="#原则条件" class="headerlink" title="原则条件"></a>原则条件</h5><ol><li>REST 指的是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是 RESTful。</li><li>Web应用程序最重要的REST原则是，客户端和服务器之间的交互在请求之间是（http请求）无状态的。客户端到服务器的每一个请求都必须包含理解请求所必需的信息。</li><li>在服务器端，应用程序状态和功能可以分为各种资源。向客户端公开。每个资源都使用 URL 得到一个唯一的地址。所有资源都共享同一的接口，以便客户端和服务器之间传输状态。使用的是标准的 HTTP 方法，比如 GET、PUT、POST和DELETE</li></ol><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ol><li>每个URL代表 1 种资源</li><li>客户端使用GET、POST、PUT、DELETE4个表示操作方式的动词对服务端资源进行操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源；</li><li>资源的表现形式是 XML 或者 HTML</li><li>客户端与服务端之间的交互请求之间是无状态的。客户端到服务器的每一个请求都必须包含理解请求所必需的信息。</li></ol><h5 id="RESTful架构"><a href="#RESTful架构" class="headerlink" title="RESTful架构"></a>RESTful架构</h5><ol><li><p>RESTful架构是对MVC架构改进后所形成的一种架构，通过使用事先定义好的接口与不同的服务联系起来。在RESTful架构中，浏览器使用POST，DELETE，PUT和GET四种请求方式分别对指定的URL资源进行增删改查操作。因此，RESTful是通过URI实现对资源的管理及访问，具有扩展性强、结构清晰的特点。</p></li><li><p>RESTful架构将服务器分成前端服务器和后端服务器两部分，前端服务器为用户提供无模型的视图；后端服务器为前端服务器提供接口。浏览器向前端服务器请求视图，通过视图中包含的AJAX函数发起接口请求获取模型。</p></li></ol><h5 id="其他概念-更多"><a href="#其他概念-更多" class="headerlink" title="其他概念 (更多)"></a><a href="https://mp.weixin.qq.com/s?src=3&timestamp=1586138856&ver=1&signature=YaSPg7qpu0Qva1*0Fzsibkd*dUmaJaaRaWFCm3-pr1P-9LJdS0n17C0d*v1U1XkrVZ1MzAtvI5I*Euqi3Y9oBTCQGSLdTUalCdtpQVVTXLfAxGBasGoGcxLFxFzqUr7DADEmF*rpU-Hdyd0*7Pmvty3KNdVeA-ilKzurRx4iF5w=" target="_blank" rel="noopener">其他概念 (更多)</a></h5><h6 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h6><ol><li>服务器设计接口，应当设计为无状态接口。即服务器端不保存任何与客户端相关的状态上下文信息。 客户端在每次调用接口时，需要提供足够的信息，以供服务器完成操作</li><li>无状态设计中，服务端减少了保存客户端相关上下文数据，因此，一方面服务端能够更加容易实现动态扩展；减少了服务端从故障中恢复的任务量</li><li>但无状态也会带来额外的问题。客户端将需要保存完整的用户状态信息，在每次与服务端交互时可能需要增加与用户状态相关的上下文信息，这样将导致请求数据的重复和增大</li></ol><h6 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h6><ol><li>接口设计中增加缓存策略，服务器可以决定是否可以缓存当前返回的数据。这样 减少服务器被请求的次数，提高网络访问性能</li><li>缓存要谨慎使用，需要缓存什么数据，缓存过期时间等，要根据实际情况设计。</li><li>一般而言，数据字典类数据、修改频率非常低的数据、实时性要求很低的数据等，这些数据可以设计一定的缓存策略，以提高系统运行效率。</li></ol><h6 id="系统分层"><a href="#系统分层" class="headerlink" title="系统分层"></a>系统分层</h6><ol><li><p>横向分层一般可以分为 交互层 、服务层 、数据层 </p></li><li><p>纵向分层则通常会按照不同的业务功能对系统进行切分</p></li></ol><h6 id="统一接口"><a href="#统一接口" class="headerlink" title="统一接口"></a>统一接口</h6><p>​    统一接口，即是不同系统模块之间的调用接口统一规范，使用统一的调用协议，统一的数据格式等。统一接口带来的是系统交互的规范化，接口调用与业务解耦，各模块独立进化。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RESTfull &lt;em&gt;一种软件架构风格、设计风格&lt;/em&gt;，不是标准，提供了一组设计原则和约束条件。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="rest" scheme="http://yoursite.com/tags/rest/"/>
    
  </entry>
  
  <entry>
    <title>django搭建</title>
    <link href="http://yoursite.com/2020/04/03/django%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2020/04/03/django%E6%90%AD%E5%BB%BA/</id>
    <published>2020-04-03T15:51:15.000Z</published>
    <updated>2020-04-04T13:42:22.941Z</updated>
    
    <content type="html"><![CDATA[<p>搭建django的一些坑</p><a id="more"></a><h5 id="1-下载安装python"><a href="#1-下载安装python" class="headerlink" title="1. 下载安装python"></a>1. 下载安装python</h5><p>3.4以上新版python下载后自带pip，pip根据提示自我更新</p><h5 id="2-用python-的pip管理器去下载django"><a href="#2-用python-的pip管理器去下载django" class="headerlink" title="2. 用python 的pip管理器去下载django"></a>2. 用python 的pip管理器去下载django</h5><p>注意pip 和 django  和python 的版本</p><p>注意 pip 自我更新 和下载django的时候，报错重来，多下几次。</p><h5 id="3-配置django环境变量"><a href="#3-配置django环境变量" class="headerlink" title="3. 配置django环境变量"></a>3. 配置django环境变量</h5><p>在path中加入两个 一个是到script 一个是到bin</p><h5 id="4-下载安装pycharm社区版（官网）"><a href="#4-下载安装pycharm社区版（官网）" class="headerlink" title="4. 下载安装pycharm社区版（官网）"></a>4. 下载安装pycharm社区版（官网）</h5><p>目前双击打不开，用cmd可以输入pycharm打开，命令不能关</p><h5 id="5-pycharm-设置背景颜色-字体大小"><a href="#5-pycharm-设置背景颜色-字体大小" class="headerlink" title="5. pycharm 设置背景颜色 字体大小"></a>5. pycharm 设置背景颜色 字体大小</h5><p>settings里面的</p><h5 id="6-project-interpreter"><a href="#6-project-interpreter" class="headerlink" title="6. project interpreter"></a>6. project interpreter</h5><p>在settings -&gt; Project 中添加 python</p><h5 id="7-django项目要添加python-exe"><a href="#7-django项目要添加python-exe" class="headerlink" title="7. django项目要添加python.exe"></a>7. django项目要添加python.exe</h5><h5 id="8-在下面-的-Terminal终端中执行"><a href="#8-在下面-的-Terminal终端中执行" class="headerlink" title="8. 在下面 的 Terminal终端中执行"></a>8. 在下面 的 Terminal终端中执行</h5><p>python manage.py runserver 开启服务器，django自带一个小型服务器，自动开启8000端口号。可在settings文件中更改</p><h5 id="9-python-3-x和2-x"><a href="#9-python-3-x和2-x" class="headerlink" title="9. python 3.x和2.x"></a>9. python 3.x和2.x</h5><p>两个版本是由差距的，会影响django还有一些依赖插件比如pymysql是3.x用的</p><h5 id="10-接口测试时Forbidden-CSRF-cookie-not-set"><a href="#10-接口测试时Forbidden-CSRF-cookie-not-set" class="headerlink" title="10. 接口测试时Forbidden (CSRF cookie not set.)"></a>10. 接口测试时Forbidden (CSRF cookie not set.)</h5><p>可以去settings里面 MIDDLEWARE = [ 那个csrf. ]  注释掉</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Create your views here.</span></span><br><span class="line"><span class="keyword">from</span> django.views.decorators.csrf <span class="keyword">import</span> csrf_exempt</span><br><span class="line"> </span><br><span class="line"><span class="meta">@csrf_exempt </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_api</span><span class="params">(request)</span>:</span></span><br><span class="line">    dic = &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'GET'</span>:</span><br><span class="line">        dic[<span class="string">'message'</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(json.dumps(dic))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        dic[<span class="string">'message'</span>] = <span class="string">'方法错误'</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(json.dumps(dic, ensure_ascii=<span class="literal">False</span>))</span><br><span class="line">    </span><br><span class="line"> <span class="comment"># 这里是views里面的一个如何返回类似json文件的例子</span></span><br><span class="line"> <span class="comment"># 这样 就可以 简单的实现写views 不用管渲染的部分</span></span><br></pre></td></tr></table></figure><h5 id="11-ajax-简单传值"><a href="#11-ajax-简单传值" class="headerlink" title="11. ajax 简单传值"></a>11. ajax 简单传值</h5><img src="/2020/04/03/django%E6%90%AD%E5%BB%BA/d1.png" class><h5 id="12-Django-中-request方法"><a href="#12-Django-中-request方法" class="headerlink" title="12. Django 中 request方法"></a>12. Django 中 request方法</h5><p>request.session</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">请求的路径，这里的路径是指相对路径，也就是说一个登陆后台页面的请求：http:&#96;&#96;&#x2F;&#96;&#96;&#x2F;&#96;&#96;127.0&#96;&#96;.&#96;&#96;0.1&#96;&#96;:&#96;&#96;8000&#96;&#96;&#x2F;&#96;&#96;admin 的路径是 &#96;&#96;&#x2F;&#96;&#96;admin</span><br><span class="line">获取完整路径（包括参数）：HttpRequest.get_full_path()</span><br><span class="line">获取绝对url： HttpRequest.bulid_absolute_uri(location) 此参数默认为完整路径</span><br></pre></td></tr></table></figure><p>request.encoding</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请求提交的数据的编码方式</span><br></pre></td></tr></table></figure><p> request.session</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">request.session 获取的是一个类似于字典的对象，可以进行读取写入操作，常用来保存一些数据来实现会话跟踪技术。 因为 HTTP 是一个无状态，不连续的协议。如果想让服务器记住当前的访问对象，就需要记录请求者的一些信息来达到这个目的。</span><br><span class="line"># 设置session&#96;&#96;request.session[&#96;&#96;&quot;name&quot;&#96;&#96;] &#96;&#96;&#x3D;&#96; &#96;&quot;root&quot;&#96;&#96;# 获取session&#96;&#96;name &#96;&#96;&#x3D;&#96; &#96;request.sessin[&#96;&#96;&quot;name&quot;&#96;&#96;]</span><br></pre></td></tr></table></figure><p>django会默认为session使用json序列化。json序列化只能序列化一些基本数据类型，如数字，字符串，列表等。所以session不能直接存储对象.可以简单的在settings中添加 SESSION_SERIALIZER = “django.contrib.sessions.serializers.PickleSerializer”</p><p>request.method   请求方式POST/GET</p><h5 id="13-request获取数据"><a href="#13-request获取数据" class="headerlink" title="13. request获取数据"></a>13. request获取数据</h5><p>request.body</p><p>请求的主体，返回一个字符串</p><p>request.data</p><p>请求数据部分，返回一个字典对象，其他和request.body很想</p><p><strong>request.POST</strong></p><p>获取post方式表单中提交的数据</p><p>request.POST[“username”]</p><p>request.POST.get（“username”）</p><p>request.GET</p><p>获取get方式表单中或url提交的数据</p><p>request.GET[“username”]</p><p>request.GET.get（“username”）</p><h5 id="14-postman请求"><a href="#14-postman请求" class="headerlink" title="14. postman请求"></a>14. postman请求</h5><p>请求post时，在body里面写参数！！</p><p>请求get时，在params里面写参数！！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;搭建django的一些坑&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Django" scheme="http://yoursite.com/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>前端UI框架小总结</title>
    <link href="http://yoursite.com/2020/04/01/%E5%89%8D%E7%AB%AFUI%E6%A1%86%E6%9E%B6%E5%B0%8F%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/04/01/%E5%89%8D%E7%AB%AFUI%E6%A1%86%E6%9E%B6%E5%B0%8F%E6%80%BB%E7%BB%93/</id>
    <published>2020-04-01T09:42:36.000Z</published>
    <updated>2020-04-01T09:55:19.724Z</updated>
    
    <content type="html"><![CDATA[<p>收集前端UI框架 包括移动端 PC端的官网</p><a id="more"></a><hr><blockquote><h4 id="移动端UI框架"><a href="#移动端UI框架" class="headerlink" title="移动端UI框架"></a>移动端UI框架</h4></blockquote><h5 id="Mint-UI（饿了么团队）"><a href="#Mint-UI（饿了么团队）" class="headerlink" title="Mint UI（饿了么团队）"></a><strong>Mint UI（饿了么团队）</strong></h5><p>中文官网：<a href="http://mint-ui.github.io/#!/zh-cn" target="_blank" rel="noopener">http://mint-ui.github.io/#!/zh-cn</a></p><p>描述：基于vue的移动端UI框架<br>基于vue</p><p>GitHub地址：<a href="https://github.com/ElemeFE/mint-ui/" target="_blank" rel="noopener">https://github.com/ElemeFE/mint-ui/</a></p><h5 id="Weui（微信官方设计团队）"><a href="#Weui（微信官方设计团队）" class="headerlink" title="Weui（微信官方设计团队）"></a>Weui（微信官方设计团队）</h5><p>描述：WeUI 为微信 Web 服务量身设计,是一套同微信原生视觉体验一致的基础样式库，由微信官方设计团队为微信 Web 开发量身设计，可以令用户的使用感知更加统一。</p><p>GitHub地址：<a href="https://github.com/weui/weui" target="_blank" rel="noopener">https://github.com/weui/weui</a></p><h5 id="Pure"><a href="#Pure" class="headerlink" title="Pure"></a>Pure</h5><p>中文官网：<a href="https://www.purecss.cn/" target="_blank" rel="noopener">https://www.purecss.cn/</a><br>描述：纯CSS<br>美国雅虎公司出品的一组轻量级、响应式纯css模块，适用于任何Web项目。<br>GitHub：<a href="https://github.com/yahoo/pure/" target="_blank" rel="noopener">https://github.com/yahoo/pure/</a></p><blockquote><h4 id="PC-端-UI框架"><a href="#PC-端-UI框架" class="headerlink" title="PC 端 UI框架"></a><strong>PC 端 UI框架</strong></h4></blockquote><h5 id="Element-UI（饿了么团队）"><a href="#Element-UI（饿了么团队）" class="headerlink" title="Element UI（饿了么团队）"></a>Element UI（饿了么团队）</h5><p>官方地址：<a href="http://element-cn.eleme.io/#/zh-CN" target="_blank" rel="noopener">http://element-cn.eleme.io/#/zh-CN</a><br>描述：基于 Vue 2.0 的桌面端组件库<br>GitHub：<a href="https://github.com/ElemeFE/element" target="_blank" rel="noopener">https://github.com/ElemeFE/element</a></p><h5 id="iView"><a href="#iView" class="headerlink" title="iView"></a>iView</h5><p>官网地址：<a href="https://www.iviewui.com/" target="_blank" rel="noopener">https://www.iviewui.com/</a><br>描述：一套基于 Vue.js 的高质量 UI 组件库。iView 是一套基于 Vue.js 的开源 UI 组件库，主要服务于 PC 界面的中后台产品。<br>GitHub地址：<a href="https://github.com/iview/iview" target="_blank" rel="noopener">https://github.com/iview/iview</a></p><h5 id="layui"><a href="#layui" class="headerlink" title="layui"></a>layui</h5><p>官方地址：<a href="http://www.layui.com/" target="_blank" rel="noopener">http://www.layui.com/</a></p><p>描述：更多是为服务端程序员量身定做，你无需涉足各种前端工具的复杂配置，只需面对浏览器本身，让一切你所需要的元素与交互，从这里信手拈来。</p><p>layui 兼容人类正在使用的全部浏览器（IE6/7除外），可作为 PC 端后台系统与前台界面的速成开发方案。</p><p>GitHub：<a href="https://github.com/sentsin/layui/" target="_blank" rel="noopener">https://github.com/sentsin/layui/</a></p><h5 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h5><p>中文官网：<a href="http://www.bootcss.com/" target="_blank" rel="noopener">http://www.bootcss.com/</a><br>描述：简洁、直观、强悍的前端开发框架，让web开发更迅速、简单。</p><p>GitHub地址：<a href="https://github.com/twbs/bootstrap" target="_blank" rel="noopener">https://github.com/twbs/bootstrap</a></p><h5 id="jQuery-UI"><a href="#jQuery-UI" class="headerlink" title="jQuery UI"></a>jQuery UI</h5><p>官方网址：<a href="http://jqueryui.com/" target="_blank" rel="noopener">http://jqueryui.com/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;收集前端UI框架 包括移动端 PC端的官网&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="UI" scheme="http://yoursite.com/tags/UI/"/>
    
  </entry>
  
  <entry>
    <title>网络安全之攻守道</title>
    <link href="http://yoursite.com/2020/03/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B9%8B%E6%94%BB%E5%AE%88%E9%81%93/"/>
    <id>http://yoursite.com/2020/03/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B9%8B%E6%94%BB%E5%AE%88%E9%81%93/</id>
    <published>2020-03-30T00:40:51.000Z</published>
    <updated>2020-03-30T08:27:30.645Z</updated>
    
    <content type="html"><![CDATA[<p>网络安全，就是攻守之间的对抗</p><a id="more"></a><blockquote><p>学习地址指路 <a href="https://www.bilibili.com/video/BV1yW411q7GF" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1yW411q7GF</a></p></blockquote><h5 id="Http-传输数据存在的问题"><a href="#Http-传输数据存在的问题" class="headerlink" title="Http 传输数据存在的问题"></a>Http 传输数据存在的问题</h5><p>http协议传输，超文本传输协议HTTP协议被用于在Web浏览器和网络服务器之间传递信息。HTTP协议以明文方式发送内容，不提供任何方式的数据加密。所以如果黑客截取了Web浏览器和网站服务器之间的传输报文，就可以直接读取重要信息（密码 账号 卡号等）。</p><h5 id="Https-简介"><a href="#Https-简介" class="headerlink" title="Https 简介"></a>Https 简介</h5><p>https协议，安全套接字层超文本传输协议HTTPS。是在HTTP的基础上加了SSL（Secure，Sockets，Layer，安全套接字层）。SSL依靠证书来验证服务器的身份，为浏览器和服务器之间的通信加密。</p><img src="/2020/03/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B9%8B%E6%94%BB%E5%AE%88%E9%81%93/w1.png" class><h5 id="Https-和Http-的区别"><a href="#Https-和Http-的区别" class="headerlink" title="Https 和Http 的区别"></a>Https 和Http 的区别</h5><ol><li>https协议需要到 ca 申请证书，一般都要收费</li><li>http是超文本传输协议，信息是明文传输，连接很简单，https协议是由SSL+HTTP协议构建的 可进行 加密传输、身份认证的网络协议。安全性更高</li><li>http 和 https 使用的是完全 不同 的连接方式，用的端口不一样。前者是 80 端口，后者是 443</li></ol><h5 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a><a href="https://baike.sogou.com/v214573.htm?fromTitle=ssl" target="_blank" rel="noopener">SSL</a></h5><ol><li><p>定义</p><p>SSL(Secure Sockets Layer<a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=7628534&ss_c=ssc.citia" target="_blank" rel="noopener">安全套接层</a>,及其继任者<a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=25967&ss_c=ssc.citiao.link" target="_blank" rel="noopener">传输层安全</a>（<a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=101608365&ss_c=ssc.citiao.link" target="_blank" rel="noopener">Transport</a> Layer Security，TLS）是为网络通信提供安全及<a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=340077&ss_c=ssc.citiao.link" target="_blank" rel="noopener">数据完整性</a>的一种安全协议。TLS与SSL在传输层与<a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=16954&ss_c=ssc.citiao.link" target="_blank" rel="noopener">应用层</a>之间对网络连接进行加密。</p></li><li><p>作用</p><p>认证用户和服务器，确保数据发送到正确的 客户机 和 服务器；</p><p>加密数据以防止数据中途被窃取；</p><p>维护数据的完整性，确保数据在传输过程中不被改变。</p></li><li><p>服务器类型</p><ol><li><p>Tomcat 5.x</p></li><li><p>Nginx</p></li><li><p>IIS</p></li><li><p>Apache 2.x</p></li><li><p>IBM HTTP SERVER 6.0</p></li></ol></li></ol><h5 id="SSL-安全加密方式"><a href="#SSL-安全加密方式" class="headerlink" title="SSL 安全加密方式"></a>SSL 安全加密方式</h5><p>了解加密方式，分为对称加密和非对称加密</p><ol><li>对称加密(Symmetric Cryptography)<ul><li>原理：加密算法是公开的，靠的是密钥来加密数据；使用一个密钥加密，使用相同的密钥解密</li><li>常用对称加密算法：DES,  3DES， AES(破解难度大)</li><li>注意：在传输加密数据之前，需要传递密钥</li><li><img src="/2020/03/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B9%8B%E6%94%BB%E5%AE%88%E9%81%93/w4.png" class></li><li><img src="/2020/03/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B9%8B%E6%94%BB%E5%AE%88%E9%81%93/w2.png" class></li></ul></li><li>对称加密优缺点<ul><li>优点：计算量较小，加密和解密的速度比较快，适合加密比较大的数据</li><li>缺点：密钥的传输容易泄露；一个用户需要对应一个密钥，服务器管理密钥比较麻烦</li></ul></li><li>非对称加密<ul><li>原理：算法公开，一个公钥(public key)和一个私钥(private key)。 公钥加密只能私钥解密；私钥加密只能公钥解密，加密和解密的钥匙不同，即非对称加密</li><li>常用非对称加密算法：RSA</li><li>注意：公钥私钥需要加密算法生成</li><li><img src="/2020/03/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B9%8B%E6%94%BB%E5%AE%88%E9%81%93/w3.png" class></li></ul></li><li>非对称加密优缺点<ul><li>优点：加密和解密使用不同钥匙，可以传输公钥，数据传输是安全的</li><li>缺点：计算量大，加密解密速度较慢</li></ul></li></ol><h5 id="Https-传输"><a href="#Https-传输" class="headerlink" title="Https 传输"></a>Https 传输</h5><p>Https加密、解密及验证过程，两种加密方式结合使用</p><p>先使用非对称加密，服务器传输公钥 SSL数字证书；浏览器生成随机码，通过公钥传输给服务器。服务器通过私钥解开随机码。</p><p>将随机码作为密钥，使用对称加密(速度快)，将用户的重要信息通过随机码也就是密钥加密传过去。服务器之前已经用私钥解开了随机码（密钥），所以服务器用随机码（密钥）解开重要信息。</p><img src="/2020/03/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B9%8B%E6%94%BB%E5%AE%88%E9%81%93/w5.png" class><h5 id="服务器实现Https-协议"><a href="#服务器实现Https-协议" class="headerlink" title="服务器实现Https 协议"></a>服务器实现Https 协议</h5><ol><li><p>配置</p><ul><li><p>生成密钥库</p><p>确保环境变量配置了%JAVA_HOME%\bin, 因为生成密钥库是使用 jdk 中的 keytool工具</p><p>进入dos命令运行如下命令：</p><p>keytool -genkeypair -alias test-cyq -validity 3650 -keyalg RSA -dname \</p><p>123456</p></li><li><p>配置tomcat 启用https 协议并指定密钥库</p><p>进入server.xml ，将http配置注释掉，打开https，并配置https两个属性，指定密钥库的位置和密钥库的密码</p></li></ul></li><li><p>SSL 证书种类</p><p>域名型 DVSSL</p><p>企业型 OVSSL</p><p>增强型 EVSSL</p></li></ol><h5 id="Https-优缺点"><a href="#Https-优缺点" class="headerlink" title="Https 优缺点"></a>Https 优缺点</h5><p>优点：安全性高</p><p>缺点：收费，也不是绝对安全，耗电耗资源</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网络安全，就是攻守之间的对抗&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="网络安全" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>前端需要注意的SEO</title>
    <link href="http://yoursite.com/2020/03/29/%E5%89%8D%E7%AB%AF%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84SEO/"/>
    <id>http://yoursite.com/2020/03/29/%E5%89%8D%E7%AB%AF%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84SEO/</id>
    <published>2020-03-29T08:27:58.000Z</published>
    <updated>2020-03-29T08:33:21.720Z</updated>
    
    <content type="html"><![CDATA[<p>SEO (搜索引擎优化)</p><a id="more"></a><ul><li>合理的<code>title</code>、<code>description</code>、<code>keywords</code>：搜索对着三项的权重逐个减小，<code>title</code>值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面<code>title</code>要有所不同；<code>description</code>把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面<code>description</code>有所不同；<code>keywords</code>列举出重要关键词即可</li><li>语义化的<code>HTML</code>代码，符合W3C规范：语义化代码让搜索引擎容易理解网页</li><li>重要内容<code>HTML</code>代码放在最前：搜索引擎抓取<code>HTML</code>顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取</li><li>重要内容不要用<code>js</code>输出：爬虫不会执行js获取内容</li><li>少用<code>iframe</code>：搜索引擎不会抓取<code>iframe</code>中的内容</li><li>非装饰性图片必须加<code>alt</code></li><li>提高网站速度：网站速度是搜索引擎排序的一个重要指标</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SEO (搜索引擎优化)&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="SEO" scheme="http://yoursite.com/tags/SEO/"/>
    
  </entry>
  
  <entry>
    <title>Ajax和JSON</title>
    <link href="http://yoursite.com/2020/03/29/Ajax%E5%92%8CJSON/"/>
    <id>http://yoursite.com/2020/03/29/Ajax%E5%92%8CJSON/</id>
    <published>2020-03-29T08:09:26.000Z</published>
    <updated>2020-04-05T04:06:46.378Z</updated>
    
    <content type="html"><![CDATA[<p>ajax and json</p><a id="more"></a><h5 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h5><blockquote><p>Ajax（Asynchronous <a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=2484&ss_c=ssc.citiao.link" target="_blank" rel="noopener">JavaScript</a> and XML），用于创建更好更快以及交互性更强的<a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=159605&ss_c=ssc.citiao.link" target="_blank" rel="noopener">Web应用程序</a>的技术，与传统的Web应用相比，Ajax通过浏览器与服务器进行少量的数据交换就可以实现网页的异步更新，在不重新加载整个网页的情况下，即可对网页进行更新。</p></blockquote><h5 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h5><blockquote><p>JSON(JavaScriptObject Notation, JS 对象简谱) 是一种<a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=7988600&ss_c=ssc.citiao.link" target="_blank" rel="noopener">轻量级</a>的数据交换格式，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。JSON（常用于数据交互）和XML（常用于文件配置）可读性不相上下。</p></blockquote><p>在JS语言中，一切都是对象，因此任何JS支持的类型，都可以通过JSON来表示，例如字符串、数字、对象数组等。</p><ul><li>对象表示为键值对</li><li>数据由逗号分隔</li><li>花括号保存对象</li><li>方括号保存数组</li></ul><p>JSON是JS对象的字符串表示法，它使用文本表示一个JS对象的信息，本质是一个<strong>字符串</strong></p><h5 id="JSON和JS对象互转"><a href="#JSON和JS对象互转" class="headerlink" title="JSON和JS对象互转"></a>JSON和JS对象互转</h5><p>从JSON字符串转换为JS对象，使用JSON.parse()方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">JSON</span>.parse(<span class="string">'&#123;"a":"hello","b":"world"&#125;'</span>)</span><br></pre></td></tr></table></figure><p>从JS对象转换为JSON字符串，使用JSON.stringify()方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> json = <span class="built_in">JSON</span>.stringify(&#123;<span class="string">"a"</span>:<span class="string">"hello"</span>,<span class="string">"b"</span>:<span class="string">"world"</span>&#125;)</span><br></pre></td></tr></table></figure><h5 id="jQuery-parseJSON-函数"><a href="#jQuery-parseJSON-函数" class="headerlink" title="jQuery.parseJSON()函数"></a>jQuery.parseJSON()函数</h5><p>用于将格式完好的JSON字符串转为与之对应的JavaScript对象。</p><p>所谓”格式完好”，就是要求指定的字符串必须符合严格的JSON格式，例如：属性名称必须加双引号、字符串值也必须用双引号。</p><p>如果传入一个格式不”完好”的JSON字符串将抛出一个JS异常，</p><p>例如：以下字符串均符合JSON格式，但它们不是格式完好的JSON字符串(因此会抛出异常)：</p><p>// 以下均是字符串值，省略了两侧的引号，以便于展现内容</p><p>{id: 1} // id是属性名称，必须加双引号<br>{‘id’: 1} // id是属性名称，必须用双引号(不能用单引号)<br>{“name”: ‘CodePlayer’} // name属性的值是字符串，必须用双引号(不能用单引号)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ajax and json&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="json ajax" scheme="http://yoursite.com/tags/json-ajax/"/>
    
  </entry>
  
  <entry>
    <title>JWT认证</title>
    <link href="http://yoursite.com/2020/03/29/JWT%E8%AE%A4%E8%AF%81/"/>
    <id>http://yoursite.com/2020/03/29/JWT%E8%AE%A4%E8%AF%81/</id>
    <published>2020-03-29T03:33:39.000Z</published>
    <updated>2020-03-29T08:02:17.973Z</updated>
    
    <content type="html"><![CDATA[<p>JSON Web Token（JWT）</p><a id="more"></a><hr><blockquote><p>学习文档转自 <a href="https://www.cnblogs.com/haha12/p/11796456.html" target="_blank" rel="noopener">https://www.cnblogs.com/haha12/p/11796456.html</a></p></blockquote><hr><h5 id="JWT简介"><a href="#JWT简介" class="headerlink" title="JWT简介"></a>JWT简介</h5><p>JSON Web Token（JWT）是一个开放的标准（RFC 7519），它定义了一个紧凑且自包含的方式，用于在各方之间作为JSON对象安全地传输信息。由于此信息是经过数字签名的，因此可以被验证和信任。</p><h5 id="JWT认证和session认证的区别"><a href="#JWT认证和session认证的区别" class="headerlink" title="JWT认证和session认证的区别"></a>JWT认证和session认证的区别</h5><ol><li><p>session认证</p><p>http协议是一种无状态的协议，而这就意味着如果用户向我们的应用提供了用户名和密码来进行用户认证，那么下一次请求时，用户还要再一次进行用户认证才行，因为根据http协议，我们并不能知道是哪个用户发送的请求，所以为了让我们的应用能识别是哪个用户发出的，我们只能在服务器存储一份用户登陆的信息，这份登陆信息会在响应时传递给浏览器，告诉其保存为cookie，以便下次请求时发送给我们的应用，这样我们的应用个就能识别请求来自哪个用户了，这就是传统的基于sessino认证。</p></li><li><p>JWT认证</p><p>基于token的鉴权机制类似于http协议也是无状态的，它不需要在服务端去保留用户的认证信息或会话信息。这也就意味着JWT认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利。</p></li><li><p>JWT认证流程</p><img src="/2020/03/29/JWT%E8%AE%A4%E8%AF%81/j1.png" class><p>认证流程如下：</p><ol><li>用户使用账号和密码发出post请求；</li><li>服务器使用私钥创建一个jwt；</li><li>服务器返回这个jwt给浏览器；</li><li>浏览器将该jwt串在请求头中像服务器发送请求；</li><li>服务器验证该jwt；</li><li>返回响应的资源给浏览器。</li></ol></li><li><p>JWT组成</p><img src="/2020/03/29/JWT%E8%AE%A4%E8%AF%81/j2.png" class><p>从上图可以看到，JWT含有三部分：头部（header）、载荷（payload）、签名（signature）。</p><p>1.头部</p><p>JWT的头部有两部分信息：</p><ul><li>声明类型，这里是JWT</li><li>声明加密的算法，通常直接使用HMAC SHA256</li></ul><p>头部示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"alg"</span>: <span class="string">"HS256"</span>,</span><br><span class="line">  <span class="string">"typ"</span>: <span class="string">"JWT"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>头部一般使用base64加密，加密后密文：eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9</p><p>2.载荷</p><p>该部分一般存放一些有效的信息。JWT的标准定义包含五个字段：</p><ul><li>iss：该JWT的签发者</li><li>sub: 该JWT所面向的用户</li><li>aud: 接收该JWT的一方</li><li>exp(expires): 什么时候过期，这里是一个Unix时间戳</li><li>iat(issued at): 在什么时候签发的</li></ul><p>载荷示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"sub"</span>: <span class="string">"1234567890"</span>,</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"Java碎碎念"</span>,</span><br><span class="line">  <span class="string">"iat"</span>: <span class="number">1516239022</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.签名</p><p>前面两部分都是使用Base64进行编码的，即前端可以解开知道里面的信息。signature 需要使用编码后的header和payload以及我们提供的一个密钥，然后使用header中指定的签名算法（HS256）进行签名。签名的作用是保证 JWT 没有被篡改过。</p><p>三个部分通过.连接在一起就是我们的 JWT 了，所以我们生成的JWT如下：</p><p><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkphdmHnoo7noo7lv7UiLCJpYXQiOjE1MTYyMzkwMjJ9.LLJIkhJs6SVYlzn3n8fThQmhGutjTDI3RURTLtHV4ls</code></p><p>注意：密钥就是用来进行JWT的签发和JWT的验证，所以，它就是你服务端的私钥，在任何场景都不应该泄露出去。</p></li><li><p>JWT使用场景</p><p>JWT主要使用场景如下：</p><ul><li>授权</li></ul><p>这是JWT使用最多的场景，一旦用户登录，每个后续的请求将包括JWT，从而允许用户访问该令牌允许的路由、服务和资源。</p><ul><li>信息交换：JSON</li></ul><p>JWT可以用在各方之间安全地传输信息，因为JWT可以进行签名，所以您可以确定发件人是他们所说的人。另外，由于签名是使用标头和有效负载计算的，因此您还可以验证内容是否未被篡改。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JSON Web Token（JWT）&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="验证" scheme="http://yoursite.com/tags/%E9%AA%8C%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>Django Vuejs</title>
    <link href="http://yoursite.com/2020/03/28/Django-Vuejs/"/>
    <id>http://yoursite.com/2020/03/28/Django-Vuejs/</id>
    <published>2020-03-28T13:44:40.000Z</published>
    <updated>2020-03-29T03:42:57.097Z</updated>
    
    <content type="html"><![CDATA[<p>django with vuejs</p><a id="more"></a><hr><blockquote><p>博客：<a href="https://zhuanlan.zhihu.com/p/25080236" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25080236</a></p><p>github：<a href="https://github.com/tmpbook/django-with-vuejs" target="_blank" rel="noopener">https://github.com/tmpbook/django-with-vuejs</a></p></blockquote><hr><img src="/2020/03/28/Django-Vuejs/d1.png" class>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;django with vuejs&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Django" scheme="http://yoursite.com/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>jQuery</title>
    <link href="http://yoursite.com/2020/03/27/jQuery/"/>
    <id>http://yoursite.com/2020/03/27/jQuery/</id>
    <published>2020-03-27T11:27:50.000Z</published>
    <updated>2020-03-29T03:47:18.161Z</updated>
    
    <content type="html"><![CDATA[<p>jquery基础整合</p><a id="more"></a><blockquote><p>学习文档转自黑马教程</p></blockquote><p>使用javascript开发过程中，有许多的缺点：</p><ol><li>查找元素的方法单一，麻烦。</li><li>遍历数组很麻烦，通常要嵌套一大堆的for循环。</li><li>有兼容性问题。</li><li>想要实现简单的动画效果，也很麻烦</li><li>代码冗余。</li></ol><h2 id="体验jquery的使用"><a href="#体验jquery的使用" class="headerlink" title="体验jquery的使用"></a>体验jquery的使用</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 1. 查找元素的方法多种多样，非常灵活</span></span><br><span class="line"><span class="comment">* 2. 拥有隐式迭代特性，因此不再需要手写for循环了。</span></span><br><span class="line"><span class="comment">* 3. 完全没有兼容性问题。</span></span><br><span class="line"><span class="comment">* 4. 实现动画非常简单，而且功能更加的强大。</span></span><br><span class="line"><span class="comment">* 5. 代码简单、粗暴。</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">"#btn1"</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        $(<span class="string">"div"</span>).show(<span class="number">200</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    $(<span class="string">"#btn2"</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        $(<span class="string">"div"</span>).text(<span class="string">"我是内容"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="jquery到底是什么"><a href="#jquery到底是什么" class="headerlink" title="jquery到底是什么"></a>jquery到底是什么</h2><blockquote><p>jQuery的官网 <a href="http://jquery.com/" target="_blank" rel="noopener">http://jquery.com/</a><br>jQuery就是一个js库，使用jQuery的话，会比使用JavaScript更简单。</p></blockquote><p><strong>What is jQuery?</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jQuery is a fast, small, and feature-rich JavaScript library. </span><br><span class="line">It makes things like HTML document traversal and manipulation, </span><br><span class="line">event handling, animation, and Ajax </span><br><span class="line">much simpler with an easy-to-use API that works across a multitude of browsers. </span><br><span class="line">With a combination of versatility and extensibility, </span><br><span class="line">jQuery has changed the way that millions of people write JavaScript.</span><br></pre></td></tr></table></figure><p>js库：把一些常用到的方法写到一个单独的js文件，使用的时候直接去引用这js文件就可以了。<br>（animate.js、common.js）</p><p>我们知道了，jQuery其实就是一个js文件，里面封装了一大堆的方法方便我们的开发，<br>其实就是一个加强版的common.js，因此我们学习jQuery，其实就是学习jQuery这个js文件中封装的一大堆方法。</p><h2 id="jquery的版本问题"><a href="#jquery的版本问题" class="headerlink" title="jquery的版本问题"></a>jquery的版本问题</h2><blockquote><p>官网下载地址：<a href="http://jquery.com/download/" target="_blank" rel="noopener">http://jquery.com/download/</a><br>jQuery版本有很多，分为1.x 2.x 3.x<br>1.x和2.x版本jquery都不再更新版本了，现在只更新3.x版本。</p></blockquote><p>大版本分类：</p><ul><li>1.x版本：能够兼容IE678浏览器</li><li>2.x版本：不能兼容IE678浏览器</li><li>3.x版本：不能兼容IE678浏览器，更加的精简（在国内不流行，因为国内使用jQuery的主要目的就是兼容IE678）</li></ul><p>关于压缩版和未压缩版：  </p><ul><li>jquery-1.12.4.min.js:压缩版本，适用于生产环境，因为文件比较小，去除了注释、换行、空格等东西，但是基本没有颗阅读性。</li><li>jquery-1.12.4.js:未压缩版本，适用于学习与开发环境，源码清晰，易阅读。</li></ul><h2 id="jquery的入口函数"><a href="#jquery的入口函数" class="headerlink" title="jquery的入口函数"></a>jquery的入口函数</h2><p>使用jQuery的三个步骤：</p><ol><li>引入jQuery文件</li><li>入口函数</li><li>功能实现</li></ol><p>关于jQuery的入口函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种写法</span></span><br><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//第二种写法</span></span><br><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>jQuery入口函数与js入口函数的对比：</p><ol><li>JavaScript的入口函数要等到页面中所有资源（包括图片、文件）加载完成才开始执行。</li><li>jQuery的入口函数只会等待文档树加载完成就开始执行，并不会等待图片、文件的加载。</li></ol><h2 id="jq对象和dom对象-重要"><a href="#jq对象和dom对象-重要" class="headerlink" title="jq对象和dom对象(重要)"></a>jq对象和dom对象(重要)</h2><ol><li>DOM对象：使用JavaScript中的方法获取页面中的元素返回的对象就是dom对象。</li><li>jQuery对象：jquery对象就是使用jquery的方法获取页面中的元素返回的对象就是jQuery对象。</li><li>jQuery对象其实就是DOM对象的包装集<strong>包装了DOM对象的集合（伪数组）</strong></li><li>DOM对象与jQuery对象的方法不能混用。</li></ol><p>DOM对象转换成jQuery对象：【联想记忆：花钱】</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $obj = $(domObj);</span><br><span class="line"><span class="comment">// $(document).ready(function()&#123;&#125;);就是典型的DOM对象转jQuery对象</span></span><br></pre></td></tr></table></figure><p>jQuery对象转换成DOM对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $li = $(<span class="string">"li"</span>);</span><br><span class="line"><span class="comment">//第一种方法（推荐使用）</span></span><br><span class="line">$li[<span class="number">0</span>]</span><br><span class="line"><span class="comment">//第二种方法</span></span><br><span class="line">$li.get(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="jquery选择器"><a href="#jquery选择器" class="headerlink" title="jquery选择器"></a>jquery选择器</h2><h3 id="什么是jQuery选择器"><a href="#什么是jQuery选择器" class="headerlink" title="什么是jQuery选择器"></a>什么是jQuery选择器</h3><ul><li>jQuery选择器是jQuery为我们提供的一组方法，让我们更加方便的获取到页面中的元素。<br>注意：jQuery选择器返回的是jQuery对象。</li><li>jQuery选择器有很多，基本兼容了CSS1到CSS3所有的选择器，并且jQuery还添加了很多扩展性的选择器。<br>【查看jQuery文档】</li><li>jQuery选择器虽然很多，但是选择器之间可以相互替代，就是说获取一个元素，你会有很多种方法获取到。<br>所以我们平时真正能用到的只是少数的最常用的选择器。</li></ul><h3 id="基本选择器"><a href="#基本选择器" class="headerlink" title="基本选择器"></a>基本选择器</h3><table><thead><tr><th>名称</th><th>用法</th><th align="left">描述</th></tr></thead><tbody><tr><td>ID选择器</td><td>$(“#id”);</td><td align="left">获取指定ID的元素</td></tr><tr><td>类选择器</td><td>$(“.class”);</td><td align="left">获取同一类class的元素</td></tr><tr><td>标签选择器</td><td>$(“div”);</td><td align="left">获取同一类标签的所有元素</td></tr><tr><td>并集选择器</td><td>$(“div,p,li”);</td><td align="left">使用逗号分隔，只要符合条件之一就可。</td></tr><tr><td>交集选择器</td><td>$(“div.redClass”);</td><td align="left">获取class为redClass的div元素</td></tr></tbody></table><blockquote><p>总结：跟css的选择器用法一模一样。</p></blockquote><h3 id="层级选择器"><a href="#层级选择器" class="headerlink" title="层级选择器"></a>层级选择器</h3><table><thead><tr><th>名称</th><th>用法</th><th align="left">描述</th></tr></thead><tbody><tr><td>子代选择器</td><td>$(“ul&gt;li”);</td><td align="left">使用&gt;号，获取儿子层级的元素，注意，并不会获取孙子层级的元素</td></tr><tr><td>后代选择器</td><td>$(“ul li”);</td><td align="left">使用空格，代表后代选择器，获取ul下的所有li元素，包括孙子等</td></tr></tbody></table><blockquote><p>总结：跟css的选择器用法一模一样。</p></blockquote><h3 id="过滤选择器"><a href="#过滤选择器" class="headerlink" title="过滤选择器"></a>过滤选择器</h3><table><thead><tr><th>名称</th><th>用法</th><th align="left">描述</th></tr></thead><tbody><tr><td>:eq（index）</td><td>$(“li:eq(2)”).css(“color”, ”red”);</td><td align="left">获取到的li元素中，选择索引号为2的元素，索引号index从0开始。</td></tr><tr><td>:odd</td><td>$(“li:odd”).css(“color”, ”red”);</td><td align="left">获取到的li元素中，选择索引号为奇数的元素</td></tr><tr><td>:even</td><td>$(“li:even”).css(“color”, ”red”);</td><td align="left">获取到的li元素中，选择索引号为偶数的元素</td></tr></tbody></table><blockquote><p>总结：这类选择器都带冒号</p></blockquote><h3 id="筛选选择器-方法"><a href="#筛选选择器-方法" class="headerlink" title="筛选选择器(方法)"></a>筛选选择器(方法)</h3><table><thead><tr><th>名称</th><th>用法</th><th>描述</th></tr></thead><tbody><tr><td>children(selector)</td><td>$(“ul”).children(“li”)</td><td>相当于$(“ul&gt;li”)，子类选择器</td></tr><tr><td>find(selector)</td><td>$(“ul”).find(“li”);</td><td>相当于$(“ul li”),后代选择器</td></tr><tr><td>siblings(selector)</td><td>$(“#first”).siblings(“li”);</td><td>查找兄弟节点，不包括自己本身。</td></tr><tr><td>parent()</td><td>$(“#first”).parent();</td><td>查找父亲</td></tr><tr><td>eq(index)</td><td>$(“li”).eq(2);</td><td>相当于$(“li:eq(2)”),index从0开始</td></tr><tr><td>next()</td><td>$(“li”).next()</td><td>找下一个兄弟</td></tr><tr><td>prev()</td><td>$(“li”).prev()</td><td>找上一次兄弟</td></tr></tbody></table><blockquote><p>总结：筛选选择器的功能与过滤选择器有点类似，但是用法不一样，筛选选择器主要是方法。</p></blockquote><p>【案例：下拉菜单】<br>【案例：突出展示】<br>【案例：手风琴】<br>【案例：淘宝精品】</p><h2 id="元素设置"><a href="#元素设置" class="headerlink" title="元素设置"></a>元素设置</h2><h3 id="样式设置"><a href="#样式设置" class="headerlink" title="样式设置"></a>样式设置</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*1.设置一个样式*/</span></span><br><span class="line"><span class="comment">//两个参数  设置的样式属性,具体样式</span></span><br><span class="line">$(<span class="string">'li'</span>).css(<span class="string">'color'</span>,<span class="string">'red'</span>);</span><br><span class="line"><span class="comment">//传入对象（设置的样式属性:具体样式）</span></span><br><span class="line">$(<span class="string">'li'</span>).css(&#123;<span class="string">'color'</span>:<span class="string">'red'</span>&#125;);</span><br><span class="line"><span class="comment">/*2.设置多个样式*/</span></span><br><span class="line">$(<span class="string">'li'</span>).css(&#123;</span><br><span class="line">    <span class="string">'color'</span>:<span class="string">'green'</span>,</span><br><span class="line">    <span class="string">'font-size'</span>:<span class="string">'20px'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="类名设置"><a href="#类名设置" class="headerlink" title="类名设置"></a>类名设置</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*1.添加一个类*/</span></span><br><span class="line">$(<span class="string">'li'</span>).addClass(<span class="string">'now'</span>);</span><br><span class="line"><span class="comment">/*2.删除一个类*/</span></span><br><span class="line">$(<span class="string">'li'</span>).removeClass(<span class="string">'now'</span>);</span><br><span class="line"><span class="comment">/*3.切换一个类  有就删除没有就添加*/</span></span><br><span class="line">$(<span class="string">'li'</span>).toggleClass(<span class="string">'now'</span>);</span><br><span class="line"><span class="comment">/*4.匹配一个类  判断是否包含某个类  如果包含返回true否知返回false*/</span></span><br><span class="line">$(<span class="string">'li'</span>).hasClass(<span class="string">'now'</span>);</span><br></pre></td></tr></table></figure><p>对应案例：<code>案例-《tab切换》</code></p><h3 id="属性设置"><a href="#属性设置" class="headerlink" title="属性设置"></a>属性设置</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*1.获取属性*/</span></span><br><span class="line">$(<span class="string">'li'</span>).attr(<span class="string">'name'</span>);</span><br><span class="line"><span class="comment">/*2.设置属性*/</span></span><br><span class="line">$(<span class="string">'li'</span>).attr(<span class="string">'name'</span>,<span class="string">'tom'</span>);</span><br><span class="line"><span class="comment">/*3.设置多个属性*/</span></span><br><span class="line">$(<span class="string">'li'</span>).attr(&#123;</span><br><span class="line">    <span class="string">'name'</span>:<span class="string">'tom'</span>,</span><br><span class="line">    <span class="string">'age'</span>:<span class="string">'18'</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/*4.删除属性*/</span></span><br><span class="line">$(<span class="string">'li'</span>).removeAttr(<span class="string">'name'</span>);</span><br></pre></td></tr></table></figure><p>对应案例：<code>案例-《美女相册》</code></p><h3 id="prop方法"><a href="#prop方法" class="headerlink" title="prop方法"></a>prop方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*对于布尔类型的属性，不要attr方法，应该用prop方法 prop用法跟attr方法一样。*/</span></span><br><span class="line">$(<span class="string">"#checkbox"</span>).prop(<span class="string">"checked"</span>);</span><br><span class="line">$(<span class="string">"#checkbox"</span>).prop(<span class="string">"checked"</span>, <span class="literal">true</span>);</span><br><span class="line">$(<span class="string">"#checkbox"</span>).prop(<span class="string">"checked"</span>, <span class="literal">false</span>);</span><br><span class="line">$(<span class="string">"#checkbox"</span>).removeProp(<span class="string">"checked"</span>);</span><br></pre></td></tr></table></figure><p>对应案例：<code>案例-《表格全选》</code></p><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><h3 id="基本动画"><a href="#基本动画" class="headerlink" title="基本动画"></a>基本动画</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*注意：动画的本质是改变容器的大小和透明度*/</span></span><br><span class="line"><span class="comment">/*注意：如果不传参数是看不到动画*/</span></span><br><span class="line"><span class="comment">/*注意：可传入特殊的字符  fast normal slow*/</span></span><br><span class="line"><span class="comment">/*注意：可传入数字 单位毫秒*/</span></span><br><span class="line"><span class="comment">/*1.展示动画*/</span></span><br><span class="line">$(<span class="string">'li'</span>).show();</span><br><span class="line"><span class="comment">/*2.隐藏动画*/</span></span><br><span class="line">$(<span class="string">'li'</span>).hide();</span><br><span class="line"><span class="comment">/*3.切换展示和隐藏*/</span></span><br><span class="line">$(<span class="string">'li'</span>).toggle();</span><br></pre></td></tr></table></figure><h3 id="滑入滑出"><a href="#滑入滑出" class="headerlink" title="滑入滑出"></a>滑入滑出</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*注意：动画的本质是改变容器的高度*/</span></span><br><span class="line"><span class="comment">/*1.滑入动画*/</span></span><br><span class="line">$(<span class="string">'li'</span>).slideDown();</span><br><span class="line"><span class="comment">/*2.滑出动画*/</span></span><br><span class="line">$(<span class="string">'li'</span>).slideUp();</span><br><span class="line"><span class="comment">/*3.切换滑入滑出*/</span></span><br><span class="line">$(<span class="string">'li'</span>).slideToggle();</span><br></pre></td></tr></table></figure><p>对应案例：<code>案例-《下拉菜单》</code></p><h3 id="淡入淡出"><a href="#淡入淡出" class="headerlink" title="淡入淡出"></a>淡入淡出</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*注意：动画的本质是改变容器的透明度*/</span></span><br><span class="line"><span class="comment">/*1.淡入动画*/</span></span><br><span class="line">$(<span class="string">'li'</span>).fadeIn();</span><br><span class="line"><span class="comment">/*2.淡出动画*/</span></span><br><span class="line">$(<span class="string">'li'</span>).fadeOut();</span><br><span class="line"><span class="comment">/*3.切换淡入淡出*/</span></span><br><span class="line">$(<span class="string">'li'</span>).fadeToggle();</span><br><span class="line">$(<span class="string">'li'</span>).fadeTo(<span class="string">'speed'</span>,<span class="string">'opacity'</span>);</span><br></pre></td></tr></table></figure><p>对应案例：<code>案例-《轮播图》</code></p><h3 id="自定义动画"><a href="#自定义动画" class="headerlink" title="自定义动画"></a>自定义动画</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 自定义动画</span></span><br><span class="line"><span class="comment">* 参数1：需要做动画的属性</span></span><br><span class="line"><span class="comment">* 参数2：需要执行动画的总时长</span></span><br><span class="line"><span class="comment">* 参数3：执行动画的时候的速度</span></span><br><span class="line"><span class="comment">* 参数4：执行动画完成之后的回调函数</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">$(<span class="string">'#box1'</span>).animate(&#123;<span class="attr">left</span>:<span class="number">800</span>&#125;,<span class="number">5000</span>);</span><br><span class="line">$(<span class="string">'#box2'</span>).animate(&#123;<span class="attr">left</span>:<span class="number">800</span>&#125;,<span class="number">5000</span>,<span class="string">'linear'</span>);</span><br><span class="line">$(<span class="string">'#box3'</span>).animate(&#123;<span class="attr">left</span>:<span class="number">800</span>&#125;,<span class="number">5000</span>,<span class="string">'swing'</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'动画执行完成'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>对应案例：<code>案例-《手风琴菜单》</code></p><h3 id="动画队列"><a href="#动画队列" class="headerlink" title="动画队列"></a>动画队列</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">jQuery中有个动画队列的机制。</span></span><br><span class="line"><span class="comment">当我们对一个对象添加多次动画效果时后添加的动作就会被放入这个动画队列中，  </span></span><br><span class="line"><span class="comment">等前面的动画完成后再开始执行。</span></span><br><span class="line"><span class="comment">可是用户的操作往往都比动画快，  </span></span><br><span class="line"><span class="comment">如果用户对一个对象频繁操作时不处理动画队列就会造成队列堆积，</span></span><br><span class="line"><span class="comment">影响到效果。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="stop使用"><a href="#stop使用" class="headerlink" title="stop使用"></a>stop使用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*1.停止当前动画  如果动画队列当中还有动画立即执行*/</span></span><br><span class="line"><span class="comment">//$('div').stop();</span></span><br><span class="line"><span class="comment">/*2.和stop()效果一致  说明这是默认设置*/</span></span><br><span class="line"><span class="comment">//$('div').stop(false,false);</span></span><br><span class="line"><span class="comment">/*3.停止当前动画  清除动画队列*/</span></span><br><span class="line"><span class="comment">//$('div').stop(true,false);</span></span><br><span class="line"><span class="comment">/*4.停止当前动画并且到结束位置  清除了动画队列*/</span></span><br><span class="line"><span class="comment">//$('div').stop(true,true);</span></span><br><span class="line"><span class="comment">/*5.停止当前动画并且到结束位置  如果动画队列当中还有动画立即执行*/</span></span><br><span class="line">$(<span class="string">'div'</span>).stop(<span class="literal">false</span>,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>对应案例：<code>案例-《音乐导航》</code><br>对应案例：<code>案例-《工具栏》</code></p><h2 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h2><h3 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*创建节点*/</span></span><br><span class="line"><span class="keyword">var</span> $a = $(<span class="string">'&lt;a href="http://www.baidu.com" target="_blank"&gt;百度1&lt;/a&gt;'</span>);</span><br></pre></td></tr></table></figure><h3 id="克隆节点"><a href="#克隆节点" class="headerlink" title="克隆节点"></a>克隆节点</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*如果想克隆事件  false  true克隆事件*/</span></span><br><span class="line"><span class="keyword">var</span> $cloneP = $(<span class="string">'p'</span>).clone(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h3 id="添加-amp-移动节点"><a href="#添加-amp-移动节点" class="headerlink" title="添加&amp;移动节点"></a>添加&amp;移动节点</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*追加自身的最后面  传对象和html格式代码*/</span></span><br><span class="line">$(<span class="string">'#box'</span>).append(<span class="string">'&lt;a href="http://www.baidu.com" target="_blank"&gt;&lt;b&gt;百度3&lt;/b&gt;&lt;/a&gt;'</span>);</span><br><span class="line">$(<span class="string">'#box'</span>).append($(<span class="string">'a'</span>));</span><br><span class="line"><span class="comment">/*追加到目标元素最后面  传目标元素的选择器或者对象*/</span></span><br><span class="line">$(<span class="string">'&lt;a href="http://www.baidu.com" target="_blank"&gt;&lt;b&gt;百度3&lt;/b&gt;&lt;/a&gt;'</span>).appendTo($(<span class="string">'#box'</span>));</span><br><span class="line">$(<span class="string">'a'</span>).appendTo(<span class="string">'#box'</span>);</span><br><span class="line"></span><br><span class="line">prepend();</span><br><span class="line">prependTo();</span><br><span class="line">after();</span><br><span class="line">before();</span><br></pre></td></tr></table></figure><h3 id="删除节点-amp-清空节点"><a href="#删除节点-amp-清空节点" class="headerlink" title="删除节点&amp;清空节点"></a>删除节点&amp;清空节点</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*1.清空box里面的元素*/</span></span><br><span class="line"><span class="comment">/* 清理门户 */</span></span><br><span class="line">$(<span class="string">'#box'</span>).empty();</span><br><span class="line"><span class="comment">/*2.删除某个元素*/</span></span><br><span class="line"><span class="comment">/* 自杀 */</span></span><br><span class="line">$(<span class="string">'#box'</span>).remove();</span><br></pre></td></tr></table></figure><p>【案例-《弹幕》】</p><h2 id="jQuery特殊属性操作"><a href="#jQuery特殊属性操作" class="headerlink" title="jQuery特殊属性操作"></a>jQuery特殊属性操作</h2><h3 id="val方法"><a href="#val方法" class="headerlink" title="val方法"></a>val方法</h3><blockquote><p>val方法用于设置和获取表单元素的值，例如input、textarea的值</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置值</span></span><br><span class="line">$(<span class="string">"#name"</span>).val(<span class="string">'张三'</span>);</span><br><span class="line"><span class="comment">//获取值</span></span><br><span class="line">$(<span class="string">"#name"</span>).val();</span><br></pre></td></tr></table></figure><h3 id="html方法与text方法"><a href="#html方法与text方法" class="headerlink" title="html方法与text方法"></a>html方法与text方法</h3><blockquote><p>html方法相当于innerHTML  text方法相当于innerText</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置内容</span></span><br><span class="line">$(<span class="string">'div'</span>).html(<span class="string">'&lt;span&gt;这是一段内容&lt;/span&gt;'</span>);</span><br><span class="line"><span class="comment">//获取内容</span></span><br><span class="line">$(<span class="string">'div'</span>).html()</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置内容</span></span><br><span class="line">$(<span class="string">'div'</span>).text(<span class="string">'&lt;span&gt;这是一段内容&lt;/span&gt;'</span>);</span><br><span class="line"><span class="comment">//获取内容</span></span><br><span class="line">$(<span class="string">'div'</span>).text()</span><br></pre></td></tr></table></figure><p>区别：html方法会识别html标签，text方法会那内容直接当成字符串，并不会识别html标签。</p><h3 id="width方法与height方法"><a href="#width方法与height方法" class="headerlink" title="width方法与height方法"></a>width方法与height方法</h3><blockquote><p>设置或者获取高度</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//带参数表示设置高度</span></span><br><span class="line">$(<span class="string">'img'</span>).height(<span class="number">200</span>);</span><br><span class="line"><span class="comment">//不带参数获取高度</span></span><br><span class="line">$(<span class="string">'img'</span>).height();</span><br></pre></td></tr></table></figure><p>获取网页的可视区宽高</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取可视区宽度</span></span><br><span class="line">$(<span class="built_in">window</span>).width();</span><br><span class="line"><span class="comment">//获取可视区高度</span></span><br><span class="line">$(<span class="built_in">window</span>).height();</span><br></pre></td></tr></table></figure><h3 id="scrollTop与scrollLeft"><a href="#scrollTop与scrollLeft" class="headerlink" title="scrollTop与scrollLeft"></a>scrollTop与scrollLeft</h3><blockquote><p>设置或者获取垂直滚动条的位置</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取页面被卷曲的高度</span></span><br><span class="line">$(<span class="built_in">window</span>).scrollTop();</span><br><span class="line"><span class="comment">//获取页面被卷曲的宽度</span></span><br><span class="line">$(<span class="built_in">window</span>).scrollLeft();</span><br></pre></td></tr></table></figure><h3 id="offset方法与position方法"><a href="#offset方法与position方法" class="headerlink" title="offset方法与position方法"></a>offset方法与position方法</h3><blockquote><p>offset方法获取元素距离document的位置，position方法获取的是元素距离有定位的父元素的位置。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取元素距离document的位置,返回值为对象：&#123;left:100, top:100&#125;</span></span><br><span class="line">$(selector).offset();</span><br><span class="line"><span class="comment">//获取相对于其最近的有定位的父元素的位置。</span></span><br><span class="line">$(selector).position();</span><br></pre></td></tr></table></figure><h2 id="jQuery事件机制"><a href="#jQuery事件机制" class="headerlink" title="jQuery事件机制"></a>jQuery事件机制</h2><blockquote><p>JavaScript中已经学习过了事件，但是jQuery对JavaScript事件进行了封装，增加并扩展了事件处理机制。jQuery不仅提供了更加优雅的事件处理语法，而且极大的增强了事件的处理能力。</p></blockquote><h3 id="jQuery事件发展历程-了解"><a href="#jQuery事件发展历程-了解" class="headerlink" title="jQuery事件发展历程(了解)"></a>jQuery事件发展历程(了解)</h3><p>简单事件绑定&gt;&gt;bind事件绑定&gt;&gt;delegate事件绑定&gt;&gt;on事件绑定(推荐)</p><blockquote><p>简单事件注册</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">click(handler)<span class="comment">//单击事件</span></span><br><span class="line">mouseenter(handler)<span class="comment">//鼠标进入事件</span></span><br><span class="line">mouseleave(handler)<span class="comment">//鼠标离开事件</span></span><br></pre></td></tr></table></figure><p>缺点：不能同时注册多个事件</p><blockquote><p>bind方式注册事件</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个参数：事件类型</span></span><br><span class="line"><span class="comment">//第二个参数：事件处理程序</span></span><br><span class="line">$(<span class="string">"p"</span>).bind(<span class="string">"click mouseenter"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//事件响应方法</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>缺点：不支持动态事件绑定</p><blockquote><p>delegate注册委托事件</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个参数：selector，要绑定事件的元素</span></span><br><span class="line"><span class="comment">// 第二个参数：事件类型</span></span><br><span class="line"><span class="comment">// 第三个参数：事件处理函数</span></span><br><span class="line">$(<span class="string">".parentBox"</span>).delegate(<span class="string">"p"</span>, <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//为 .parentBox下面的所有的p标签绑定事件</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>缺点：只能注册委托事件，因此注册时间需要记得方法太多了</p><blockquote><p>on注册事件</p></blockquote><h3 id="on注册事件-重点"><a href="#on注册事件-重点" class="headerlink" title="on注册事件(重点)"></a>on注册事件(重点)</h3><blockquote><p>jQuery1.7之后，jQuery用on统一了所有事件的处理方法。</p><p>最现代的方式，兼容zepto(移动端类似jQuery的一个库)，强烈建议使用。</p></blockquote><p>on注册简单事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示给$(selector)绑定事件，并且由自己触发，不支持动态绑定。</span></span><br><span class="line">$(selector).on( <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;);</span><br></pre></td></tr></table></figure><p>on注册委托事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示给$(selector)绑定代理事件，当必须是它的内部元素span才能触发这个事件，支持动态绑定</span></span><br><span class="line">$(selector).on( <span class="string">"click"</span>,<span class="string">'span'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;);</span><br></pre></td></tr></table></figure><p>on注册事件的语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个参数：events，绑定事件的名称可以是由空格分隔的多个事件（标准事件或者自定义事件）</span></span><br><span class="line"><span class="comment">// 第二个参数：selector, 执行事件的后代元素（可选），如果没有后代元素，那么事件将有自己执行。</span></span><br><span class="line"><span class="comment">// 第三个参数：data，传递给处理函数的数据，事件触发的时候通过event.data来使用（不常使用）</span></span><br><span class="line"><span class="comment">// 第四个参数：handler，事件处理函数</span></span><br><span class="line">$(selector).on(events,[selector],[data],handler);</span><br></pre></td></tr></table></figure><h3 id="事件解绑"><a href="#事件解绑" class="headerlink" title="事件解绑"></a>事件解绑</h3><blockquote><p>unbind方式（不用）</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(selector).unbind(); <span class="comment">//解绑所有的事件</span></span><br><span class="line">$(selector).unbind(<span class="string">"click"</span>); <span class="comment">//解绑指定的事件</span></span><br></pre></td></tr></table></figure><blockquote><p>undelegate方式（不用）</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$( selector ).undelegate(); <span class="comment">//解绑所有的delegate事件</span></span><br><span class="line">$( selector).undelegate( <span class="string">'click'</span> ); <span class="comment">//解绑所有的click事件</span></span><br></pre></td></tr></table></figure><blockquote><p>off方式（推荐）</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解绑匹配元素的所有事件</span></span><br><span class="line">$(selector).off();</span><br><span class="line"><span class="comment">// 解绑匹配元素的所有click事件</span></span><br><span class="line">$(selector).off(<span class="string">"click"</span>);</span><br></pre></td></tr></table></figure><h3 id="触发事件"><a href="#触发事件" class="headerlink" title="触发事件"></a>触发事件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(selector).click(); <span class="comment">//触发 click事件</span></span><br><span class="line">$(selector).trigger(<span class="string">"click"</span>);</span><br></pre></td></tr></table></figure><h3 id="jQuery事件对象"><a href="#jQuery事件对象" class="headerlink" title="jQuery事件对象"></a>jQuery事件对象</h3><p>jQuery事件对象其实就是js事件对象的一个封装，处理了兼容性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//screenX和screenY对应屏幕最左上角的值</span></span><br><span class="line"><span class="comment">//clientX和clientY距离页面左上角的位置（忽视滚动条）</span></span><br><span class="line"><span class="comment">//pageX和pageY距离页面最顶部的左上角的位置（会计算滚动条的距离）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//event.keyCode按下的键盘代码</span></span><br><span class="line"><span class="comment">//event.data存储绑定事件时传递的附加数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//event.stopPropagation()阻止事件冒泡行为</span></span><br><span class="line"><span class="comment">//event.preventDefault()阻止浏览器默认行为</span></span><br><span class="line"><span class="comment">//return false:既能阻止事件冒泡，又能阻止浏览器默认行为。</span></span><br></pre></td></tr></table></figure><h2 id="jQuery补充知识点"><a href="#jQuery补充知识点" class="headerlink" title="jQuery补充知识点"></a>jQuery补充知识点</h2><h3 id="链式编程"><a href="#链式编程" class="headerlink" title="链式编程"></a>链式编程</h3><blockquote><p>通常情况下，只有设置操作才能把链式编程延续下去。因为获取操作的时候，会返回获取到的相应的值，无法返回 jQuery对象。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">end(); <span class="comment">// 筛选选择器会改变jQuery对象的DOM对象，想要回复到上一次的状态，并且返回匹配元素之前的状态。</span></span><br></pre></td></tr></table></figure><p>【案例：五角星评分案例.html】</p><h3 id="each方法"><a href="#each方法" class="headerlink" title="each方法"></a>each方法</h3><blockquote><p>jQuery的隐式迭代会对所有的DOM对象设置相同的值，但是如果我们需要给每一个对象设置不同的值的时候，就需要自己进行迭代了。</p></blockquote><p>作用：遍历jQuery对象集合，为每个匹配的元素执行一个函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数一表示当前元素在所有匹配元素中的索引号</span></span><br><span class="line"><span class="comment">// 参数二表示当前元素（DOM对象）</span></span><br><span class="line">$(selector).each(<span class="function"><span class="keyword">function</span>(<span class="params">index,element</span>)</span>&#123;&#125;);</span><br></pre></td></tr></table></figure><p>【案例：不同的透明度.html】</p><h3 id="多库共存"><a href="#多库共存" class="headerlink" title="多库共存"></a>多库共存</h3><blockquote><p>jQuery使用$作为标示符，但是如果与其他框架中的$冲突时，jQuery可以释放$符的控制权.</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = $.noConflict();<span class="comment">//释放$的控制权,并且把$的能力给了c</span></span><br></pre></td></tr></table></figure><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h3><blockquote><p>插件：jquery不可能包含所有的功能，我们可以通过插件扩展jquery的功能。</p><p>jQuery有着丰富的插件，使用这些插件能给jQuery提供一些额外的功能。</p></blockquote><ol><li>jquery.color.js</li></ol><blockquote><p>animate不支持颜色的渐变，但是使用了jquery.color.js后，就可以支持颜色的渐变了。</p></blockquote><p>使用插件的步骤</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 引入jQuery文件</span></span><br><span class="line"><span class="comment">//2. 引入插件（如果有用到css的话，需要引入css）</span></span><br><span class="line"><span class="comment">//3. 使用插件</span></span><br></pre></td></tr></table></figure><ol start="2"><li>jquery.lazyload.js</li></ol><p>懒加载插件</p><h3 id="jquery-ui-js插件"><a href="#jquery-ui-js插件" class="headerlink" title="jquery.ui.js插件"></a>jquery.ui.js插件</h3><p>jQueryUI专指由jQuery官方维护的UI方向的插件。</p><p>官方API：<a href="http://api.jqueryui.com/category/all/" target="_blank" rel="noopener">http://api.jqueryui.com/category/all/</a></p><p>其他教程：<a href="http://www.runoob.com/jqueryui/jqueryui-tutorial.html" target="_blank" rel="noopener">jQueryUI教程</a></p><p>基本使用:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.引入jQueryUI的样式文件</span></span><br><span class="line"><span class="comment">//2.引入jQuery</span></span><br><span class="line"><span class="comment">//3.引入jQueryUI的js文件</span></span><br><span class="line"><span class="comment">//4.使用jQueryUI功能</span></span><br></pre></td></tr></table></figure><p>使用jquery.ui.js手风琴菜单</p><h2 id="制作jquery插件"><a href="#制作jquery插件" class="headerlink" title="制作jquery插件"></a>制作jquery插件</h2><blockquote><p>原理：jquery插件其实说白了就是给jquery对象增加一个新的方法，让jquery对象拥有某一个功能。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过给$.fn添加方法就能够扩展jquery对象</span></span><br><span class="line">$.fn. pluginName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;jquery基础整合&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="jQuery" scheme="http://yoursite.com/tags/jQuery/"/>
    
  </entry>
  
</feed>
