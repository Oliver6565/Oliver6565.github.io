{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/02/16/hello-world/"},{"title":"MGQ时尚风云中","text":"《明星大侦探第五季》第七案《MGQ时尚风云中》分析今天这一期的案件是发生在MGQ时尚杂志社里。杂志社的同事们约好在晚上十点给何社长办生日会，但是却在10点10分的时候发现杂志社的甄主编死在了楼梯间。 本期侦探：何社长 涉案人员 撒时装：40岁，与甄主编是上下级的关系，入职20年,身高175CM 侯助理：22岁，与甄主编并没有什么来往，入职一年，身高178CM 蓉美妆：30岁，与甄主编是师徒关系，入职八年，身高175CM 贾美妆：22岁，与甄主编是上下级的关系，入职一年，身高178CM 魏秘书：24岁，是甄主编的助理，入职不到一年，身高178CM 死者：甄主编：42岁，入职22年。死因，被丝巾勒死，尸体放在了楼梯间的硬纸箱里，身高178CM 郝秘书：2019年12月29日，因过劳死在了公司茶水间，时年30岁。 案发时间梳理根据线索，甄主编原本计划是在晚上9点50分回到公司，但是在何的朋友圈留言，显示其在8：05的时候就已经回来了。 根据保安的证词，甄主编在晚上9：30的时候又离开了公司。 根据现有的证据显示，甄主编是在晚上9：30-10：10间遇害身亡。 在后面的证据搜索中，发现以下几个线索： 在撒和侯的办公室发现了一套与死者一模一样的衣服，还有一个灯光控制器 在整点的时候，保洁会来打扫卫生；在半点的时候保安会巡视 死者所在的楼梯间在晚上9：20-9：25的时候有油漆工人给地板刷油漆，而油漆在晚上9：35之前不会干 茶水间监控于2018年12月30日进行更换，并且每一个小时缓存一次 在茶水间的视频中可以看到，在晚上9：30的时候茶水间的门自动开了，甄主编出现在了茶水间外面，进入了楼梯间，然后灯灭了，过了15秒灯亮起，楼梯间的门紧紧关着。 据悉，从楼梯间的后门连接的是停车场，从后门回到正门需要半个小时 楼梯间的门只能由甄主编从里面开，其他人只能从杂志社内从楼梯间的外面开门 由以上证据，可以作出以下几个假设： 监控里出现的就是甄主编，甄主编是在9：30之后被害 监控视频里是凶手伪装的甄主编，甄主编在这很短的时间里遇害，凶手又在15秒的黑暗时间里离开楼梯间。 死者在9：20前就已经遇害，而凶手伪装成甄主编的样子，假装甄主编是在9：30之前遇害的假象。伪造不在场证明。 根据分析，第三点假设更加成立。但是根据第三条线索，凶手在9：30今日楼梯，鞋底必然会沾上油漆，但是在现场的鞋子上并没有发现油漆，而根据监控视频，凶手确实是进入到了楼梯间。 那么只有一种可能，凶手并没有进入楼梯间。凶手伪造了现场。在现场找到了两面可以推动的镜子，通过实验发现，凶手是通过镜面的折射，伪造了进入楼梯间的假象，实则进入的是旁边的甄主编的办公室。 凶手在9：30的时候将镜子摆放成如图的样子，然后用力推开茶水间的门，伪装成甄主编的样子进入旁边的甄主编的办公室，在15秒的黑暗时间，将镜子推走。就这样伪造了一个监控视频。 由此可以确认甄主编在9：20之前就已经死亡了。 而根据涉案人员陈述的时间点，每个人都没有不在场证明。 下面从每个人的动机分析 撒时装：家庭负担重，但是甄主编辞退了他，并表示会在何的生日会上宣布这件事。撒又因为年纪的原因被其他公司拒绝。 蓉美妆：与郝秘书曾经是恋爱关系。但是发现郝秘书赌博，并且并不是像大家以为的兢兢业业，而是在办公室进行网络赌博，所以相与郝秘书分手。郝秘书以曝光蓉的私照与谈恋爱的秘密为要挟，向蓉勒索。蓉与郝在茶水间争执，蓉失手将郝推倒，导致郝死亡。甄看到了，帮助蓉将现场伪造成郝过劳死。后来贾在一个月内得到了蓉奋斗了五年的职位，蓉又听到了贾威胁蓉的话，以为甄把自己的事情告诉了贾，所以怀恨在心。 贾美妆：他看到了甄与蓉的做的事情，于是威胁甄得到升职的机会。在最后一次威胁的时候，贾希望得到副主编的位置，但是甄主编表示，自己会在生日会的时候宣布离职，主编的位置会留给贾。但是就在26日的晚上八点四十分，贾知道了，甄已经和另一家杂志社签订了合同，并打算带走MGQ杂志社内所有的核心编辑。 魏秘书：他是名校毕业，原本在一家杂志社担任编辑，但是在甄主编的聘用下，决定来MGQ当秘书，但是干的是和编辑不相干的事情。他接到了一通以“郝秘书”的名义打来的电话，而且灯光熄灭，气氛非常诡异，而在电话里说，魏的下场就会和郝的下场一样。接下来他又收到了“郝秘书”送来的血书。因为“郝秘书”称他为“魏秘书”而不是“喂”，他觉得自己得到了尊重，所以，经常通过打字机与“郝秘书”聊天。而在任职期间，魏秘书希望可以去体检，但是甄主编却以工作为由，拒绝了他体检的理由。然后魏秘书就收到了诊断书，他患有百分之九十的心肌坏死，严重过劳，并且已经到了生命的尽头，所以他对杂志社的所有人都怀恨在心。他买了易燃的地毯，没有换甄主编让他换的地毯，买了蜡烛。只要何在10点10分吹蜡烛，就会引火。 侯助理：是郝秘书的弟弟，来公司调查哥哥的死因。在此期间，他文章被以撒的名义刊登在了撒主持编辑的版块。他又发现了魏秘书的境况，伪装成“郝秘书”与魏秘书交流，所以他用过灯光控制器。他意外收到了魏秘书的诊断书，将诊断书上的百分之十改成了百分之九十，诱导魏秘书对杂志社的人进行报复。 根据以上线索，可以排除掉蓉，因为勒死一个身高比自己高的成年女性，还要在15秒内将两面大镜子推走，对于蓉来说是吃力的。 可以排除掉侯，因为侯已经利用了魏秘书，只需要等待魏秘书行动了。 至于撒和贾，并没有明确的计划，他们其实在在茶水间里等待机会。 剩下的只有魏了。魏秘书在这个案件中非常关键的一点就是那条地毯。因为甄主编是一个非常苛刻的人，所以当她回来看到地毯不是她要求魏秘书换的那条一定会让魏秘书换掉，而魏秘书的计划就没有办法实施了。但是他没有想到甄主编会提前回来，反正他是打算杀掉所有人，所以提前杀掉甄主编也可以。而如果甄主编一直不出现，所有人一定要会等她出现，所以他伪造了甄主编出去的假象，而所有人可以放心吹蜡烛。 以上就是对于本期《明星大侦探》的分析。 本片文章转自 原创 姑且如此 不得甚解 1月2日 侵私删","link":"/2020/02/16/MGQ%E6%97%B6%E5%B0%9A%E9%A3%8E%E4%BA%91%E4%B8%AD/"},{"title":"Typora常用快捷键","text":"无序列表：输入-之后输入空格 有序列表：输入数字+“.”之后输入空格 任务列表：-[空格]空格 文字 标题：ctrl+数字 ctrl+数字 表格：ctrl+t 生成目录：[TOC]按回车 选中一整行：ctrl+l 选中单词：ctrl+d 选中相同格式的文字：ctrl+e 跳转到文章开头：ctrl+home 跳转到文章结尾：ctrl+end 搜索：ctrl+f 替换：ctrl+h 引用：输入&gt;之后输入空格 引用格式 代码块：ctrl+alt+k 1var a = 'hello' 加粗：ctrl+b 倾斜：ctrl+i 下划线：ctrl+u 删除线：alt+shift+5 插入图片：直接拖动到指定位置即可或者ctrl+shift+i 也可以右击插入图片 插入链接：ctrl+k","link":"/2020/02/16/Typora%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"title":"npm相关","text":"npm的常用操作 指令 描述 npm init -y 初始化项目 会生成package.json和package-lock.json npm install 安装 ，简写：npm i npm i express mongoose 一次性安装多个模块 npm i -S 保存依赖 npm install -g cnpm –registry=https://registry.npm.taobao.org 安装全局cnpm，使用淘宝镜像 npm -v 查看npm的版本 npm install npm -g 用npm来安装最新的npm npm root 查看项目中模块所在的目录 npm root -g 查看全局安装的模块所在目录","link":"/2020/02/18/npm%E7%9B%B8%E5%85%B3/"},{"title":"mongodb","text":"在node.js中开启mongodb mongod –dbpath 存放data\\db的路径 （F:/mongodb/data/db） node.js中连接数据库，用mongoose model里面的 var mongoose = require(‘mongoose’) // 连接数据库,只需连接一次mongoose.connect(‘mongodb://localhost/blog’) var Schema = mongoose.Schema var userSchema = new Schema({ email: { type: String, required: true },……数据集合","link":"/2020/02/18/mongodb%E7%9B%B8%E5%85%B3/"},{"title":"Interview_questions_01","text":"1.call 和 apply 的区别是什么，哪个性能更好一些？答：1.都是function原型上的方法，每一個函數作爲function函數的实例，可以调取原型上的call和apply方法；2.都是改变this指向的，唯一区别是call是一个个传参，而apply是以数组的形式传参。3.相类似方法bind，但是没有立即执行这个方法，预先处理改变this指向（异步可以用）。4.call性能要优于apply（尤其是传递给函数的参数超过三个的时候），所以开发的时候使用call多一点。 123456789fn.call(obj, 10, 20, 30); // 傳參是一個個fn.apply(obj, [10,20,30]);// 以數組的形式保存起來let arr = [10, 20, 30]; obj = {};function fn(x, y, z) {}fn.apply(obj, arr); //x=10,y=20,z=30fn.call(obj, arr); //x=[10, 20, 30] y=z=undefinedfn.call(obj, ...arr); //基于ES6的展开运算符也可以实现把数组中的每一项依次传递给函数 自己实现性能测试（只供参考）：任何的代码性能测试都是和测试的环境有关系的，例如CPU、内存、GPU等电脑当前性能。（电脑性能一般不稳定） console.time可以测试出一段程序执行的时间 1234567console.time('A');//let t1 = new Date();for(let i = 0; i&lt;1000000; i++){}//console.log(new Date() - t1);console.timeEnd('A'); 2.实现(5).add(3).minus(2), 使其结果输出为：6arr.push(); arr是Array的实例，可以调用Array.prototype上的方法，push就是Array.prototype上的一个方法。 123456789101112131415161718192021~function(){ //每一個方法執行完，都要返回Number这个类的实例，这样才可以继续调取Number类原型中的方法（链式写法） function check(n){ n = Number(n); return isNaN(n) ? 0 : n; } function add(n){ n = check(n); return this + n; } function minus(n){ n = check(n); return this - n; } Number.prototype.add = add; Number.prototype.minus = minus; /* [\"add\", \"minus\"].forEach(item =&gt; { Number.prototype[item] = eval(item); });*/}();console.log((5).add(3).minus(2)); 3.箭头函数与普通函数（function）的区别是什么？ 构造函数（function）可以使用new生成实例，那么箭头函数可以吗？ 为什么？1.箭头函数es6语法比普通函数更简洁 12345678910functuon fn (x){ return function(y){ return x + y; }}let fn = (x) =&gt;{ return (y) =&gt;{ return x + y; };}; 2.箭头函数没有自己的this，他里面this是继承函数所处的上下文中的this，使用call/apply无法改变this的指向 123456789101112let obj = { name: 'OBJ'};function fn1(){ console.log(this); //this 指向obj}fn1.call(obj);// 箭头函数let fn2 = () =&gt; { console.log(this); //this 指向window}fn2.call(obj); 4.如何把一个字符串的大小写取反，例如‘AbC’变成’aBc’12345678910111213let str = 'abcdEFG的單詞！*';/*for (let str i=0; i&lt;str.length; i++) { }*///正則str = str.replace(/[a-zA-Z]/g, (content) =&gt; { //content：每一次正则匹配的结果 //验证是否为大写字母；把字母转换为大写后看和之前是否一样，如果一样，那么之前也是大写的；在ASCII表中找到大学字母的取值范围进行判断（65-90）。 //content.charCodeAt()&gt;=65 &amp;&amp; content.charCodeAt()&lt;=90 return content.toUpperCase() === content ? content.toLowerCase() : content.toUpperCase(); });console.log(str); 5.实现一个字符串匹配算法，从字符串S中，查找是否存在字符串T，若存在 返回所在位置，不存在返回-1.123456789101112131415161718192021222324252627282930313233343536indexOf/includes //内置方法~function () { //闭包 /* 循环原始字符串中的每一项，让每一项从当前位置向后截取 T.length个字符，和T比较，如果不一样，继续循环；如果一样 返回当前索引值即可，循环结束； */ function myIndexOf(T){ //this：S let lenT = T.length, lenS = this.length， res = -1; if(lenT&gt;lenS){ return -1; } for(let i = 0; i &lt;= lenS - lenT; i++){ if(this.substr(i,lenT) === T){ res = i; break; } } return res;//从当前字符i，截取lenT个，并与T对比。 } //用正则的方式做 function myIndexOf(T){ let reg = new RegExp(T), //这里是把T字符串变成了正则 res = reg.exec(this); return res === null ? -1 :res.index; } //把myIndexOf这个方法挂载到String的原型方法上 String.prototype.myIndexOf = myIndexOf;}();let S = 'helloworld', T = 'world';console.log(S.myIndexOf(T));","link":"/2020/02/23/Interview-questions-01/"},{"title":"Interview_questions_02","text":"1.var a = ?;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//var a = ?;var a = { n: 0, //私有的属性方法 toString: function () { return ++ this.n; }}//a.toString() //此时调取的不是Object.prototype.toString了，调取的是自己私有的方法if ( a == 1 &amp;&amp; a == 2 &amp;&amp; a ==3 ) { console.log('ok')}/* == 進行比较，如果左右两边数据类型不一样，则先转换为相同的数据类型，然后再进行比较 1.{} == {} 不相等，两个对象进行比较，比较的是堆内存的地址 2.null == undefined 相等， null === undefined 不相等 3.NaN == NaN 都不成立， NaN和谁都不相等 4.[12] == '12' 成立，对象和字符串比较，是把对象toString转化为字符串后进行类型比较 5.剩余所有情况在进行比较的时候，都是转换为数字（前提数据类型不一样） 对象转数字：先toString转换为字符串，然后再转换为数字 字符串转数字：只要传一个非数字字符，结果就是NaN 布尔转数字：true -&gt; 1 false -&gt; 0 null转数字：0 undefined转数字 NaN *[12] == true =&gt; Number([12].toString()) == 1 fasle *[1] == trur =&gt; 1 == 1 true *[] == false =&gt; 0 == 0 true *[] == 1 =&gt; 0 == 1 false *'1' == 1 =&gt; 1 == 1 true *true == 2 =&gt; 1 == 2 false *///shift(); 删除数组第一项，把删除的内容返回，原有数组改变let a = [1, 2, 3];a.toString = a.shift; //添加私有的toString方法if ( a == 1 &amp;&amp; a == 2 &amp;&amp; a ==3 ) { console.log('ok')}/*es6中新增加的一些方法 String.fromCharCode() Array.from() Array.isArray()*/ 2.let obj = {}12345678910111213141516171819Array.prototype.push = function (val) { this[this.length] = val //this.length在原来的基础上加1 return this.length;}/*[12, 23].push(100)[12, 23, 100]arr=[12,23]arr[arr.length] = 100;*/let obj = { 2: 3, 3: 4, length: 2, push: Array.prototype.push}obj.push(1)obj.push(2)console.log(obj)","link":"/2020/02/26/Interview-questions-02/"},{"title":"webpack基本使用","text":"概念本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 1.项目构建工具，基于node.js开发出来的前端工具 2.webpack能够处理JS文件的相互依赖关系 2.webpack能处理JS的兼容问题，把高级的、浏览器不识别的语法转换为能识别的 (vue-cli 会自动配置webpack） 1. 在项目中安装和配置webpack 运行npm install webpack webpack-cli -D 命令，安装webpack相关的包 在项目根目录中，创建名为webpack.config.js的webpack配置文件 在webpack的配置文件中，初始化如下基本配置： 123module.exports = { mode: 'development' // mode 用来指定构建模式 } 在package.json配置文件中scripts节点下，新增dev脚本如下： 123\"scripts\": {\"dev\": \"webpack\" // script 节点下的脚本，可以通过npm run 来执行} 在终端运行 npm run dev 命令，启动webpack进行项目打包 （将index.js 打包为 main.js） 在index.html中可以引用输出文件main.js 2. 配置打包的入口与出口webpack的4.x版本中默认约定： 打包的入口文件为 src -&gt; index.js 在这里import js、css资源 打包的输出文件为 dist -&gt; main.js 如果要修改，就在webpack.config.js配置文件中添加一些节点 1234567const path = require(path)entry: path.join(__dirname, './src/index.js'),output: { path: path.join(__dirname, './dist'),//输出文件路径 filename: 'bundle.js' // 输出文件的名称} 3. 配置webpack的自动打包功能 运行npm install webpack-dev-server -D命令，安装支持项目自动打包的工具 修改package.json -&gt; scripts中的 dev 命令如下： 123\"scripts\": { \"dev\": \"webpack-dev-server\"} 将src -&gt; index.html 中，script脚本引用路径，改为“/bundle.js” 运行 npm run dev 命令，重新进行打包 （这里会自动在根目录中生成一个bundle.js，在内存中生成的，物理目录中看不到） 在浏览器中访问 8080,地址，查看自动打包效果 注意： webpack-dev-server 会启动一个实时打包的http服务器 webpack-dev-server 打包生成的输出文件，默认放到了项目根目录中，而且是虚拟的、看不见的 4. html-webpack-plugin生成的预览页面（写在前面， 运行 npm install html-webpack-plugin -D 命令，安装生成预览页面的插件 修改 webpack.config.js文件头部区域，添加如下配置信息： 1234567// 导入生成预览页面的插件，得到一个构造函数const HtmlWebpackPlugin = require('html-webpack-plugin')// 创建插件的实例对象 new出来const htmlPlugin = new HtmlWebpackPlugin({ template: './src/index.html', filename: 'index.html'}) 修改webpack.config.js文件中向外暴露的配置对象，新增如下配置节点： 1plugins:[ htmlPlugin ] // plugins數組是webpack打包期间会用到的一些插件列表 5. 配置自动打包相关的参数1234567// package.json中配置// --open 打包完成后自动打开浏览器页面// --host 配置IP地址// --port 配置端口\"scripts\" : [ \"dev\": \"webpack-dev-server --open --host 127.0.0.1 --port 8888\"], 6. loader打包非js模块loader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。 本质上，webpack loader 将所有类型的文件，转换为应用程序的依赖图（和最终的 bundle）可以直接引用的模块。 注意，loader 能够 import 导入任何类型的模块（例如 .css 文件），这是 webpack 特有的功能，其他打包程序或任务执行器的可能并不支持。我们认为这种语言扩展是有很必要的，因为这可以使开发人员创建出更准确的依赖关系图。 less-loader sass-loader url-loader 7. 打包处理css文件 运行 *npm i style-loader css-loader -D* 命令，安装处理css文件的loader 在webpack.config.js的module -&gt; rules 数组中，添加loader： 123456// 所有第三方文件模块的匹配规则module: { rules: [ { test: /\\.css$/, use: ['style-loader', 'css-loader']} ]} 其中，test 表示匹配的文件类型，use表示对应要调用的loader 注意： use 数组中指定的loader 顺序是固定的 多个loader的调用顺序是：从后往前调用 8. 打包处理less文件 运行 npm i less-loader less -D 命令 在webpack.config.js 的module -&gt; rules 数组中，添加loader: 123456// 所有第三方文件模块的匹配规则module: { rules: [ { test: /\\.less$/, use: ['style-loader', 'css-loader', 'less-loader']} ]} 9. 打包处理sass文件 运行 npm i sass-loader node-sass -D 命令 在webpack.config.js 的module -&gt; rules 数组中，添加loader: 123456// 所有第三方文件模块的匹配规则module: { rules: [ { test: /\\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader']} ]} 10. 配置postCSS 自动添加css的兼容前缀 运行 npm i postcss-loader autoprofixer -D 命令 在项目根目录中创建 postcss 的配置文件 postcss.config.js 12345const autoprofixer = require('autoprofixer')module.exports = { plugins:[autoprofixer]} 在webpack.config.js的module -&gt; rules 数组中，修改css的loader： 12345module: { rules: [ { test: /\\.css$/, use: ['style-loader', 'css-loader', 'postcss-loader']} ]} 11. 打包样式表中的图片和文字文件 运行 npm i url-loader file-loader -D 命令 在webpack.config.js 的module -&gt; rules数组中，添加loader： 12345module: { rules: [ { test: /\\.jpg|png|gif|bmp|ttf|svg|woff|woff2$/, use:'url-loader?limit=16940'} ]} 其中？之后的是loader的参数项 limit 用来指定图片的大小，单位是字节（byte），只有小于limit大小的图片，才会被转为 base64 图片 12. 打包处理js文件中的高级语法 安装babel转换器相关的包：npm i babel-loader @babel/core @babel/runtime -D 安装babel语法插件相关的包： npm i @babel/preset-env @babel/plugin-transform-runtime @babel/plugin-proposal-class-properties -D 在项目根目录中，创建babel配置文件，babel.config.js，并初始化基本配置： 1234module.exports = { presets: ['@babel/preset-env'] plugins: ['@babel/preset-env', '@babel/plugin-transform-runtime', '@babel/plugin-proposal-class-properties']} 在webpack.config.js的module -&gt; rules数组中，已添加loader规则： 1{ test: /\\.js$/, use:'babel-loader', exclude: /node_modules/} 其中，exclude为排除项，表示babel-loader不需要处理node_modules中的js文件 13. 打包vue组件.vue文件，需要安装相关的loader npm i vue-loader vue-temlate-compiler -D 在webpack.config.js配置文件中，新增loader配置项 1{ test: /\\.vue$/, use: 'vue-loader' } 总结梳理：webpack中如何使用vue：1.安装vue的包：npm i vue -S 2.由于在webpack中，推荐使用.vue这个组件模板文件定义组件，所以，需要安装 能解析这种文件的loader cnpm i vue-template-complier -D 3.在main.js中，导入vue模块 import Vue from ‘vue’ 4.定义一个.vue结尾的组件，其中，组件有三部分组成：template script style 5.使用import导入这个组件 6.创建vm的实例，var vm = new Vue（ {el: ‘#app’, render: c=&gt; c(login) }) 7.在页面中创建一个id为app的div元素，作为我们vm实例要控制的区域","link":"/2020/03/12/webpack%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"},{"title":"Nodejs相关","text":"前言：学了node的一些基础知识，理解了node的语法和建立服务器 连接数据库相关的知识。然后登录注册退出功能已完成。后续的学习把后台管理和展示内容部分做出来，然后部署上下测试。 2020.2.18 在ES6中，导入模块：import 模块名称 from ‘模块标识 import ’表示路径‘ 向外暴露成员：export default 和export 在Node中，导入模块 使用 var 名称 = require(‘模块标识符’) 向外暴露成员：module.exports 和exports来暴露成员","link":"/2020/02/18/Nodejs%E7%9B%B8%E5%85%B3/"},{"title":"Promise相关","text":"1.Promise用法1.1 异步调用 异步效果分析 定时任务 setTimeout setInterver Ajax 异步ajax请求（jqurey） 1234567891011var ret = ''$ajax{( url:'http://localhost:3000/...', success: function(data){ console.log(data) ret = data; console.log(ret) // 这里可以 })}console.log(ret) // 这里的ret是获取不到里面的东西的// 只能在回调函数中，获得值 事件函数 多次异步调用的依赖分析 多次异步调用的结果顺序不确定 异步调用结果如果存在依赖，那么我们需要多次多次嵌套，就是传说中的“十八层地域”，回调地狱。 1.2 Promise 概述Promise 是异步编程的一种解决方案，从语法上讲，Promise是一个对象，从它可以获取异步操作的消息。 可以避免多层异步调用嵌套问题（回调地狱）。 Promise对象提供了简介的API，使得控制异步操作更加容易 1.3 Promise 基本用法 实例化Promise 对象，构造函数中传递函数，该函数中用于处理异步任务 resolve和reject两个参数（都是方法，可以调用）用于处理成功和失败两种情况，并通过p.the获取处理结果 12345678910111213141516171819202122232425262728var p = new Promise(function(resolve, reject){ // 成功时调用 resolve() // 失败时调用 reject()})p.then(function(ret){ // 返回成功的结果ret},function(error){ // 返回失败的结果}) -------------------------------------------------var p = new Promise(function(resolve, reject){ setTimeout(function(){ var flag = true if(flag) { // 正常情况 resolve('hello') }else { // 异常情况 reject('出错') } }, 100) })p.then(function(data){ console.log(data)},function(error){ console.log(error)}) 1.4 基于Promise处理Ajax请求 处理原生Ajax 1.5 then参数中的函数返回值1.返回Promise实例对象 返回的该实例对象会调用下一个then 2.返回普通值 返回的普通值会直接传递给下一个then，通过then参数中函数的参数接收该值 1.6 Promise常用的API1.实例方法（在原型中的方法，需要用实例去调用） p.then() 得到异步任务的正确结果 p.catch() 获取异常信息 p.finally() 成功与否都会执行（尚且不是正式标准） 123456789101112131415161718function foo(){ return new Promise(function(resolve, reject){ setTimeout(function(){ // resolve(123); reject(error) },100); })}foo() .then(function(data){ console.log(data) }) .catch(function(data)){ console.log(data) }) .finally(function(){ console.log('finished') }); 2.对象方法 Promise.all() 并发处理多个异步任务，所有任务都执行完成才能得到结果 Promise.race() 并发处理多个异步任务，只要有一个任务完成就能得到结果 2 接口调用 -fetch用法2.1 基本特性 更加简单的数据获取方式，功能更强大，更灵活，可以看做是xhr的升级版 基于Promise实现 2.2 语法结构fetch(url).then(fn2) ​ .then(fn3) ​ … ​ .catch(fn) 12345fetch('http://localhost:3000/fdata').then(function(data){ return data.text(); //text()方法属于fetchAPI的一部分，它返回一个Promise实例对象，用于获取后台返回的数据}).then(function(data){ console.log(data)}) 2.3 fetch请求参数 常用配置选项 method(String): HTTP请求方法，默认为GET POST PUT DELETE body(String): HTTP请求参数 header(Object): HTTP的请求头，默认为{} 3. axios 用法3.1 axios 的基本特性axios（官网：https://github.com/axios/axios）是一个基于Promise用于浏览器和node.js的HTTP客户端 它有以下特性： 支持浏览器和node.js 支持promise 能拦截请求和响应 自动转换JSON数据 3.2 axios 的基本用法12345axios.get('/adata') .then(ret =&gt; { //data属性名称是固定的，用于获取后台响应的数据 console.log(ret.data)}) 3.3 axios 常用API get： 添加数据 post： 删除数据 put： 修改数据 delete： 删除数据 GET 传递参数 通过 URL 传递参数 通过params 选项传递参数 123456789axios.get('/adata?id=123') .then(ret =&gt; { console.log(ret.data) })// 后台接口app.get('/axios',(req,res) =&gt; { res.send('axios get 传递参数' + req.query.id)}) 123456789axios.get('/adata/123') .then(ret =&gt; { console.log(ret.data) })// 后台接口app.get('/axios/:id',(req,res) =&gt; { res.send('axios get (Restful) 传递参数' + req.params.id)}) 12345678axios.get('/adata',{ params:{ id:123 }}).then(ret =&gt; { console.log(ret.data)})","link":"/2020/03/14/Promise%E7%9B%B8%E5%85%B3/"},{"title":"webapp搭建vue","text":"webapp 外卖系统（移动端）！（前言：学习Vue项目搭建流程，记录心得（部分筆記為課件）。学习视频 -&gt; https://www.bilibili.com/video/av49099807 1. 使用 vue-cli(脚手架)搭建项目 Vue-cli 是 vue 官方提供的用于搭建基于 vue+webpack+es6 项目的脚手架工具 在线文档:https://github.com/vuejs/vue-cli 操作: npm install -g vue-cli vue init webpack gshop cd gshop npm install npm run dev 访问: localhost:8080 2. 项目结构分析gshop |– build : webpack 相关的配置文件夹(基本不需要修改) |– config: webpack 相关的配置文件夹(基本不需要修改) |– index.js: 指定的后台服务的端口号和静态资源文件夹 |– node_modules |– src : 源码文件夹 |– main.js: 应用入口 js |– static: 静态资源文件夹 |– .babelrc: babel 的配置文件 |– .editorconfig: 通过编辑器的编码/格式进行一定的配置 |– .eslintignore: eslint 检查忽略的配置 |– .eslintrc.js: eslint 检查的配置 |– .gitignore: git 版本管制忽略的配置 |– index.html: 主页面文件 |– package.json: 应用包配置文件 |– README.md: 应用描述说明的 readme 文件 3. 编码测试与打包发布项目 编码测试 npm run dev 访问:http://localhost:8080 编码, 自动编译打包(HMR), 查看效果 打包发布 npm run build npm install -g serve serve dist 访问:http://localhost:5000 4. 項目源碼目錄設計 src api 与后台交互模块文件夹 common（asstes） 通用资源文件夹，如fonts/img/stylus (stylus: css预编译器，Sass/Less npminstallstylusstylus-loader–save-dev） components 非路由组件文件夹 filters 自定义过滤器模块文件夹 mock 模拟数据接口文件夹 pages 路由组件文件夹 router 路由器文件夹-&gt;index.js/router.js 暴露router给入口文件main.js store vuex相关模块文件夹 App.vue 应用组件 main.js 入口JS 记录props的详解：组件示例的作用域是孤立的，意味着不能（也不应该）在子组件的模板内直接引用父组件的数据。父组件的数据要通过prop才能下发到子组件中。 props是子组件访问父组件数据的唯一接口 一个组件可以直接在模板里面渲染data里面的数据（双大括号）。 子组件不能直接在模板里面渲染父元素的数据。 如果子组件想要引用父元素的数据，那么就在prop里面声明一个变量（比如a），这个变量就可以引用父元素的数据。然后在模板里渲染这个变量（前面的a），这时候渲染出来的就是父元素里面的数据。 slot的详解：给元素指定一个name后可以分发多个内容 一个简单的小例子： 1.父组件传递了todos数组给子组件 2.子组件通过props接受了数组数据，这里应该没有任何问题 3.子组件拿到数组后v-for渲染列表，并且通过 的方式，把数组内的每一个todo对象，传递给父组件 4.父组件通过slot-scope=”slotProps”的方式，接受todo对象，之后就可以通过slotProps.todo.xxx的方式来使用了 所以数据的流动经历了 父组件传递todos数组给子组件 子组件遍历todos数组，把里面的todo对象传递给父组件 Swiper左右滑动插件 npm i swiper -D 先下载 ——可以去官网查看html结构，这样写会有好的css样式 import Swiper from ‘swiper’ 阿里巴巴iconfontinconfont矢量标记图标。登录账号，选择图标添加购物车，生成网上链接，可以直接使用。使用方式 去官网看。 Svg图片可以做验证码 $router.back()&lt;a href=”javascript:” class=”go_back” @click=”$router.back()”&gt; 返回到之前的路由 $route 代表当前路由 postman创建集合，以便归类请求 封装ajax请求跨域问题的解决总结总结01 项目开发准备 项目描述 技术选型 API接口（接口文档 -&gt; postman 测接口） 从此项目学到什么 开启项目开发 使用脚手架创建项目 安装依赖 开发环境运行 生产环境打包与发布 搭建项目整体界面结构 stylus的理解和使用（结构化，变量，函数/minxin（混合 vue-router的理解和使用 router-view/router-link/keep-alive $router: 路由对象，包含一些操作路由的功能函数，来实现编程式导航（跳转路由） $route: 当前路由对象，一些当前路由信息数据的容器，path/meta/query/params 项目路由拆分 一般组件和导航路由组件 抽取组件 登录路由组件 后台项目 前后台交互 ajax请求库：axios ajax请求函数封装：axios + promise 接口请求函数封装，每个后台接口 02","link":"/2020/03/13/webapp%E6%90%AD%E5%BB%BAvue/"}],"tags":[{"name":"案件","slug":"案件","link":"/tags/%E6%A1%88%E4%BB%B6/"},{"name":"Typora技巧","slug":"Typora技巧","link":"/tags/Typora%E6%8A%80%E5%B7%A7/"},{"name":"npm","slug":"npm","link":"/tags/npm/"},{"name":"mongodb","slug":"mongodb","link":"/tags/mongodb/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"webpack","slug":"webpack","link":"/tags/webpack/"},{"name":"node","slug":"node","link":"/tags/node/"},{"name":"promise axios 异步","slug":"promise-axios-异步","link":"/tags/promise-axios-%E5%BC%82%E6%AD%A5/"},{"name":"vue","slug":"vue","link":"/tags/vue/"}],"categories":[]}