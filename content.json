{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/02/16/hello-world/"},{"title":"MGQ时尚风云中","text":"《明星大侦探第五季》第七案《MGQ时尚风云中》分析今天这一期的案件是发生在MGQ时尚杂志社里。杂志社的同事们约好在晚上十点给何社长办生日会，但是却在10点10分的时候发现杂志社的甄主编死在了楼梯间。 本期侦探：何社长 涉案人员 撒时装：40岁，与甄主编是上下级的关系，入职20年,身高175CM 侯助理：22岁，与甄主编并没有什么来往，入职一年，身高178CM 蓉美妆：30岁，与甄主编是师徒关系，入职八年，身高175CM 贾美妆：22岁，与甄主编是上下级的关系，入职一年，身高178CM 魏秘书：24岁，是甄主编的助理，入职不到一年，身高178CM 死者：甄主编：42岁，入职22年。死因，被丝巾勒死，尸体放在了楼梯间的硬纸箱里，身高178CM 郝秘书：2019年12月29日，因过劳死在了公司茶水间，时年30岁。 案发时间梳理根据线索，甄主编原本计划是在晚上9点50分回到公司，但是在何的朋友圈留言，显示其在8：05的时候就已经回来了。 根据保安的证词，甄主编在晚上9：30的时候又离开了公司。 根据现有的证据显示，甄主编是在晚上9：30-10：10间遇害身亡。 在后面的证据搜索中，发现以下几个线索： 在撒和侯的办公室发现了一套与死者一模一样的衣服，还有一个灯光控制器 在整点的时候，保洁会来打扫卫生；在半点的时候保安会巡视 死者所在的楼梯间在晚上9：20-9：25的时候有油漆工人给地板刷油漆，而油漆在晚上9：35之前不会干 茶水间监控于2018年12月30日进行更换，并且每一个小时缓存一次 在茶水间的视频中可以看到，在晚上9：30的时候茶水间的门自动开了，甄主编出现在了茶水间外面，进入了楼梯间，然后灯灭了，过了15秒灯亮起，楼梯间的门紧紧关着。 据悉，从楼梯间的后门连接的是停车场，从后门回到正门需要半个小时 楼梯间的门只能由甄主编从里面开，其他人只能从杂志社内从楼梯间的外面开门 由以上证据，可以作出以下几个假设： 监控里出现的就是甄主编，甄主编是在9：30之后被害 监控视频里是凶手伪装的甄主编，甄主编在这很短的时间里遇害，凶手又在15秒的黑暗时间里离开楼梯间。 死者在9：20前就已经遇害，而凶手伪装成甄主编的样子，假装甄主编是在9：30之前遇害的假象。伪造不在场证明。 根据分析，第三点假设更加成立。但是根据第三条线索，凶手在9：30今日楼梯，鞋底必然会沾上油漆，但是在现场的鞋子上并没有发现油漆，而根据监控视频，凶手确实是进入到了楼梯间。 那么只有一种可能，凶手并没有进入楼梯间。凶手伪造了现场。在现场找到了两面可以推动的镜子，通过实验发现，凶手是通过镜面的折射，伪造了进入楼梯间的假象，实则进入的是旁边的甄主编的办公室。 凶手在9：30的时候将镜子摆放成如图的样子，然后用力推开茶水间的门，伪装成甄主编的样子进入旁边的甄主编的办公室，在15秒的黑暗时间，将镜子推走。就这样伪造了一个监控视频。 由此可以确认甄主编在9：20之前就已经死亡了。 而根据涉案人员陈述的时间点，每个人都没有不在场证明。 下面从每个人的动机分析 撒时装：家庭负担重，但是甄主编辞退了他，并表示会在何的生日会上宣布这件事。撒又因为年纪的原因被其他公司拒绝。 蓉美妆：与郝秘书曾经是恋爱关系。但是发现郝秘书赌博，并且并不是像大家以为的兢兢业业，而是在办公室进行网络赌博，所以相与郝秘书分手。郝秘书以曝光蓉的私照与谈恋爱的秘密为要挟，向蓉勒索。蓉与郝在茶水间争执，蓉失手将郝推倒，导致郝死亡。甄看到了，帮助蓉将现场伪造成郝过劳死。后来贾在一个月内得到了蓉奋斗了五年的职位，蓉又听到了贾威胁蓉的话，以为甄把自己的事情告诉了贾，所以怀恨在心。 贾美妆：他看到了甄与蓉的做的事情，于是威胁甄得到升职的机会。在最后一次威胁的时候，贾希望得到副主编的位置，但是甄主编表示，自己会在生日会的时候宣布离职，主编的位置会留给贾。但是就在26日的晚上八点四十分，贾知道了，甄已经和另一家杂志社签订了合同，并打算带走MGQ杂志社内所有的核心编辑。 魏秘书：他是名校毕业，原本在一家杂志社担任编辑，但是在甄主编的聘用下，决定来MGQ当秘书，但是干的是和编辑不相干的事情。他接到了一通以“郝秘书”的名义打来的电话，而且灯光熄灭，气氛非常诡异，而在电话里说，魏的下场就会和郝的下场一样。接下来他又收到了“郝秘书”送来的血书。因为“郝秘书”称他为“魏秘书”而不是“喂”，他觉得自己得到了尊重，所以，经常通过打字机与“郝秘书”聊天。而在任职期间，魏秘书希望可以去体检，但是甄主编却以工作为由，拒绝了他体检的理由。然后魏秘书就收到了诊断书，他患有百分之九十的心肌坏死，严重过劳，并且已经到了生命的尽头，所以他对杂志社的所有人都怀恨在心。他买了易燃的地毯，没有换甄主编让他换的地毯，买了蜡烛。只要何在10点10分吹蜡烛，就会引火。 侯助理：是郝秘书的弟弟，来公司调查哥哥的死因。在此期间，他文章被以撒的名义刊登在了撒主持编辑的版块。他又发现了魏秘书的境况，伪装成“郝秘书”与魏秘书交流，所以他用过灯光控制器。他意外收到了魏秘书的诊断书，将诊断书上的百分之十改成了百分之九十，诱导魏秘书对杂志社的人进行报复。 根据以上线索，可以排除掉蓉，因为勒死一个身高比自己高的成年女性，还要在15秒内将两面大镜子推走，对于蓉来说是吃力的。 可以排除掉侯，因为侯已经利用了魏秘书，只需要等待魏秘书行动了。 至于撒和贾，并没有明确的计划，他们其实在在茶水间里等待机会。 剩下的只有魏了。魏秘书在这个案件中非常关键的一点就是那条地毯。因为甄主编是一个非常苛刻的人，所以当她回来看到地毯不是她要求魏秘书换的那条一定会让魏秘书换掉，而魏秘书的计划就没有办法实施了。但是他没有想到甄主编会提前回来，反正他是打算杀掉所有人，所以提前杀掉甄主编也可以。而如果甄主编一直不出现，所有人一定要会等她出现，所以他伪造了甄主编出去的假象，而所有人可以放心吹蜡烛。 以上就是对于本期《明星大侦探》的分析。 本片文章转自 原创 姑且如此 不得甚解 1月2日 侵私删","link":"/2020/02/16/MGQ%E6%97%B6%E5%B0%9A%E9%A3%8E%E4%BA%91%E4%B8%AD/"},{"title":"Typora常用快捷键","text":"无序列表：输入-之后输入空格 有序列表：输入数字+“.”之后输入空格 任务列表：-[空格]空格 文字 标题：ctrl+数字 ctrl+数字 表格：ctrl+t 生成目录：[TOC]按回车 选中一整行：ctrl+l 选中单词：ctrl+d 选中相同格式的文字：ctrl+e 跳转到文章开头：ctrl+home 跳转到文章结尾：ctrl+end 搜索：ctrl+f 替换：ctrl+h 引用：输入&gt;之后输入空格 引用格式 代码块：ctrl+alt+k 1var a = 'hello' 加粗：ctrl+b 倾斜：ctrl+i 下划线：ctrl+u 删除线：alt+shift+5 插入图片：直接拖动到指定位置即可或者ctrl+shift+i 也可以右击插入图片 插入链接：ctrl+k","link":"/2020/02/16/Typora%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"title":"npm相关","text":"npm的常用操作 指令 描述 npm init -y 初始化项目 会生成package.json和package-lock.json npm install 安装 ，简写：npm i npm i express mongoose 一次性安装多个模块 npm i -S 保存依赖 npm install -g cnpm –registry=https://registry.npm.taobao.org 安装全局cnpm，使用淘宝镜像 npm -v 查看npm的版本 npm install npm -g 用npm来安装最新的npm npm root 查看项目中模块所在的目录 npm root -g 查看全局安装的模块所在目录","link":"/2020/02/18/npm%E7%9B%B8%E5%85%B3/"},{"title":"Nodejs搭建blog-记录","text":"前言：学了node的一些基础知识，理解了node的语法和建立服务器 连接数据库相关的知识。然后登录注册退出功能已完成。后续的学习把后台管理和展示内容部分做出来，然后部署上下测试。 2020.2.18","link":"/2020/02/18/Nodejs%E6%90%AD%E5%BB%BAblog-%E8%AE%B0%E5%BD%95/"},{"title":"mongodb","text":"在node.js中开启mongodb mongod –dbpath 存放data\\db的路径 （F:\\mongodb\\data\\db） node.js中连接数据库，用mongoose model里面的 var mongoose = require(‘mongoose’) // 连接数据库,只需连接一次mongoose.connect(‘mongodb://localhost/blog’) var Schema = mongoose.Schema var userSchema = new Schema({ email: { type: String, required: true },……数据集合","link":"/2020/02/18/mongodb%E7%9B%B8%E5%85%B3/"},{"title":"Interview_questions_01","text":"1.call 和 apply 的区别是什么，哪个性能更好一些？答：1.都是function原型上的方法，每一個函數作爲function函數的实例，可以调取原型上的call和apply方法；2.都是改变this指向的，唯一区别是call是一个个传参，而apply是以数组的形式传参。3.相类似方法bind，但是没有立即执行这个方法，预先处理改变this指向（异步可以用）。4.call性能要优于apply（尤其是传递给函数的参数超过三个的时候），所以开发的时候使用call多一点。 123456789fn.call(obj, 10, 20, 30); // 傳參是一個個fn.apply(obj, [10,20,30]);// 以數組的形式保存起來let arr = [10, 20, 30]; obj = {};function fn(x, y, z) {}fn.apply(obj, arr); //x=10,y=20,z=30fn.call(obj, arr); //x=[10, 20, 30] y=z=undefinedfn.call(obj, ...arr); //基于ES6的展开运算符也可以实现把数组中的每一项依次传递给函数 自己实现性能测试（只供参考）：任何的代码性能测试都是和测试的环境有关系的，例如CPU、内存、GPU等电脑当前性能。（电脑性能一般不稳定） console.time可以测试出一段程序执行的时间 1234567console.time('A');//let t1 = new Date();for(let i = 0; i&lt;1000000; i++){}//console.log(new Date() - t1);console.timeEnd('A'); 2.实现(5).add(3).minus(2), 使其结果输出为：6arr.push(); arr是Array的实例，可以调用Array.prototype上的方法，push就是Array.prototype上的一个方法。 123456789101112131415161718192021~function(){ //每一個方法執行完，都要返回Number这个类的实例，这样才可以继续调取Number类原型中的方法（链式写法） function check(n){ n = Number(n); return isNaN(n) ? 0 : n; } function add(n){ n = check(n); return this + n; } function minus(n){ n = check(n); return this - n; } Number.prototype.add = add; Number.prototype.minus = minus; /* [\"add\", \"minus\"].forEach(item =&gt; { Number.prototype[item] = eval(item); });*/}();console.log((5).add(3).minus(2)); 3.箭头函数与普通函数（function）的区别是什么？ 构造函数（function）可以使用new生成实例，那么箭头函数可以吗？ 为什么？1.箭头函数es6语法比普通函数更简洁 12345678910functuon fn (x){ return function(y){ return x + y; }}let fn = (x) =&gt;{ return (y) =&gt;{ return x + y; };}; 2.箭头函数没有自己的this，他里面this是继承函数所处的上下文中的this，使用call/apply无法改变this的指向 123456789101112let obj = { name: 'OBJ'};function fn1(){ console.log(this); //this 指向obj}fn1.call(obj);// 箭头函数let fn2 = () =&gt; { console.log(this); //this 指向window}fn2.call(obj); 4.如何把一个字符串的大小写取反，例如‘AbC’变成’aBc’12345678910111213let str = 'abcdEFG的單詞！*';/*for (let str i=0; i&lt;str.length; i++) { }*///正則str = str.replace(/[a-zA-Z]/g, (content) =&gt; { //content：每一次正则匹配的结果 //验证是否为大写字母；把字母转换为大写后看和之前是否一样，如果一样，那么之前也是大写的；在ASCII表中找到大学字母的取值范围进行判断（65-90）。 //content.charCodeAt()&gt;=65 &amp;&amp; content.charCodeAt()&lt;=90 return content.toUpperCase() === content ? content.toLowerCase() : content.toUpperCase(); });console.log(str); 5.实现一个字符串匹配算法，从字符串S中，查找是否存在字符串T，若存在 返回所在位置，不存在返回-1.123456789101112131415161718192021222324252627282930313233343536indexOf/includes //内置方法~function () { //闭包 /* 循环原始字符串中的每一项，让每一项从当前位置向后截取 T.length个字符，和T比较，如果不一样，继续循环；如果一样 返回当前索引值即可，循环结束； */ function myIndexOf(T){ //this：S let lenT = T.length, lenS = this.length， res = -1; if(lenT&gt;lenS){ return -1; } for(let i = 0; i &lt;= lenS - lenT; i++){ if(this.substr(i,lenT) === T){ res = i; break; } } return res;//从当前字符i，截取lenT个，并与T对比。 } //用正则的方式做 function myIndexOf(T){ let reg = new RegExp(T), //这里是把T字符串变成了正则 res = reg.exec(this); return res === null ? -1 :res.index; } //把myIndexOf这个方法挂载到String的原型方法上 String.prototype.myIndexOf = myIndexOf;}();let S = 'helloworld', T = 'world';console.log(S.myIndexOf(T));","link":"/2020/02/23/Interview-questions-01/"}],"tags":[{"name":"案件","slug":"案件","link":"/tags/%E6%A1%88%E4%BB%B6/"},{"name":"Typora技巧","slug":"Typora技巧","link":"/tags/Typora%E6%8A%80%E5%B7%A7/"},{"name":"npm","slug":"npm","link":"/tags/npm/"},{"name":"学习记录","slug":"学习记录","link":"/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"name":"mongodb","slug":"mongodb","link":"/tags/mongodb/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"}],"categories":[]}