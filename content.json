{"pages":[{"title":"To know me","text":"永远相信，美好的事情即将发生。 Always believe that good things are about to happen. 想做一个会magic的前端工程师 关于学历 本科：重庆师范大学 信息管理与信息系统专业； 主要学习Java、 J2EE、 python、 Django还有管理学相关的知识； 关于前端的知识：html、css、js（ES6）、nodejs和vue等相关。 关于兴趣 喜欢一些艺术、平面、UI设计 平时有空會看看TED，还有各国的生活纪录片；也会抽时间夜跑锻炼 喜欢看欧美剧，一些欧美综艺也不错，极力求推荐~~","link":"/about/index.html"},{"title":"分类","text":"","link":"/categories/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"ES6-class关键字02","text":"class关键字(继承) class-继承 语法： class 子类 extends 父类 {} 父类 Person 子类 American 子类 Chinese 继承公共实例属性12345678910111213141516171819202122// 把父类 理解成 原型对象 prototypeclass Person { constructor(name, age){ this.name = name this.age = age }}// 在class类中，使用extends 关键字，实现子类继承父类// 语法： class 子类 extends 父类class American extends Person {}const a1 = new American('Jack', 20)console.log(a1)class Chinese extends Person {}const c1 = new Chinese('张三', 22)console.log(c1) 继承公共实例方法子类通过extends 关键字继承了父类，那么子类的 constructor 构造函数中，必须先调用一下 super() super是一个函数 其实就是父类的 构造器 12345678910111213141516171819202122232425262728293031class Person { constructor(name, age){ this.name = name this.age = age } // 实例方法 sayHello(){ consolo.log('大家好') }}class American extends Person { constructor(name, age){ super(name, age) }}const a1 = new American('Jack', 20)console.log(a1)console.log(a1.sayHello)class Chinese extends Person { constructor(name, age, IDNumber){ super(name, age) this.IDNumber = IDNumber //挂载子类独有的实例属性 }}const c1 = new Chinese('张三', 22, '130020*****')console.log(c1)console.log(c1.sayHello)","link":"/2020/03/25/ES6-class%E5%85%B3%E9%94%AE%E5%AD%9702/"},{"title":"Ajax和JSON","text":"ajax and json Ajax Ajax（Asynchronous JavaScript and XML），用于创建更好更快以及交互性更强的Web应用程序的技术，与传统的Web应用相比，Ajax通过浏览器与服务器进行少量的数据交换就可以实现网页的异步更新，在不重新加载整个网页的情况下，即可对网页进行更新。 JSON JSON(JavaScriptObject Notation, JS 对象简谱) 是一种轻量级的数据交换格式，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。JSON（常用于数据交互）和XML（常用于文件配置）可读性不相上下。 在JS语言中，一切都是对象，因此任何JS支持的类型，都可以通过JSON来表示，例如字符串、数字、对象数组等。 对象表示为键值对 数据由逗号分隔 花括号保存对象 方括号保存数组 JSON是JS对象的字符串表示法，它使用文本表示一个JS对象的信息，本质是一个字符串 JSON和JS对象互转从JSON字符串转换为JS对象，使用JSON.parse()方法： 1var obj = JSON.parse('{\"a\":\"hello\",\"b\":\"world\"}') 从JS对象转换为JSON字符串，使用JSON.stringify()方法： 1var json = JSON.stringify({\"a\":\"hello\",\"b\":\"world\"}) jQuery.parseJSON()函数用于将格式完好的JSON字符串转为与之对应的JavaScript对象。 所谓”格式完好”，就是要求指定的字符串必须符合严格的JSON格式，例如：属性名称必须加双引号、字符串值也必须用双引号。 如果传入一个格式不”完好”的JSON字符串将抛出一个JS异常， 例如：以下字符串均符合JSON格式，但它们不是格式完好的JSON字符串(因此会抛出异常)： // 以下均是字符串值，省略了两侧的引号，以便于展现内容 {id: 1} // id是属性名称，必须加双引号{‘id’: 1} // id是属性名称，必须用双引号(不能用单引号){“name”: ‘CodePlayer’} // name属性的值是字符串，必须用双引号(不能用单引号)","link":"/2020/03/29/Ajax%E5%92%8CJSON/"},{"title":"Django Vuejs","text":"django with vuejs 博客：https://zhuanlan.zhihu.com/p/25080236 github：https://github.com/tmpbook/django-with-vuejs","link":"/2020/03/28/Django-Vuejs/"},{"title":"ES6-class关键字01","text":"class关键字 class关键字，是实现面向对象编程的新形式 静态属性：通过构造函数，直接访问到的属性，叫做静态属性 实例属性：通过 new 出来的实例 访问到的属性，叫做 实例属性 传统1234567891011121314151617181920212223242526272829function Person(name,age){ this.name = name this.age = age}// info属性 直接挂在给构造函数Person，所以info是静态属性Person.info = 'aaaaa'// 静态方法Person.show = function () { console.log('这是 Person 的静态 show方法')}// 将方法say挂在到Person的原型对象上，成为了实例方法Person.prototype.say = function () { console.log('这是 Person 的实例方法')}const p1 = new Person('xiaoyi', 18)// 通过 new 出来的实例 访问到的属性，叫做 实例属性console.log(p1)console.log(p1.name)console.log(p1.age)// 通过 实例对象 .出来的方法，就叫实例方法console.log(p1.say)// 静态方法 和 属性，只能由构造函数访问，实例对象不能访问console.log(Person.info)console.log(Person.show) class创建12345678910111213141516171819202122232425262728class Animal { // 每一个类中，都有一个构造器（或隐藏）；每当new 这个类的时候，必然会优先执行 构造器中的代码 constructor(name ,age){ // 实例属性 this.name = name this.age = age } // 在class内部，通过static修饰的属性，就是静态属性 static info = 'aaaaa' // 静态方法 static show(){ console.log('这是 Animal 的静态方法') } // 这也是挂在到原型对象上的一个实例方法，同say // 经常会使用到实例方法 see(){ console.log('这是 Animal 的实例方法') }}const a1 = new Animal('milu,10)console.log(a1)console.log(a1.name)console.log(a1.age)console.log(a1.see)console.log(Animal.info)console.log(Animal.show) 注意： 在class的 { } 区间内，只能写 构造器、实例方法、静态方法和静态属性，其中 实例属性 在构造器中写 class 关键字的内部 ，还是用原来的方法实现的，所以我们把class关键字，称作 语法糖","link":"/2020/03/25/ES6-class%E5%85%B3%E9%94%AE%E5%AD%9701/"},{"title":"ES6-展开运算符","text":"展开运算符（spread operator） 展开运算符，允许一个表达式在某处展开。展开运算符在多个参数（用于函数调用）或多个元素（用于数组字面量）或者多个变量（用于解构赋值）的地方可以使用。 展开运算符不能用在对象当中，因为目前展开运算符只能在可遍历对象（iterables）可用。iterables的实现是依靠[Symbol.iterator]函数，而目前只有Array,Set,String内置[Symbol.iterator]方法，而Object尚未内置该方法，因此无法使用展开运算符。不过ES7草案当中已经加入了对象展开运算符特性。 函数调用中使用展开运算符我们使用…展开运算符就可以把args直接传递给test()函数。 123function test(a,b,c) { }var args = [0,1,2];test(...args); 数组字面量中使用展开运算符12var arr1=['a','b','c'];var arr2=[...arr1,'d','e']; //['a','b','c','d','e'] 展开运算符也可以用在push函数中，可以不用再用apply()函数来合并两个数组： 123var arr1=['a','b','c'];var arr2=['d','e'];arr1.push(...arr2); //['a','b','c','d','e'] 用于解构赋值1234let [arg1,arg2,...arg3] = [1, 2, 3, 4];arg1 //1arg2 //2arg3 //['3','4'] 展开运算符在解构赋值中的作用跟之前的作用看上去是相反的，将多个数组项组合成了一个新数组。 不过要注意，解构赋值中展开运算符只能用在最后 类数组对象变成数组展开运算符可以将一个类数组对象变成一个真正的数组对象： 12var list=document.getElementsByTagName('div');var arr=[..list];","link":"/2020/03/25/ES6-%E5%B1%95%E5%BC%80%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"title":"JWT认证","text":"JSON Web Token（JWT） 学习文档转自 https://www.cnblogs.com/haha12/p/11796456.html JWT简介JSON Web Token（JWT）是一个开放的标准（RFC 7519），它定义了一个紧凑且自包含的方式，用于在各方之间作为JSON对象安全地传输信息。由于此信息是经过数字签名的，因此可以被验证和信任。 JWT认证和session认证的区别 session认证 http协议是一种无状态的协议，而这就意味着如果用户向我们的应用提供了用户名和密码来进行用户认证，那么下一次请求时，用户还要再一次进行用户认证才行，因为根据http协议，我们并不能知道是哪个用户发送的请求，所以为了让我们的应用能识别是哪个用户发出的，我们只能在服务器存储一份用户登陆的信息，这份登陆信息会在响应时传递给浏览器，告诉其保存为cookie，以便下次请求时发送给我们的应用，这样我们的应用个就能识别请求来自哪个用户了，这就是传统的基于sessino认证。 JWT认证 基于token的鉴权机制类似于http协议也是无状态的，它不需要在服务端去保留用户的认证信息或会话信息。这也就意味着JWT认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利。 JWT认证流程 认证流程如下： 用户使用账号和密码发出post请求； 服务器使用私钥创建一个jwt； 服务器返回这个jwt给浏览器； 浏览器将该jwt串在请求头中像服务器发送请求； 服务器验证该jwt； 返回响应的资源给浏览器。 JWT组成 从上图可以看到，JWT含有三部分：头部（header）、载荷（payload）、签名（signature）。 1.头部 JWT的头部有两部分信息： 声明类型，这里是JWT 声明加密的算法，通常直接使用HMAC SHA256 头部示例如下： 1234{ \"alg\": \"HS256\", \"typ\": \"JWT\"} 头部一般使用base64加密，加密后密文：eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9 2.载荷 该部分一般存放一些有效的信息。JWT的标准定义包含五个字段： iss：该JWT的签发者 sub: 该JWT所面向的用户 aud: 接收该JWT的一方 exp(expires): 什么时候过期，这里是一个Unix时间戳 iat(issued at): 在什么时候签发的 载荷示例如下： 12345{ \"sub\": \"1234567890\", \"name\": \"Java碎碎念\", \"iat\": 1516239022} 3.签名 前面两部分都是使用Base64进行编码的，即前端可以解开知道里面的信息。signature 需要使用编码后的header和payload以及我们提供的一个密钥，然后使用header中指定的签名算法（HS256）进行签名。签名的作用是保证 JWT 没有被篡改过。 三个部分通过.连接在一起就是我们的 JWT 了，所以我们生成的JWT如下： eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkphdmHnoo7noo7lv7UiLCJpYXQiOjE1MTYyMzkwMjJ9.LLJIkhJs6SVYlzn3n8fThQmhGutjTDI3RURTLtHV4ls 注意：密钥就是用来进行JWT的签发和JWT的验证，所以，它就是你服务端的私钥，在任何场景都不应该泄露出去。 JWT使用场景 JWT主要使用场景如下： 授权 这是JWT使用最多的场景，一旦用户登录，每个后续的请求将包括JWT，从而允许用户访问该令牌允许的路由、服务和资源。 信息交换：JSON JWT可以用在各方之间安全地传输信息，因为JWT可以进行签名，所以您可以确定发件人是他们所说的人。另外，由于签名是使用标头和有效负载计算的，因此您还可以验证内容是否未被篡改。","link":"/2020/03/29/JWT%E8%AE%A4%E8%AF%81/"},{"title":"MGQ时尚风云中","text":"《明星大侦探第五季》第七案《MGQ时尚风云中》分析今天这一期的案件是发生在MGQ时尚杂志社里。杂志社的同事们约好在晚上十点给何社长办生日会，但是却在10点10分的时候发现杂志社的甄主编死在了楼梯间。 本期侦探：何社长 涉案人员 撒时装：40岁，与甄主编是上下级的关系，入职20年,身高175CM 侯助理：22岁，与甄主编并没有什么来往，入职一年，身高178CM 蓉美妆：30岁，与甄主编是师徒关系，入职八年，身高175CM 贾美妆：22岁，与甄主编是上下级的关系，入职一年，身高178CM 魏秘书：24岁，是甄主编的助理，入职不到一年，身高178CM 死者：甄主编：42岁，入职22年。死因，被丝巾勒死，尸体放在了楼梯间的硬纸箱里，身高178CM 郝秘书：2019年12月29日，因过劳死在了公司茶水间，时年30岁。 案发时间梳理根据线索，甄主编原本计划是在晚上9点50分回到公司，但是在何的朋友圈留言，显示其在8：05的时候就已经回来了。 根据保安的证词，甄主编在晚上9：30的时候又离开了公司。 根据现有的证据显示，甄主编是在晚上9：30-10：10间遇害身亡。 在后面的证据搜索中，发现以下几个线索： 在撒和侯的办公室发现了一套与死者一模一样的衣服，还有一个灯光控制器 在整点的时候，保洁会来打扫卫生；在半点的时候保安会巡视 死者所在的楼梯间在晚上9：20-9：25的时候有油漆工人给地板刷油漆，而油漆在晚上9：35之前不会干 茶水间监控于2018年12月30日进行更换，并且每一个小时缓存一次 在茶水间的视频中可以看到，在晚上9：30的时候茶水间的门自动开了，甄主编出现在了茶水间外面，进入了楼梯间，然后灯灭了，过了15秒灯亮起，楼梯间的门紧紧关着。 据悉，从楼梯间的后门连接的是停车场，从后门回到正门需要半个小时 楼梯间的门只能由甄主编从里面开，其他人只能从杂志社内从楼梯间的外面开门 由以上证据，可以作出以下几个假设： 监控里出现的就是甄主编，甄主编是在9：30之后被害 监控视频里是凶手伪装的甄主编，甄主编在这很短的时间里遇害，凶手又在15秒的黑暗时间里离开楼梯间。 死者在9：20前就已经遇害，而凶手伪装成甄主编的样子，假装甄主编是在9：30之前遇害的假象。伪造不在场证明。 根据分析，第三点假设更加成立。但是根据第三条线索，凶手在9：30今日楼梯，鞋底必然会沾上油漆，但是在现场的鞋子上并没有发现油漆，而根据监控视频，凶手确实是进入到了楼梯间。 那么只有一种可能，凶手并没有进入楼梯间。凶手伪造了现场。在现场找到了两面可以推动的镜子，通过实验发现，凶手是通过镜面的折射，伪造了进入楼梯间的假象，实则进入的是旁边的甄主编的办公室。 凶手在9：30的时候将镜子摆放成如图的样子，然后用力推开茶水间的门，伪装成甄主编的样子进入旁边的甄主编的办公室，在15秒的黑暗时间，将镜子推走。就这样伪造了一个监控视频。 由此可以确认甄主编在9：20之前就已经死亡了。 而根据涉案人员陈述的时间点，每个人都没有不在场证明。 下面从每个人的动机分析 撒时装：家庭负担重，但是甄主编辞退了他，并表示会在何的生日会上宣布这件事。撒又因为年纪的原因被其他公司拒绝。 蓉美妆：与郝秘书曾经是恋爱关系。但是发现郝秘书赌博，并且并不是像大家以为的兢兢业业，而是在办公室进行网络赌博，所以相与郝秘书分手。郝秘书以曝光蓉的私照与谈恋爱的秘密为要挟，向蓉勒索。蓉与郝在茶水间争执，蓉失手将郝推倒，导致郝死亡。甄看到了，帮助蓉将现场伪造成郝过劳死。后来贾在一个月内得到了蓉奋斗了五年的职位，蓉又听到了贾威胁蓉的话，以为甄把自己的事情告诉了贾，所以怀恨在心。 贾美妆：他看到了甄与蓉的做的事情，于是威胁甄得到升职的机会。在最后一次威胁的时候，贾希望得到副主编的位置，但是甄主编表示，自己会在生日会的时候宣布离职，主编的位置会留给贾。但是就在26日的晚上八点四十分，贾知道了，甄已经和另一家杂志社签订了合同，并打算带走MGQ杂志社内所有的核心编辑。 魏秘书：他是名校毕业，原本在一家杂志社担任编辑，但是在甄主编的聘用下，决定来MGQ当秘书，但是干的是和编辑不相干的事情。他接到了一通以“郝秘书”的名义打来的电话，而且灯光熄灭，气氛非常诡异，而在电话里说，魏的下场就会和郝的下场一样。接下来他又收到了“郝秘书”送来的血书。因为“郝秘书”称他为“魏秘书”而不是“喂”，他觉得自己得到了尊重，所以，经常通过打字机与“郝秘书”聊天。而在任职期间，魏秘书希望可以去体检，但是甄主编却以工作为由，拒绝了他体检的理由。然后魏秘书就收到了诊断书，他患有百分之九十的心肌坏死，严重过劳，并且已经到了生命的尽头，所以他对杂志社的所有人都怀恨在心。他买了易燃的地毯，没有换甄主编让他换的地毯，买了蜡烛。只要何在10点10分吹蜡烛，就会引火。 侯助理：是郝秘书的弟弟，来公司调查哥哥的死因。在此期间，他文章被以撒的名义刊登在了撒主持编辑的版块。他又发现了魏秘书的境况，伪装成“郝秘书”与魏秘书交流，所以他用过灯光控制器。他意外收到了魏秘书的诊断书，将诊断书上的百分之十改成了百分之九十，诱导魏秘书对杂志社的人进行报复。 根据以上线索，可以排除掉蓉，因为勒死一个身高比自己高的成年女性，还要在15秒内将两面大镜子推走，对于蓉来说是吃力的。 可以排除掉侯，因为侯已经利用了魏秘书，只需要等待魏秘书行动了。 至于撒和贾，并没有明确的计划，他们其实在在茶水间里等待机会。 剩下的只有魏了。魏秘书在这个案件中非常关键的一点就是那条地毯。因为甄主编是一个非常苛刻的人，所以当她回来看到地毯不是她要求魏秘书换的那条一定会让魏秘书换掉，而魏秘书的计划就没有办法实施了。但是他没有想到甄主编会提前回来，反正他是打算杀掉所有人，所以提前杀掉甄主编也可以。而如果甄主编一直不出现，所有人一定要会等她出现，所以他伪造了甄主编出去的假象，而所有人可以放心吹蜡烛。 以上就是对于本期《明星大侦探》的分析。 本片文章转自 原创 姑且如此 不得甚解 1月2日 侵私删","link":"/2020/02/16/MGQ%E6%97%B6%E5%B0%9A%E9%A3%8E%E4%BA%91%E4%B8%AD/"},{"title":"Mockjs","text":"mockjs 生成随机数据 所有内容資料來自 前后端分离趋势，前端负责数据展示、页面动态效果等，后端负责编写应用程序接口，功页面、第三方等调用。有很多情况是，前端已经写好页面，一直等待后端接口的联调。所以现在就有造价数据的工具mockjs jquery 中 使用 mockjs来拦截ajax请求，并返回假数据。 引入mockjs123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657const Mock = require('mockjs')// 返回字符串Mock.mock('/api/data', (req, res) =&gt; { return Mock.mock({ 'string|3': '*' })})// 返回指定范围的整数Mock.mock('/api/getInteger', (req, res) =&gt; { return Mock.mock({ 'a|1-100': 100 })})// 返回随机个数的对象Mock.mock('/api/getObject', (req, res) =&gt; { return Mock.mock({ 'brand|1-3': { a: '京东', b: '国美', c: '苏宁', d: '当当', e: '天猫', f: '淘宝' } })})// 返回随机数组Mock.mock('/api/getArr', (req, res) =&gt; { return Mock.mock({ 'data|1-10': [ { 'name': '张三' } ] })})// 返回随机字符Mock.mock('/api/getRandom1', (req, res) =&gt; { return Mock.mock({ 'random1': /[a-z]{2}[A-Z]{2}[0-9]/ })})// 返回随机字符Mock.mock('/api/getRandom2', (req, res) =&gt; { return Mock.mock({random2: '@string(\"lower\", 5)'})})// 返回UUIDMock.mock('/api/getUUID', (req, res) =&gt; { return {'uuid': Mock.Random.id()}}) 常用类1234567\"id|+1\": 1, //id的递增\"name\": \"@cname\", // 姓名\"email\": \"@email\", //邮箱\"mobile\": /^(13[0-9]|15[012356789]|166|17[3678]|18[0-9]|14[57])[0-9]{8}$/, //生成手机11位号 可以使用正则表达式\"sex\": \"@boolean, // 随机boolean\"avatar\":\"@image\" // 图片\"avatar\":\"@image('50x50','red','#fff','文字‘)\" 数据类123456\"Boolean\": \"@boolean\", // 布尔值\"natural\": \"@natural\", // natural( min, max )\"integer\": \"@integer\", // integer( min, max )\"float\": \"@float(22,99,1,2)\", // float( min, max, dmin, dmax )\"string\": \"@string\", //string(type,min,max) lower小写，upper大写，number数字，symbol符号，\"range\": \"@range\", //range( start, stop, step ) step为间隔为，最后返回值为数组 時間1234\"date\": \"@date\", // 日期\"time\": \"@time\", // 时间\"dataTime\": \"@datetime\", // 日期+时间\"Now\": \"@now\", // 当前的日期时间 文章 凡是@后加c就是为中文；例如name为英文，cname则是中文 1234\"paragraph\": \"@cparagraph\", // 段落\"title\":\"@ctitle(1,10)\",//标题，长度为1-10\"sentence\": \"@csentence\", //句子\"first\": \"@cfirst\", //姓氏 地方123\"region\": \"@region\", //方位\"province\": \"@province\", //省份 \"city\": \"@city\", // 城市 +(true)，可以获取到上一级，例如：@city(true) 可以获取到省市 对象和数组123456789101112\"city|2-4\": { \"110000\": \"北京市\", \"120000\": \"天津市\", \"130000\": \"河北省\", \"140000\": \"山西省\" }\"city|1\": [ \"北京市\", \"天津市\", \"河北省\", \"山西省\"]","link":"/2020/04/07/Mockjs/"},{"title":"Nodejs相关","text":"NodeJSNode.js® 是一个基于 Chrome V8 引擎 的 JavaScript 运行时。 Node.js是一个基于Chrome JavaScript运行时建立的平台， 用于方便地搭建响应速度快、易于扩展的网络应用。Node.js 使用事件驱动， 非阻塞I/O 模型而得以轻量和高效，非常适合在分布式设备上运行的数据密集型的实时应用。 Express 是一个基于 Node.js 平台的极简、灵活的 web 应用开发框架，它提供一系列强大的特性，帮助你创建各种 Web 和移动设备应用。Express 也是官方推荐的Web框架。 下载安装node.js 新建文件，并npm init -y 初始化项目生成 package.jspn文件 安装 Express npm init express -S 会生成node_modules","link":"/2020/02/18/Nodejs%E7%9B%B8%E5%85%B3/"},{"title":"Promise相关","text":"Promise ES6 原生提供了 Promise 对象。所谓 Promise，就是一个对象，用来传递异步操作的消息。它代表了某个未来才会知道结果的事件（通常是一个异步操作），并且这个事件提供统一的 API，可供进一步处理。 1.Promise用法1.1 异步调用 异步效果分析 定时任务 setTimeout setInterver Ajax 异步ajax请求（jqurey） 1234567891011var ret = ''$ajax{( url:'http://localhost:3000/...', success: function(data){ console.log(data) ret = data; console.log(ret) // 这里可以 })}console.log(ret) // 这里的ret是获取不到里面的东西的// 只能在回调函数中，获得值 事件函数 多次异步调用的依赖分析 多次异步调用的结果顺序不确定 异步调用结果如果存在依赖，那么我们需要多次多次嵌套，就是传说中的“十八层地域”，回调地狱。 1.2 Promise 概述Promise 是异步编程的一种解决方案，从语法上讲，Promise是一个对象，从它可以获取异步操作的消息。 可以避免多层异步调用嵌套问题（回调地狱）。 Promise对象提供了简介的API，使得控制异步操作更加容易 1.3 Promise 基本用法 实例化Promise 对象，构造函数中传递函数，该函数中用于处理异步任务 resolve和reject两个参数（都是方法，可以调用）用于处理成功和失败两种情况，并通过p.the获取处理结果 12345678910111213141516171819202122232425262728var p = new Promise(function(resolve, reject){ // 成功时调用 resolve() // 失败时调用 reject()})p.then(function(ret){ // 返回成功的结果ret},function(error){ // 返回失败的结果}) -------------------------------------------------var p = new Promise(function(resolve, reject){ setTimeout(function(){ var flag = true if(flag) { // 正常情况 resolve('hello') }else { // 异常情况 reject('出错') } }, 100) })p.then(function(data){ console.log(data)},function(error){ console.log(error)}) 1.4 基于Promise处理Ajax请求 处理原生Ajax 1.5 then参数中的函数返回值1.返回Promise实例对象 返回的该实例对象会调用下一个then 2.返回普通值 返回的普通值会直接传递给下一个then，通过then参数中函数的参数接收该值 1.6 Promise常用的API1.实例方法（在原型中的方法，需要用实例去调用） p.then() 得到异步任务的正确结果 p.catch() 获取异常信息 p.finally() 成功与否都会执行（尚且不是正式标准） 123456789101112131415161718function foo(){ return new Promise(function(resolve, reject){ setTimeout(function(){ // resolve(123); reject(error) },100); })}foo() .then(function(data){ console.log(data) }) .catch(function(data)){ console.log(data) }) .finally(function(){ console.log('finished') }); 2.对象方法 Promise.all() 并发处理多个异步任务，所有任务都执行完成才能得到结果 Promise.race() 并发处理多个异步任务，只要有一个任务完成就能得到结果 2 接口调用 -fetch用法2.1 基本特性 更加简单的数据获取方式，功能更强大，更灵活，可以看做是xhr的升级版 基于Promise实现 2.2 语法结构fetch(url).then(fn2) ​ .then(fn3) ​ … ​ .catch(fn) 12345fetch('http://localhost:3000/fdata').then(function(data){ return data.text(); //text()方法属于fetchAPI的一部分，它返回一个Promise实例对象，用于获取后台返回的数据}).then(function(data){ console.log(data)}) 2.3 fetch请求参数 常用配置选项 method(String): HTTP请求方法，默认为GET POST PUT DELETE body(String): HTTP请求参数 header(Object): HTTP的请求头，默认为{} 3. axios 用法3.1 axios 的基本特性axios（官网：https://github.com/axios/axios）是一个基于Promise用于浏览器和node.js的HTTP客户端 它有以下特性： 支持浏览器和node.js 支持promise 能拦截请求和响应 自动转换JSON数据 3.2 axios 的基本用法12345axios.get('/adata') .then(ret =&gt; { //data属性名称是固定的，用于获取后台响应的数据 console.log(ret.data)}) 3.3 axios 常用API get： 添加数据 post： 删除数据 put： 修改数据 delete： 删除数据 GET 传递参数 通过 URL 传递参数 通过params 选项传递参数 123456789axios.get('/adata?id=123') .then(ret =&gt; { console.log(ret.data) })// 后台接口app.get('/axios',(req,res) =&gt; { res.send('axios get 传递参数' + req.query.id)}) 123456789axios.get('/adata/123') .then(ret =&gt; { console.log(ret.data) })// 后台接口app.get('/axios/:id',(req,res) =&gt; { res.send('axios get (Restful) 传递参数' + req.params.id)}) 12345678axios.get('/adata',{ params:{ id:123 }}).then(ret =&gt; { console.log(ret.data)}) POST 传递参数 axios.post(‘http://localhost:3000/axios’,{ ​ uname: ‘lily’ ​ pwd: 123 }).then(function(ret){ ​ console.log(ret.data) }) post传参，这样默认传过去的是以json格式传 3.4 axios 的响应结果响应结果的主要属性（axios自己包装了，有这些属性 data：实际响应回来的数据 headers：响应头信息 status：响应状态码 statusText：响应状态信息 3.5 axios 的全局配置axios.defaults.timeout = 3000； //超时时间 axios.defaults.aseURL = ‘http://localhost:3000/app’; //默认地址 axios.defaults.headers[ ‘mytoken’ ] = ‘xxxx’ //设置请求头 3.6 axios 的拦截器 请求拦截器 在请求发出之前设置一些信息 //添加一个请求拦截器 token拦截 axios.interceptors.request.use(function(config){ ​ // 在请求发出之前进行一些信息设置 ​ config.headers.mytoken = ‘ nihao’ ​ return config }，function（err）{ // 处理响应的错误信息 }) 2.响应拦截器 在获取数据之前，对数据做一些加工处理 添加一个响应拦截器 axios.interceptors.request.use(function(res){ ​ // 在这里对返回的数据进行处理 ​ return res }，function（err）{ // 处理响应的错误信息 }) 4. 接口调用 -async /await用法 （常用） async/await是ES7 引入的新语法，可以更加方便的进行一步操作 async 关键字用于函数上（async函数的返回值是Promise实例对象） await 关键字用于async 函数当中（await可以得到异步的结果） async function queryData(id){ ​ const ret = await axios.get(‘/data’) ​ return ret; } queryData.then(ret =&gt; { ​ console.log(ret) })","link":"/2020/03/14/Promise%E7%9B%B8%E5%85%B3/"},{"title":"RESTfull","text":"RESTfull 一种软件架构风格、设计风格，不是标准，提供了一组设计原则和约束条件。 主要用于客户端和服务器交互类软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存机制。查看词条 原则条件 REST 指的是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是 RESTful。 Web应用程序最重要的REST原则是，客户端和服务器之间的交互在请求之间是（http请求）无状态的。客户端到服务器的每一个请求都必须包含理解请求所必需的信息。 在服务器端，应用程序状态和功能可以分为各种资源。向客户端公开。每个资源都使用 URL 得到一个唯一的地址。所有资源都共享同一的接口，以便客户端和服务器之间传输状态。使用的是标准的 HTTP 方法，比如 GET、PUT、POST和DELETE 特点 每个URL代表 1 种资源 客户端使用GET、POST、PUT、DELETE4个表示操作方式的动词对服务端资源进行操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源； 资源的表现形式是 XML 或者 HTML 客户端与服务端之间的交互请求之间是无状态的。客户端到服务器的每一个请求都必须包含理解请求所必需的信息。 RESTful架构 RESTful架构是对MVC架构改进后所形成的一种架构，通过使用事先定义好的接口与不同的服务联系起来。在RESTful架构中，浏览器使用POST，DELETE，PUT和GET四种请求方式分别对指定的URL资源进行增删改查操作。因此，RESTful是通过URI实现对资源的管理及访问，具有扩展性强、结构清晰的特点。 RESTful架构将服务器分成前端服务器和后端服务器两部分，前端服务器为用户提供无模型的视图；后端服务器为前端服务器提供接口。浏览器向前端服务器请求视图，通过视图中包含的AJAX函数发起接口请求获取模型。 其他概念 (更多)无状态 服务器设计接口，应当设计为无状态接口。即服务器端不保存任何与客户端相关的状态上下文信息。 客户端在每次调用接口时，需要提供足够的信息，以供服务器完成操作 无状态设计中，服务端减少了保存客户端相关上下文数据，因此，一方面服务端能够更加容易实现动态扩展；减少了服务端从故障中恢复的任务量 但无状态也会带来额外的问题。客户端将需要保存完整的用户状态信息，在每次与服务端交互时可能需要增加与用户状态相关的上下文信息，这样将导致请求数据的重复和增大 缓存 接口设计中增加缓存策略，服务器可以决定是否可以缓存当前返回的数据。这样 减少服务器被请求的次数，提高网络访问性能 缓存要谨慎使用，需要缓存什么数据，缓存过期时间等，要根据实际情况设计。 一般而言，数据字典类数据、修改频率非常低的数据、实时性要求很低的数据等，这些数据可以设计一定的缓存策略，以提高系统运行效率。 系统分层 横向分层一般可以分为 交互层 、服务层 、数据层 纵向分层则通常会按照不同的业务功能对系统进行切分 统一接口​ 统一接口，即是不同系统模块之间的调用接口统一规范，使用统一的调用协议，统一的数据格式等。统一接口带来的是系统交互的规范化，接口调用与业务解耦，各模块独立进化。","link":"/2020/04/06/RESTfull/"},{"title":"React 1","text":"React和Vue对比 1.如何实现组件化Vue: 通过 .vue 文件，来创建对应的组件;（Vue.component() 这也是一种) (.vue 这种文件需要有vue-loader去编译（webpack里面的一个loader）) eg: Home.vue template 结构 script 行为 style 样式 App.js import Home from ‘./Home.vue’ React: 有组件化的概念，但没有像vue这样的组件模板文件；React中，一切都是以JS来表现的；JS知识要合格，ES6和ES7(async await)需了解. 2.团队React是有FaceBook前端官方团队进行维护和更新 Vue是以尤雨溪为主导的开源小团队","link":"/2020/03/23/React-1/"},{"title":"React 2","text":"React中几个核心的概念​ 虚拟DOM（为了实现页面中，DOM元素的高效更新） DOM的本质：浏览器中的概念，用JS对象来表示 页面上的元素，并提供了操作DOM对象的API 什么是React中的虚拟DOM：框架中的概念， 用JS对象来模拟页面上的DOM和DOM嵌套 用JS对象的形式，来模拟页面上DOM嵌套关系。 提供新旧DOM树 DOM树的概念​ 一個网页呈现的过程： 浏览器请求服务器获取页面HTML代码 浏览器先在内存中解析DOM结构，并在浏览器内存中，渲染出一颗DOM树 浏览器把DOM树呈现到页面上 Diff算法 tree diff： 新旧两个DOM树，逐层对比的过程，就是Tree Diff，当整颗DOM逐层对比完毕，则所有需要被按需更新的元素，必然能够找到； component diff：在进行Tree Diff的时候，每一层中，组件级别的对比，叫做Component Diff； 如果对比前后，组件的类型相同，则暂时认为此组件不需要被更新； 对比后，组件类型不同，则需要移除旧组件，创建新组件，并追加到页面上； element diff：在进行组件对比的时候，如果两个组件类型相同，则需要进行元素级别的对比，叫做element diff。 ​","link":"/2020/03/24/React-2/"},{"title":"React 3","text":"React（转载） 学习文档转自黑马教程 ReactJS简介 React 起源于 Facebook 的内部项目，因为该公司对市场上所有 JavaScript MVC 框架，都不满意，就决定自己写一套，用来架设 Instagram 的网站。做出来以后，发现这套东西很好用，就在2013年5月开源了。 由于 React 的设计思想极其独特，属于革命性创新，性能出众，代码逻辑却非常简单。所以，越来越多的人开始关注和使用，认为它可能是将来 Web 开发的主流工具。 library Framework 前端三大主流框架 Angular.js：出来最早的前端框架，学习曲线比较陡，NG1学起来比较麻烦，NG2开始，进行了一系列的改革，也开始启用组件化了；在NG中，也支持使用TS（TypeScript）进行编程； Vue.js：最火的一门前端框架，它是中国人开发的，对我我们来说，文档要友好一些； React.js：最流行的一门框架，因为它的设计很优秀； windowsPhone 7 7.5 8 10 React与vue.js的对比组件化方面 什么是模块化：从 代码 的角度，去分析问题，把我们编程时候的业务逻辑，分割到不同的模块中来进行开发，这样能够方便代码的重用； 什么是组件化：从 UI 的角度，去分析问题，把一个页面，拆分为一些互不相干的小组件，随着我们项目的开发，我们手里的组件会越来越多，最后，我们如果要实现一个页面，可能直接把现有的组件拿过来进行拼接，就能快速得到一个完整的页面， 这样方便了UI元素的重用；组件是元素的集合体； 组件化的好处： Vue是如何实现组件化的：.vue 组件模板文件，浏览器不识别这样的.vue文件，所以，在运行前，会把 .vue 预先编译成真正的组件； template： UI结构 script： 业务逻辑和数据 style： UI的样式 React如何实现组件化：在React中实现组件化的时候，根本没有 像 .vue 这样的模板文件，而是，直接使用JS代码的形式，去创建任何你想要的组件； React中的组件，都是直接在 js 文件中定义的； React的组件，并没有把一个组件 拆分为 三部分（结构、样式、业务逻辑），而是全部使用JS来实现一个组件的；（也就是说：结构、样式、业务逻辑是混合在JS里面一起编写出来的） 开发团队方面 React是由FaceBook前端官方团队进行维护和更新的；因此，React的维护开发团队，技术实力比较雄厚； Vue：第一版，主要是有作者 尤雨溪 专门进行维护的，当 Vue更新到 2.x 版本后，也有了一个小团队进行相关的维护和开发； 社区方面 在社区方面，React由于诞生的较早，所以社区比较强大，一些常见的问题、坑、最优解决方案，文档、博客在社区中都是可以很方便就能找到的； Vue是近两年才诞生开源出来的，所以，它的社区相对于React来说，要小巧一些，所以，可能有的一些坑，没人踩过； 移动APP开发体验方面 Vue，结合 Weex 这门技术，提供了 迁移到 移动端App开发的体验（Weex，目前只是一个 小的玩具， 并没有很成功的 大案例；） React，结合 ReactNative，也提供了无缝迁移到 移动App的开发体验（RN用的最多，也是最火最流行的）； 为什么要学习React 设计很优秀，是基于组件化的，方便我们UI代码的重用； 开发团队实力强悍，不必担心短更的情况； 社区强大，很多问题都能找到对应的解决方案； 提供了无缝转到 ReactNative 上的开发体验，让我们技术能力得到了拓展；增强了我们的核心竞争力 React中几个核心的概念虚拟DOM（Virtual Document Object Model） DOM的本质是什么：就是用JS表示的UI元素 DOM和虚拟DOM的区别： DOM是由浏览器中的JS提供功能，所以我们只能人为的使用 浏览器提供的固定的API来操作DOM对象； 虚拟DOM：并不是由浏览器提供的，而是我们程序员手动模拟实现的，类似于浏览器中的DOM，但是有着本质的区别； 为什么要实现虚拟DOM： 什么是React中的虚拟DOM： 虚拟DOM的目的： Diff算法 tree diff:新旧DOM树，逐层对比的方式，就叫做 tree diff,每当我们从前到后，把所有层的节点对比完后，必然能够找到那些 需要被更新的元素； component diff：在对比每一层的时候，组件之间的对比，叫做 component diff;当对比组件的时候，如果两个组件的类型相同，则暂时认为这个组件不需要被更新，如果组件的类型不同，则立即将旧组件移除，新建一个组件，替换到被移除的位置； element diff:在组件中，每个元素之间也要进行对比，那么，元素级别的对比，叫做 element diff； key：key这个属性，可以把 页面上的 DOM节点 和 虚拟DOM中的对象，做一层关联关系； React项目的创建 运行 cnpm i react react-dom -S 安装包 1.1 react 这个包，是专门用来创建React组件、创建虛擬DOM、组件生命周期等这些东西的；1.2 react-dom 里面主要封装了和 DOM 操作相关的包，进行DOM操作，最主要的应用场景是 ReactDOM， render() 在项目中导入两个相关的包： 12import React from 'react'import ReactDOM from 'react-dom' 使用JS的创建虚拟DOM节点： 在 react 中，如要要创建 DOM 元素了，只能使用 React 提供的 JS API 来创建，不能【直接】像 Vue 中那样，手写 HTML 元素 123456789// React.createElement() 方法，用于创建 虚拟DOM 对象，它接收 3个及以上的参数 // 参数1： 是个字符串类型的参数，表示要创建的元素类型 // 参数2： 是一个属性对象，表示 创建的这个元素上，有哪些属性 // 参数3： 从第三个参数的位置开始，后面可以放好多的虚拟DOM对象，这写参数，表示当前元素的子节点 // &lt;div title=\"this is a div\" id=\"mydiv\"&gt;这是一个div&lt;/div&gt; var myH1 = React.createElement('h1', null, '这是一个大大的H1') var myDiv = React.createElement('div', { title: 'this is a div', id: 'mydiv' }, '这是一个div', myH1) 使用 ReactDOM 把元素渲染到页面指定的容器中： 123// ReactDOM.render('要渲染的虚拟DOM元素', '要渲染到页面上的哪个位置中')// 注意： ReactDOM.render() 方法的第二个参数，和vue不一样，不接受 \"#app\" 这样的字符串，而是需要传递一个 原生的 DOM 对象ReactDOM.render(myDiv, document.getElementById('app')) JSX语法 (配合官方jsx文档)​ Babel 是一个 JavaScript 编译器。（把浏览器不认识的语法，编译成浏览器认识的语法。） ​ webpack 是一个现代 JavaScript 应用程序的静态模块打包器。（项目打包） 如要要使用 JSX 语法，必须先运行 cnpm i babel-preset-react -D，然后再 .babelrc 中添加 语法配置； 运行 cnpm i babel-core babel-loader babel-plugin-transform-runtime -D 运行 cnpm i babel-present-env babel-preset-stage -D JSX语法的本质：还是以 React.createElement 的形式来实现的，并没有直接把 用户写的 HTML代码，渲染到页面上； 如果要在 JSX 语法内部，书写 JS 代码了，那么，所有的JS代码，必须写到 {} 内部； 渲染数字 渲染字符串 渲染布尔值 为属性绑定值 渲染jsx元素 渲染jsx元素数组 将普通字符串数组 转为jsx数组并渲染到页面上 eg：let a = 10 ​ &lt;div&gt; {a} &lt;/div&gt; ​ &lt;div&gt; {a+2} &lt;/div&gt; 也可以进行基本的运算 当 编译引擎，在编译JSX代码的时候，如果遇到了&lt;那么就把它当作 HTML代码去编译，如果遇到了 {} 就把 花括号内部的代码当作 普通JS代码去编译； 在{}内部，可以写任何符合JS规范的代码； 在JSX中，如果要为元素添加class属性了，那么，必须写成className，因为 class在ES6中是一个关键字；和class类似，label标签的 for 属性需要替换为 htmlFor. 在JSX创建DOM的时候，所有的节点，必须有唯一的根元素进行包裹； 如果要写注释了，注释必须放到 {/* */} 内部 React中：第一种创建组件的方式 使用构造构造函数来创造组件，如果要接收外界传递的数据，需要再 构造函数的参数列表中使用props来接收；必须要向外return一个合法的JSX创建的虚拟DOM 创建组件： 12345// 注意：组件首字母必须是大写function Hello(){ // return null return &lt;div&gt;Hello 组件&lt;/div&gt;} 为组件传递数据： 123456789// 使用组件，并为组件传递props 数据&lt;Hello name={dog.name} age={dog.age} gender={dog.gender}&gt;&lt;/Hello&gt;// 在构造函数中，使用props 形参，接收外界传递过来的数据function Hello(props){ // props.name = 'zs' console.log(props) // 结论：不论是 Vue 还是 React，组建中的props 永远都是只读的；不被重新赋值； return &lt;div&gt;Hello 组件----{props.name}----{props.age}----{props.gender}&lt;/div&gt;} 父组件向子组件传递数据使用(…obj)属性扩散传递数据将组件封装到单独的文件中React中：第二种创建组件的方式了解ES6中class关键字的使用基于class关键字创建组件 使用 class 关键字来创建组件 render 函数的作用： 是渲染 当前组件所对应的 虚拟DOM元素 类中的 this 指向这个类的实例对象 123456789101112131415161718192021class Person extends React.Component{ constructor(){ super() // 这个this.state = {} 相当于vue中的data(){return{}} // 这个是可读可写的 this.state = { msg : '大家好！' } } // 在class创建的组件中，必须定义一个render函数 render(){ // 在render函数中，必须返回一个null或者符合规范的虚拟DOM元素 // 在 class关键字创建的组件中，如果想使用 外界传递过来的 props 参数，不需要接收，直接通过 this.props.*** return &lt;div&gt; &lt;h1&gt;这是用 class 关键字创建的组件！--- { this.props.name }&lt;/h1&gt; &lt;p&gt; { this.state.msg } &lt;/p&gt; &lt;/div&gt;; }} 这里的 Person 标签,就是 上面Person 类的一个实例对象 12345678const user = { name='zs' age=22 gender:'男'}//&lt;Person name={user.name} age={user.age}&gt;&lt;/Person&gt;&lt;Person {...user}&gt;&lt;/Person&gt; 两种创建组件方式的对比 注意：使用class关键字创建的组件，有自己的私有数据和生命周期函数 ​ 使用function创建的组件，只有props，没有自己的私有数据和生命周期函数 用构造函数创建出来的组件：专业的名字叫做“无状态组件” 用class关键字创建出来的组件：专业的名字叫做“有状态组件” 用构造函数创建出来的组件，和用class创建出来的组件，这两种不同的组件之间的本质区别就是：有无state属性有状态组件和无状态组件之间的本质区别就是：有无state属性 和 生命周期函数 组件中的 props 和 state/data 之间的区别 props 中的数据都是外界传递过来的 state/data 中的数据， 都是组件私有的（通过Ajax 获取回来的数据，一般都是私有数据） props 中的数据 都是只读的，不能重新赋值 state/data 中的数据，都是可读可写的 一个小案例，巩固有状态组件和无状态组件的使用通过for循环生成多个组件123456789101112131415161718192021222324252627282930313233343536import React from 'react'import ReactDOM from 'react-dom'function CmtItem(props){ return &lt;div&gt; &lt;h1&gt;评论人： {props.user}&lt;/h1&gt; &lt;h1&gt;评论内容： {props.content}&lt;/h1&gt; &lt;/div&gt;} class CmtList extends React.Component { constructor(){ super() this.state = { CommentList = [ { user: '张三', content: '哈哈，沙发' }, { user: '张三2', content: '哈哈，板凳' }, { user: '张三3', content: '哈哈，凉席' }, { user: '张三4', content: '哈哈，砖头' }, { user: '张三5', content: '哈哈，楼下山炮' } ] } } render(){ return &lt;div&gt; &lt;h1&gt; 这是评论列表组件&lt;/h1&gt; {this.state.CommentList.map(item =&gt; &lt;CmtItem {...item} key={item.id}&gt;&lt;/CmtItem&gt;)} &lt;/div&gt; }}// 调用render 函数渲染ReactDOM.render(&lt;div&gt; &lt;CmtList&gt;&lt;/CmtList&gt; &lt;/div&gt;, document.getElementById('app')) 注意：在webpack.config.js中配置 @ 代表绝对路径./src。 后面就不用 ./ 这种相对路径了 将父组件CmtList、子组件CmtItem抽离为.jsx文件 12345678import React from 'react'export default function CmtItem(props){ return &lt;div&gt; &lt;h1&gt;评论人： {props.user}&lt;/h1&gt; &lt;h1&gt;评论内容： {props.content}&lt;/h1&gt; &lt;/div&gt;} 1234567891011121314151617181920212223242526import React from 'react'// 導入 评论项子组件import CmtItem from '@/components/CmtItem'export default class CmtList extends React.Component { constructor(){ super() this.state = { CommentList = [ { user: '张三', content: '哈哈，沙发' }, { user: '张三2', content: '哈哈，板凳' }, { user: '张三3', content: '哈哈，凉席' }, { user: '张三4', content: '哈哈，砖头' }, { user: '张三5', content: '哈哈，楼下山炮' } ] } } render(){ return &lt;div&gt; &lt;h1&gt; 这是评论列表组件&lt;/h1&gt; {this.state.CommentList.map(item =&gt; &lt;CmtItem {...item} key={item.id}&gt;&lt;/CmtItem&gt;)} &lt;/div&gt; }} 123456789import React from 'react'import ReactDOM from 'react-dom'import CmtList from '@/components/CmtList'// 调用render 函数渲染ReactDOM.render(&lt;div&gt; &lt;CmtList&gt;&lt;/CmtList&gt; &lt;/div&gt;, document.getElementById('app')) style样式使用CSS模块化 可以在webpack.config.js中为css-loader启用模块化： 另外两种方法： 总结理解React中虚拟DOM的概念理解React中三种Diff算法的概念使用JS中createElement的方式创建虚拟DOM使用ReactDOM.render方法使用JSX语法并理解其本质掌握创建组件的两种方式理解有状态组件和无状态组件的本质区别理解props和state的区别 相关文章 React数据流和组件间的沟通总结 单向数据流和双向绑定各有什么优缺点？ 怎么更好的理解虚拟DOM? React中文文档 - 版本较低 React 源码剖析系列 － 不可思议的 react diff 深入浅出React（四）：虚拟DOM Diff算法解析 一看就懂的ReactJs入门教程（精华版） CSS Modules 用法教程 将MarkDown转换为HTML页面 win7命令行 端口占用 查询进程号 杀进程","link":"/2020/03/24/React-3/"},{"title":"React 4","text":"组件的生命周期 概念：在组件创建、到加载到页面上运行、以及组件被销毁的过程中，总是伴随着各种各样的事件，这些在组件特定时期，触发的事件，统称为 组件的生命周期； 组件生命周期分为三部分： 组件创建阶段：组件创建阶段的生命周期函数，有一个显著的特点：创建阶段的生命周期函数，在组件的一辈子中，只执行一次； componentWillMount: 组件将要被挂载，此时还没有开始渲染虚拟DOMrender：第一次开始渲染真正的虚拟DOM，当render执行完，内存中就有了完整的虚拟DOM了componentDidMount: 组件完成了挂载，此时，组件已经显示到了页面上，当这个方法执行完，组件就进入都了 运行中 的状态 组件运行阶段：也有一个显著的特点，根据组件的state和props的改变，有选择性的触发0次或多次； componentWillReceiveProps: 组件将要接收新属性，此时，只要这个方法被触发，就证明父组件为当前子组件传递了新的属性值；shouldComponentUpdate: 组件是否需要被更新，此时，组件尚未被更新，但是，state 和 props 肯定是最新的componentWillUpdate: 组件将要被更新，此时，尚未开始更新，内存中的虚拟DOM树还是旧的render: 此时，又要重新根据最新的 state 和 props 重新渲染一棵内存中的 虚拟DOM树，当 render 调用完毕，内存中的旧DOM树，已经被新DOM树替换了！此时页面还是旧的componentDidUpdate: 此时，页面又被重新渲染了，state 和 虚拟DOM 和 页面已经完全保持同步 组件销毁阶段：也有一个显著的特点，一辈子只执行一次； componentWillUnmount: 组件将要被卸载，此时组件还可以正常使用； vue中的生命周期图React Native 中组件的生命周期 defaultProps 在组件创建之前，会先初始化默认的props属性，这是全局调用一次，严格地来说，这不是组件的生命周期的一部分。在组件被创建并加载候，首先调用 constructor 构造器中的 this.state = {}，来初始化组件的状态。 React生命周期的回调函数总结成表格如下： Mounting： constructor() componentWillMount() render() componentDidMount() Updating： componentWillReceiveProps(nextProps) shouldComponentUpdate(nextProps, nextState) componentWillUpdate(nextProps, nextState) render() componentDidUpdate(prevProps, prevState) Unmounting： componentWillUnmount() 通过Counter计数器的小案例 - 了解生命周期函数 给组件设置默认属性： 1234/* 设置 默认属性值 */ static defaultProps = { initcount:0 // 如果外界没有传initcount值，那就初始化为0 } 给属性进行类型校验，需要先运行cnpm i prop-types --save 组件初始化时生命周期事件总结 componentWillMount： render： componentDidMount： 注意：在render函数中，不能调用setState()方法 通过原生的方式获取元素并绑定事件React中使用ref属性获取DOM元素引用使用React中的事件，绑定count自增组件运行中事件的对比 shouldComponentUpdate： componentWillUpdate： render： componentDidUpdate： 绑定this并传参的三种方式 在事件中绑定this并传参： bind 作用： 为前面的函数(handleMsg1)，修改函数内部的this指向，让函数内部的this，指向bind参数列表中的第一个参数 bind 和 call/apply 之间的区别： call/aplly 修改完this指向后，会立即调用前面的函数，但是bind只会修改this 指向， 并不会调用 注意：bind 中的第一个参数，是用来修改this指向的，第一个参数后面的所有参数，都会当作将来调用 前面函数时候的参数传递进去 12345678910&lt;input type=\"button\" value=\"在事件中绑定this并传参\" onClick={this.handleMsg1.bind(this, '🍕', '🍟')} /&gt;// 在事件中绑定this并传参handleMsg1(arg1, arg2) { console.log(this); // 此时this是个null this.setState({ msg: '在事件中绑定this并传参：' + arg1 + arg2 });} 在构造函数中绑定this并传参: 全局只bind一次，上面那种每次调用这个方法(this.handleMsg2),都要bind一次 12345678910111213 // 修改构造函数中的代码：// 注意：调用bind改变this指向后，bind函数调用的结果，有一个返回值。这个值，就是被改变this指向后的函数的应用// 注意：bind不会修改原函数的this指向 this.handleMsg2 = this.handleMsg2.bind(this, '🚗', '🚚'); &lt;input type=\"button\" value=\"在构造函数中绑定this并传参\" onClick={this.handleMsg2} /&gt; // 在构造函数中绑定this并传参 handleMsg2(arg1, arg2) { this.setState({ msg: '在构造函数中绑定this并传参：' + arg1 + arg2 }); } 用箭头函数绑定this并传参： 箭头函数 本身就是一个 匿名的 function函数 function默认的this，谁调用这个function，this就指向谁 但箭头函数 this指向 外层 上下文 123456789101112131415 &lt;input type=\"button\" value=\"用箭头函数绑定this并传参\" onClick={() =&gt; { this.handleMsg3('👩', '👰') }} /&gt; // 用箭头函数绑定this并传参 handleMsg3(arg1, arg2) { this.setState({ msg: '用箭头函数绑定this并传参：' + arg1 + arg2 }); }// ----------------------------------------------------------------- // handleMsg3 = (arg1, arg2) =&gt; { this.setState({ msg: '用箭头函数绑定this并传参：' + arg1 + arg2 }); } 绑定文本框与state中的值 在Vue.js中，默认可以通过v-model指令，将表单控件和我们的data上面的属性进行双向数据绑定，数据变化和页面之间的变化是同步的！ 在React.js中，默认没有提供双向数据绑定这一功能，默认的，只能把state之上的数据同步到界面的控件上，但是不能默认实现把界面上数据的改变，同步到state之上，需要程序员手动调用相关的事件，来进行逆向的数据传输！ 绑定文本框和state的值： 123456789{/*只要将value属性，和state上的状态进行绑定，那么，这个表单元素就变成了受控表单元素，这时候，如果没有调用相关的事件，是无法手动修改表单元素中的值的*/}&lt;input style={{ width: '100%' }} ref=\"txt\" type=\"text\" value={this.state.msg} onChange={this.handleTextChange} /&gt;// 这是文本框内容改变时候的处理函数handleTextChange = () =&gt; { this.setState({ msg: this.refs.txt.value });} 注意 setState的一个问题： 在 setState， 只会把 对应的 state 状态更新，而不会 覆盖其他的state状态 this.setState 方法的执行 是异步的 12345678// 保存最新的state状态值，在保存的时候，是异步地进行保存的，所以，如果想要获取最新的，刚刚保存的那个状态，需要通过回掉函数的形式去获取最新statethis.setState({ msg: this.refs.txt.value // msg: e.target.value}, function () { // 获取最新的state状态值 console.log(this.state.msg);}); 发表评论案例扩展context特性记住一串单词组合getChildContextTypes前3个、后3个、后两个一个方法、两个静态属性 相关文章类型校验Animation Add-Ons","link":"/2020/03/26/React-4/"},{"title":"The farewell","text":"纽约一声大喝，惊扰长春飞鸟 YOU THINK ONE’S LIFE BELONGS TO ONESELF.","link":"/2021/03/09/The-farewell/"},{"title":"TypeScript01","text":"TypeScript 基础 Typescript 是微软推出的一门语言，是JavaScript的超集，包含ES567 新增了类型系统和完整的面向对象 第一章 TypeScript 基础01.TypeScript 环境安装 需要一个工具，将ts代码转换为浏览器或者nodejs识别的js代码，就需要ts环境（npm，nodejs的包管理器，用npm下载ts环境；网上下载安装nodejs，cmd node -v 查看）-&gt;cmd中 tsc -v 查看 全局安装： npm i -g typescript 校验typescript： tsc -v tsc的作用：负责将ts代码转为浏览器、nodejs识别的js代码 第一个ts程序 在后缀名为.ts文件中写typescript代码 使用tsc工具将typescript代码编译为浏览器、nodejs识别的js代码 在浏览器或者nodejs中执行js代码 ts -&gt; js -&gt; html scprit标签引入 在nodejs中执行typescript代码 执行tsc转换过后的js代码 node xxx.js ts-node ： 自动将ts代码转换为js代码，并将其在nodejs中执行 安装 npm i -g ts-node 使用 ts-node xxx.ts文件名 vscode配置自动编译（功能同4） tsc –init 生成tsconfig.json 改”outDir”:’./js’ 终端-运行任务-监视tsconfig.json 02. TypeScript 数据类型 | 变量 在JavaScript中，变量中可以存储任意类型的数据 var a = 10； a = “jack” ； a=true； 但是在TS语法规定：在声明变量的时候，必须制定变量的类型 声明变量的语法： let 变量名：变量类型 let age： number let myName： String 变量的类型一旦指定后，这个变量只能存储这个类型的数据 age = 18； 这样可以的 age = “jack” 错误 -&gt; 因为上面age指定了类型为number 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647var flag: boolean = trueflag = falseconsole.log(flag)var str: string = ''str = '12300'console.log(str)var arr:number[]=[11, 22, 33]console.log(arr)var arr2:Array&lt;number&gt;=[33,22,11]console.log(arr2)var arr3:string[]=['1','2str','3str']console.log(arr3)var arr4:object[]=[{name:'hall',age:'18'},{name:'xun',age:'19'}]console.log(arr4)// 元组类型var arr5:[number,string]=[123,'this is str']console.log(arr5)// 枚舉类型，使用单词就能够知道单纯的数字表示什么意思。易读enum Flag {success=1,error=2}let s:Flag=Flag.successconsole.log(s)// 任意类型var num:any=123num='str'num=true// undefined null 类型var a:undefineda=undefinedvar b:nullb=nullvar c:never// c='122' 报错 c是never类型，从不使用类型// 抛出异常，不常用c=(()=&gt;{ throw new Error('错误')})()","link":"/2020/03/17/TypeScript01/"},{"title":"TypeScript03","text":"TypeScript中的类（上） es5里面的类 最简单的类 1234567function Person() { this.name = 'xiaoyi' this.age = 20}var p = new Person()console.log(p)console.log(p.name) 构造函数和原型链里面增加方法 123456789101112131415161718function Person() { this.name = 'xiaoyi' /*属性*/ this.age = 20 this.run = function() { /*实例方法*/ console.log(this.name + '在运动') }}Person.prototype.sex = '男' //在原型链上添加一个方法,原型链上面的属性会被多个实例共享Person.prototype.work = function() { console.log(this.name + '在工作')}var p = new Person()console.log(p.name)console.log(p.sex)p.run()p.work() 类里面的静态方法 es5里面的继承，对象冒充实现继承, 原型鏈加对象冒充的组合继承模式 1234567891011121314151617181920212223function Person() { this.name = 'xiaoyi' /*属性*/ this.age = 20 this.run = function() { /*实例方法*/ console.log(this.name + '在运动') } } Person.prototype.sex = '男' //在原型链上添加一个方法,原型链上面的属性会被多个实例共享 Person.prototype.work = function() { console.log(this.name + '在工作') } var p = new Person() // p.work() // web类继承Person类 原型链加对象冒充的组合继承模式 function Web() { Person.call(this) /*改变this指向，对象冒充可以继承构造函数里面的属性和方法*/ } var w = new Web() w.run() /*对象冒充可以继承构造函数里面的属性和方法*/ w.work() /*但不能继承原型链上的属性和方法*/ es5里面的继承，原型链实现继承 123456789101112131415161718function Person() { this.name = 'xiaoyi' /*属性*/ this.age = 20 this.run = function() { /*实例方法*/ console.log(this.name + '在运动') }}Person.prototype.sex = '男'Person.prototype.work = function() { console.log(this.name + '在工作')}var p = new Person()function Web() {}Web.prototype = new Person() /*原型链实现继承*/var w = new Web()w.run()w.work() 原型链实现继承的 问题 12345678910111213141516171819202122function Person(name, age) { this.name = name this.age = age this.run = function() { /*实例方法*/ console.log(this.name + '在运动') }}Person.prototype.sex = '男'Person.prototype.work = function() { console.log(this.name + '在工作')}var p = new Person('xiaxa', 25)p.run()function Web(name, age) {}Web.prototype = new Person() /*原型链实现继承*/var w = new Web('xaxaxaxaxa', 26) /*实例化子类的时候，没法给父类传参*/w.run()w.work() 原型链加构造函数的组合继承模式 123456789101112131415161718192021222324252627 function Person(name, age) {​ this.name = name​ this.age = age​ this.run = function() { /*实例方法*/​ console.log(this.name + '在运动')​ } } Person.prototype.sex = '男' Person.prototype.work = function() {​ console.log(this.name + '在工作') } var p = new Person('xiaxa', 25) p.run() // web类继承Person类 原型链加对象冒充的组合继承模式 function Web(name, age) {​ Person.call(this, name, age) /*对象冒充继承，实例化子类可以给父类传参*/ } Web.prototype = new Person() /*原型链实现继承*///Web.prototype = Person.prototypr /*也可以*/ var w = new Web('lily', 26) /*实例化子类的时候，没法给父类传参*/ w.run() w.work()","link":"/2020/03/18/TypeScript03/"},{"title":"TypeScript02","text":"TypeScript中的函数 1. 函数的定义1.1. es5定义函数的方法 12345678//函数声明function run () { return 'run'}// 匿名函数 -&gt; 没有函数名，直接返回为变量run2var run2 = function(){ return 'run2'}1.2. TS中定义函数的方法 123456789function run():string{ return '123'}// 匿名函数var fun2 = function():number { return 123321}console.log(fun2()) 2. 函数的传参2.1. ts中定义方法传参 —&gt; ``模板字符拼接 es6 12345678910function getInfo(name:string,age:number):string{ return `${name}---${age}`}console.log(getInfo('xiaoyi',18))var getInfo2 = function(name:string,age:number):string{ return `${name}---${age}`}console.log(getInfo2('xiaoyi',22)) 2.2. 没有返回值的方法 1234function runddd(): void{ console.log('runddd')}runddd() 3.1. es5中，方法的实参和形参可以不一样，但是ts中必须一样，如果不一样，就需要配置可选参数 12345678910function getInfo(name:string,age?:number):string{ if(age){ return `${name}---${age}` }else { return `${name}---年龄保密` }}alert(getInfo('xiaoyi',20))// 后面加个？就是可选参数// 注意：可选参数必须配置到参数的最后面 -&gt;即如果age是可以选参数，那么age必须在name后面，即最后面 默认参数 es5里面没法设置默认参数，es6和ts中都可以设置默认参数 直接在name:string=’xiaoyi’ 在声明参数的时候后面等于一下默认值就可以 剩余函数 123456789101112131415function sum(a:number,b:number,c:number,d:number){return a+b+c+d}console.log(sum(1,2,3,4))// 三点运算符es6 接收形参传过来的值function sum2(...result:number[]):number{var sum = 0;result.forEach(element =&gt; {sum = sum+element});return sum}console.log(sum2(1,2,3,4)) 函数重载 Java中方法的重载：重载指的是两个或两个以上同名函数，但它们的参数不一样，这时候会出现重载的情况 typescript中的重载：通过为同一个函数提供多个函数类型定义来试下多种功能的目的 es5中出现同名方法,下面的会替换上面的方法 TS中： 123456789function getInfo(name:string):stringfunction getInfo(age:number):stringfunction getInfo(str:any):any if(typeof str === 'string'){ return '我叫'+str }else{ return '我的年龄是'+str }getInfo('小易') √ 箭头函数 es6 :this指向问题 箭头函数里面的this指向上下文","link":"/2020/03/18/TypeScript02/"},{"title":"django搭建","text":"搭建django的一些坑 1. 下载安装python3.4以上新版python下载后自带pip，pip根据提示自我更新 2. 用python 的pip管理器去下载django注意pip 和 django 和python 的版本 注意 pip 自我更新 和下载django的时候，报错重来，多下几次。 3. 配置django环境变量在path中加入两个 一个是到script 一个是到bin 4. 下载安装pycharm社区版（官网）目前双击打不开，用cmd可以输入pycharm打开，命令不能关 5. pycharm 设置背景颜色 字体大小settings里面的 6. project interpreter在settings -&gt; Project 中添加 python 7. django项目要添加python.exe8. 在下面 的 Terminal终端中执行python manage.py runserver 开启服务器，django自带一个小型服务器，自动开启8000端口号。可在settings文件中更改 9. python 3.x和2.x两个版本是由差距的，会影响django还有一些依赖插件比如pymysql是3.x用的 10. 接口测试时Forbidden (CSRF cookie not set.)可以去settings里面 MIDDLEWARE = [ 那个csrf. ] 注释掉 123456789101112131415161718import jsonfrom django.http import HttpResponse # Create your views here.from django.views.decorators.csrf import csrf_exempt @csrf_exempt def my_api(request): dic = {} if request.method == 'GET': dic['message'] = 0 return HttpResponse(json.dumps(dic)) else: dic['message'] = '方法错误' return HttpResponse(json.dumps(dic, ensure_ascii=False)) # 这里是views里面的一个如何返回类似json文件的例子 # 这样 就可以 简单的实现写views 不用管渲染的部分 11. ajax 简单传值 12. Django 中 request方法request.session 123请求的路径，这里的路径是指相对路径，也就是说一个登陆后台页面的请求：http:``/``/``127.0``.``0.1``:``8000``/``admin 的路径是 ``/``admin获取完整路径（包括参数）：HttpRequest.get_full_path()获取绝对url： HttpRequest.bulid_absolute_uri(location) 此参数默认为完整路径 request.encoding 1请求提交的数据的编码方式 request.session 12request.session 获取的是一个类似于字典的对象，可以进行读取写入操作，常用来保存一些数据来实现会话跟踪技术。 因为 HTTP 是一个无状态，不连续的协议。如果想让服务器记住当前的访问对象，就需要记录请求者的一些信息来达到这个目的。# 设置session``request.session[``&quot;name&quot;``] ``=` `&quot;root&quot;``# 获取session``name ``=` `request.sessin[``&quot;name&quot;``] django会默认为session使用json序列化。json序列化只能序列化一些基本数据类型，如数字，字符串，列表等。所以session不能直接存储对象.可以简单的在settings中添加 SESSION_SERIALIZER = “django.contrib.sessions.serializers.PickleSerializer” request.method 请求方式POST/GET 13. request获取数据request.body 请求的主体，返回一个字符串 request.data 请求数据部分，返回一个字典对象，其他和request.body很想 request.POST 获取post方式表单中提交的数据 request.POST[“username”] request.POST.get（“username”） request.GET 获取get方式表单中或url提交的数据 request.GET[“username”] request.GET.get（“username”） 14. postman请求请求post时，在body里面写参数！！ 请求get时，在params里面写参数！！","link":"/2020/04/03/django%E6%90%AD%E5%BB%BA/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 自定义样式Hexo -&gt; source -&gt; _data -&gt; styles.styl 开发者模式调试样式，然后复制样式名，粘贴到这里来，就可以覆盖原来的样式","link":"/2020/06/24/hello-world/"},{"title":"Typora常用快捷键","text":"Typora编写markdown快捷键 无序列表：输入-之后输入空格 有序列表：输入数字+“.”之后输入空格 任务列表：-[空格]空格 文字 标题：ctrl+数字 ctrl+数字 表格：ctrl+t 生成目录：[TOC]按回车 选中一整行：ctrl+l 选中单词：ctrl+d 选中相同格式的文字：ctrl+e 跳转到文章开头：ctrl+home 跳转到文章结尾：ctrl+end 搜索：ctrl+f 替换：ctrl+h 引用：输入&gt;之后输入空格 引用格式 代码块：ctrl+alt+k 1var a = 'hello' 加粗：ctrl+b 倾斜：ctrl+i 下划线：ctrl+u 删除线：alt+shift+5 插入图片：直接拖动到指定位置即可或者ctrl+shift+i 也可以右击插入图片 插入链接：ctrl+k","link":"/2020/02/16/Typora%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"title":"mongodb","text":"Mongodb MongoDB是一个基于分布式文件存储的数据库，由C++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。 在node.js中开启mongodb mongod –dbpath 存放data\\db的路径 （F:/mongodb/data/db） node.js中连接数据库，用mongoose model里面的 var mongoose = require(‘mongoose’) // 连接数据库,只需连接一次mongoose.connect(‘mongodb://localhost/blog’) var Schema = mongoose.Schema var userSchema = new Schema({ email: { type: String, required: true },……数据集合","link":"/2020/02/18/mongodb%E7%9B%B8%E5%85%B3/"},{"title":"jQuery","text":"jquery基础整合 学习文档转自黑马教程 使用javascript开发过程中，有许多的缺点： 查找元素的方法单一，麻烦。 遍历数组很麻烦，通常要嵌套一大堆的for循环。 有兼容性问题。 想要实现简单的动画效果，也很麻烦 代码冗余。 体验jquery的使用123456789101112131415/** 1. 查找元素的方法多种多样，非常灵活* 2. 拥有隐式迭代特性，因此不再需要手写for循环了。* 3. 完全没有兼容性问题。* 4. 实现动画非常简单，而且功能更加的强大。* 5. 代码简单、粗暴。* */$(document).ready(function () { $(\"#btn1\").click(function () { $(\"div\").show(200); }); $(\"#btn2\").click(function () { $(\"div\").text(\"我是内容\"); });}); jquery到底是什么 jQuery的官网 http://jquery.com/jQuery就是一个js库，使用jQuery的话，会比使用JavaScript更简单。 What is jQuery? 123456jQuery is a fast, small, and feature-rich JavaScript library. It makes things like HTML document traversal and manipulation, event handling, animation, and Ajax much simpler with an easy-to-use API that works across a multitude of browsers. With a combination of versatility and extensibility, jQuery has changed the way that millions of people write JavaScript. js库：把一些常用到的方法写到一个单独的js文件，使用的时候直接去引用这js文件就可以了。（animate.js、common.js） 我们知道了，jQuery其实就是一个js文件，里面封装了一大堆的方法方便我们的开发，其实就是一个加强版的common.js，因此我们学习jQuery，其实就是学习jQuery这个js文件中封装的一大堆方法。 jquery的版本问题 官网下载地址：http://jquery.com/download/jQuery版本有很多，分为1.x 2.x 3.x1.x和2.x版本jquery都不再更新版本了，现在只更新3.x版本。 大版本分类： 1.x版本：能够兼容IE678浏览器 2.x版本：不能兼容IE678浏览器 3.x版本：不能兼容IE678浏览器，更加的精简（在国内不流行，因为国内使用jQuery的主要目的就是兼容IE678） 关于压缩版和未压缩版： jquery-1.12.4.min.js:压缩版本，适用于生产环境，因为文件比较小，去除了注释、换行、空格等东西，但是基本没有颗阅读性。 jquery-1.12.4.js:未压缩版本，适用于学习与开发环境，源码清晰，易阅读。 jquery的入口函数使用jQuery的三个步骤： 引入jQuery文件 入口函数 功能实现 关于jQuery的入口函数： 12345678//第一种写法$(document).ready(function() { });//第二种写法$(function() { }); jQuery入口函数与js入口函数的对比： JavaScript的入口函数要等到页面中所有资源（包括图片、文件）加载完成才开始执行。 jQuery的入口函数只会等待文档树加载完成就开始执行，并不会等待图片、文件的加载。 jq对象和dom对象(重要) DOM对象：使用JavaScript中的方法获取页面中的元素返回的对象就是dom对象。 jQuery对象：jquery对象就是使用jquery的方法获取页面中的元素返回的对象就是jQuery对象。 jQuery对象其实就是DOM对象的包装集包装了DOM对象的集合（伪数组） DOM对象与jQuery对象的方法不能混用。 DOM对象转换成jQuery对象：【联想记忆：花钱】 12var $obj = $(domObj);// $(document).ready(function(){});就是典型的DOM对象转jQuery对象 jQuery对象转换成DOM对象： 12345var $li = $(\"li\");//第一种方法（推荐使用）$li[0]//第二种方法$li.get(0) jquery选择器什么是jQuery选择器 jQuery选择器是jQuery为我们提供的一组方法，让我们更加方便的获取到页面中的元素。注意：jQuery选择器返回的是jQuery对象。 jQuery选择器有很多，基本兼容了CSS1到CSS3所有的选择器，并且jQuery还添加了很多扩展性的选择器。【查看jQuery文档】 jQuery选择器虽然很多，但是选择器之间可以相互替代，就是说获取一个元素，你会有很多种方法获取到。所以我们平时真正能用到的只是少数的最常用的选择器。 基本选择器 名称 用法 描述 ID选择器 $(“#id”); 获取指定ID的元素 类选择器 $(“.class”); 获取同一类class的元素 标签选择器 $(“div”); 获取同一类标签的所有元素 并集选择器 $(“div,p,li”); 使用逗号分隔，只要符合条件之一就可。 交集选择器 $(“div.redClass”); 获取class为redClass的div元素 总结：跟css的选择器用法一模一样。 层级选择器 名称 用法 描述 子代选择器 $(“ul&gt;li”); 使用&gt;号，获取儿子层级的元素，注意，并不会获取孙子层级的元素 后代选择器 $(“ul li”); 使用空格，代表后代选择器，获取ul下的所有li元素，包括孙子等 总结：跟css的选择器用法一模一样。 过滤选择器 名称 用法 描述 :eq（index） $(“li:eq(2)”).css(“color”, ”red”); 获取到的li元素中，选择索引号为2的元素，索引号index从0开始。 :odd $(“li:odd”).css(“color”, ”red”); 获取到的li元素中，选择索引号为奇数的元素 :even $(“li:even”).css(“color”, ”red”); 获取到的li元素中，选择索引号为偶数的元素 总结：这类选择器都带冒号 筛选选择器(方法) 名称 用法 描述 children(selector) $(“ul”).children(“li”) 相当于$(“ul&gt;li”)，子类选择器 find(selector) $(“ul”).find(“li”); 相当于$(“ul li”),后代选择器 siblings(selector) $(“#first”).siblings(“li”); 查找兄弟节点，不包括自己本身。 parent() $(“#first”).parent(); 查找父亲 eq(index) $(“li”).eq(2); 相当于$(“li:eq(2)”),index从0开始 next() $(“li”).next() 找下一个兄弟 prev() $(“li”).prev() 找上一次兄弟 总结：筛选选择器的功能与过滤选择器有点类似，但是用法不一样，筛选选择器主要是方法。 【案例：下拉菜单】【案例：突出展示】【案例：手风琴】【案例：淘宝精品】 元素设置样式设置12345678910/*1.设置一个样式*///两个参数 设置的样式属性,具体样式$('li').css('color','red');//传入对象（设置的样式属性:具体样式）$('li').css({'color':'red'});/*2.设置多个样式*/$('li').css({ 'color':'green', 'font-size':'20px'}); 类名设置12345678/*1.添加一个类*/$('li').addClass('now');/*2.删除一个类*/$('li').removeClass('now');/*3.切换一个类 有就删除没有就添加*/$('li').toggleClass('now');/*4.匹配一个类 判断是否包含某个类 如果包含返回true否知返回false*/$('li').hasClass('now'); 对应案例：案例-《tab切换》 属性设置1234567891011/*1.获取属性*/$('li').attr('name');/*2.设置属性*/$('li').attr('name','tom');/*3.设置多个属性*/$('li').attr({ 'name':'tom', 'age':'18'});/*4.删除属性*/$('li').removeAttr('name'); 对应案例：案例-《美女相册》 prop方法12345/*对于布尔类型的属性，不要attr方法，应该用prop方法 prop用法跟attr方法一样。*/$(\"#checkbox\").prop(\"checked\");$(\"#checkbox\").prop(\"checked\", true);$(\"#checkbox\").prop(\"checked\", false);$(\"#checkbox\").removeProp(\"checked\"); 对应案例：案例-《表格全选》 动画基本动画12345678910/*注意：动画的本质是改变容器的大小和透明度*//*注意：如果不传参数是看不到动画*//*注意：可传入特殊的字符 fast normal slow*//*注意：可传入数字 单位毫秒*//*1.展示动画*/$('li').show();/*2.隐藏动画*/$('li').hide();/*3.切换展示和隐藏*/$('li').toggle(); 滑入滑出1234567/*注意：动画的本质是改变容器的高度*//*1.滑入动画*/$('li').slideDown();/*2.滑出动画*/$('li').slideUp();/*3.切换滑入滑出*/$('li').slideToggle(); 对应案例：案例-《下拉菜单》 淡入淡出12345678/*注意：动画的本质是改变容器的透明度*//*1.淡入动画*/$('li').fadeIn();/*2.淡出动画*/$('li').fadeOut();/*3.切换淡入淡出*/$('li').fadeToggle();$('li').fadeTo('speed','opacity'); 对应案例：案例-《轮播图》 自定义动画123456789101112/** 自定义动画* 参数1：需要做动画的属性* 参数2：需要执行动画的总时长* 参数3：执行动画的时候的速度* 参数4：执行动画完成之后的回调函数* */$('#box1').animate({left:800},5000);$('#box2').animate({left:800},5000,'linear');$('#box3').animate({left:800},5000,'swing',function () { console.log('动画执行完成');}); 对应案例：案例-《手风琴菜单》 动画队列12345678/*jQuery中有个动画队列的机制。当我们对一个对象添加多次动画效果时后添加的动作就会被放入这个动画队列中， 等前面的动画完成后再开始执行。可是用户的操作往往都比动画快， 如果用户对一个对象频繁操作时不处理动画队列就会造成队列堆积，影响到效果。*/ stop使用12345678910/*1.停止当前动画 如果动画队列当中还有动画立即执行*///$('div').stop();/*2.和stop()效果一致 说明这是默认设置*///$('div').stop(false,false);/*3.停止当前动画 清除动画队列*///$('div').stop(true,false);/*4.停止当前动画并且到结束位置 清除了动画队列*///$('div').stop(true,true);/*5.停止当前动画并且到结束位置 如果动画队列当中还有动画立即执行*/$('div').stop(false,true); 对应案例：案例-《音乐导航》对应案例：案例-《工具栏》 节点操作创建节点12/*创建节点*/var $a = $('&lt;a href=\"http://www.baidu.com\" target=\"_blank\"&gt;百度1&lt;/a&gt;'); 克隆节点12/*如果想克隆事件 false true克隆事件*/var $cloneP = $('p').clone(true); 添加&amp;移动节点1234567891011/*追加自身的最后面 传对象和html格式代码*/$('#box').append('&lt;a href=\"http://www.baidu.com\" target=\"_blank\"&gt;&lt;b&gt;百度3&lt;/b&gt;&lt;/a&gt;');$('#box').append($('a'));/*追加到目标元素最后面 传目标元素的选择器或者对象*/$('&lt;a href=\"http://www.baidu.com\" target=\"_blank\"&gt;&lt;b&gt;百度3&lt;/b&gt;&lt;/a&gt;').appendTo($('#box'));$('a').appendTo('#box');prepend();prependTo();after();before(); 删除节点&amp;清空节点123456/*1.清空box里面的元素*//* 清理门户 */$('#box').empty();/*2.删除某个元素*//* 自杀 */$('#box').remove(); 【案例-《弹幕》】 jQuery特殊属性操作val方法 val方法用于设置和获取表单元素的值，例如input、textarea的值 1234//设置值$(\"#name\").val('张三');//获取值$(\"#name\").val(); html方法与text方法 html方法相当于innerHTML text方法相当于innerText 123456789//设置内容$('div').html('&lt;span&gt;这是一段内容&lt;/span&gt;');//获取内容$('div').html()//设置内容$('div').text('&lt;span&gt;这是一段内容&lt;/span&gt;');//获取内容$('div').text() 区别：html方法会识别html标签，text方法会那内容直接当成字符串，并不会识别html标签。 width方法与height方法 设置或者获取高度 1234//带参数表示设置高度$('img').height(200);//不带参数获取高度$('img').height(); 获取网页的可视区宽高 1234//获取可视区宽度$(window).width();//获取可视区高度$(window).height(); scrollTop与scrollLeft 设置或者获取垂直滚动条的位置 1234//获取页面被卷曲的高度$(window).scrollTop();//获取页面被卷曲的宽度$(window).scrollLeft(); offset方法与position方法 offset方法获取元素距离document的位置，position方法获取的是元素距离有定位的父元素的位置。 1234//获取元素距离document的位置,返回值为对象：{left:100, top:100}$(selector).offset();//获取相对于其最近的有定位的父元素的位置。$(selector).position(); jQuery事件机制 JavaScript中已经学习过了事件，但是jQuery对JavaScript事件进行了封装，增加并扩展了事件处理机制。jQuery不仅提供了更加优雅的事件处理语法，而且极大的增强了事件的处理能力。 jQuery事件发展历程(了解)简单事件绑定&gt;&gt;bind事件绑定&gt;&gt;delegate事件绑定&gt;&gt;on事件绑定(推荐) 简单事件注册 123click(handler) //单击事件mouseenter(handler) //鼠标进入事件mouseleave(handler) //鼠标离开事件 缺点：不能同时注册多个事件 bind方式注册事件 12345//第一个参数：事件类型//第二个参数：事件处理程序$(\"p\").bind(\"click mouseenter\", function(){ //事件响应方法}); 缺点：不支持动态事件绑定 delegate注册委托事件 123456// 第一个参数：selector，要绑定事件的元素// 第二个参数：事件类型// 第三个参数：事件处理函数$(\".parentBox\").delegate(\"p\", \"click\", function(){ //为 .parentBox下面的所有的p标签绑定事件}); 缺点：只能注册委托事件，因此注册时间需要记得方法太多了 on注册事件 on注册事件(重点) jQuery1.7之后，jQuery用on统一了所有事件的处理方法。 最现代的方式，兼容zepto(移动端类似jQuery的一个库)，强烈建议使用。 on注册简单事件 12// 表示给$(selector)绑定事件，并且由自己触发，不支持动态绑定。$(selector).on( \"click\", function() {}); on注册委托事件 12// 表示给$(selector)绑定代理事件，当必须是它的内部元素span才能触发这个事件，支持动态绑定$(selector).on( \"click\",'span', function() {}); on注册事件的语法： 12345// 第一个参数：events，绑定事件的名称可以是由空格分隔的多个事件（标准事件或者自定义事件）// 第二个参数：selector, 执行事件的后代元素（可选），如果没有后代元素，那么事件将有自己执行。// 第三个参数：data，传递给处理函数的数据，事件触发的时候通过event.data来使用（不常使用）// 第四个参数：handler，事件处理函数$(selector).on(events,[selector],[data],handler); 事件解绑 unbind方式（不用） 12$(selector).unbind(); //解绑所有的事件$(selector).unbind(\"click\"); //解绑指定的事件 undelegate方式（不用） 12$( selector ).undelegate(); //解绑所有的delegate事件$( selector).undelegate( 'click' ); //解绑所有的click事件 off方式（推荐） 1234// 解绑匹配元素的所有事件$(selector).off();// 解绑匹配元素的所有click事件$(selector).off(\"click\"); 触发事件12$(selector).click(); //触发 click事件$(selector).trigger(\"click\"); jQuery事件对象jQuery事件对象其实就是js事件对象的一个封装，处理了兼容性。 12345678910//screenX和screenY 对应屏幕最左上角的值//clientX和clientY 距离页面左上角的位置（忽视滚动条）//pageX和pageY 距离页面最顶部的左上角的位置（会计算滚动条的距离）//event.keyCode 按下的键盘代码//event.data 存储绑定事件时传递的附加数据//event.stopPropagation() 阻止事件冒泡行为//event.preventDefault() 阻止浏览器默认行为//return false:既能阻止事件冒泡，又能阻止浏览器默认行为。 jQuery补充知识点链式编程 通常情况下，只有设置操作才能把链式编程延续下去。因为获取操作的时候，会返回获取到的相应的值，无法返回 jQuery对象。 1end(); // 筛选选择器会改变jQuery对象的DOM对象，想要回复到上一次的状态，并且返回匹配元素之前的状态。 【案例：五角星评分案例.html】 each方法 jQuery的隐式迭代会对所有的DOM对象设置相同的值，但是如果我们需要给每一个对象设置不同的值的时候，就需要自己进行迭代了。 作用：遍历jQuery对象集合，为每个匹配的元素执行一个函数 123// 参数一表示当前元素在所有匹配元素中的索引号// 参数二表示当前元素（DOM对象）$(selector).each(function(index,element){}); 【案例：不同的透明度.html】 多库共存 jQuery使用$作为标示符，但是如果与其他框架中的$冲突时，jQuery可以释放$符的控制权. 1var c = $.noConflict();//释放$的控制权,并且把$的能力给了c 插件常用插件 插件：jquery不可能包含所有的功能，我们可以通过插件扩展jquery的功能。 jQuery有着丰富的插件，使用这些插件能给jQuery提供一些额外的功能。 jquery.color.js animate不支持颜色的渐变，但是使用了jquery.color.js后，就可以支持颜色的渐变了。 使用插件的步骤 123//1. 引入jQuery文件//2. 引入插件（如果有用到css的话，需要引入css）//3. 使用插件 jquery.lazyload.js 懒加载插件 jquery.ui.js插件jQueryUI专指由jQuery官方维护的UI方向的插件。 官方API：http://api.jqueryui.com/category/all/ 其他教程：jQueryUI教程 基本使用: 1234//1. 引入jQueryUI的样式文件//2. 引入jQuery//3. 引入jQueryUI的js文件//4. 使用jQueryUI功能 使用jquery.ui.js手风琴菜单 制作jquery插件 原理：jquery插件其实说白了就是给jquery对象增加一个新的方法，让jquery对象拥有某一个功能。 12//通过给$.fn添加方法就能够扩展jquery对象$.fn. pluginName = function() {};","link":"/2020/03/27/jQuery/"},{"title":"npm相关","text":"npm的常用操作 指令 描述 npm init -y 初始化项目 会生成package.json和package-lock.json npm install 安装 ，简写：npm i npm i express mongoose 一次性安装多个模块 npm i -S 保存依赖 npm install -g cnpm –registry=https://registry.npm.taobao.org 安装全局cnpm，使用淘宝镜像 npm -v 查看npm的版本 npm install npm -g 用npm来安装最新的npm npm root 查看项目中模块所在的目录 npm root -g 查看全局安装的模块所在目录","link":"/2020/02/18/npm%E7%9B%B8%E5%85%B3/"},{"title":"vue基础--4小时","text":"vue基础快速复习 一、vue基础vue简介 javascript框架，比jquery库更强大； 更简单的DOM操作；（以前通过id获取元素，操作页面） 响应式数据驱动 第一个vue程序 选择环境：开发环境：学习阶段使用 ​ 生产环境：mini版，更轻 声明式渲染 123456789101112131415&lt;div id=\"app\"&gt;{{message}}&lt;/div&gt;&lt;!-- {{}} 是插值表达式--&gt;&lt;script&gt;new Vue({ el:\"#app\", data:{ message:\"哈哈\" }, methods:{ }})&lt;/script&gt; 其中 el：挂载点（不要挂载到html、body元素上，也不要挂载到单标签上；要挂载到双标签上&lt;p&gt;&lt;/p&gt;、&lt;div&gt;&lt;/div&gt;） data：数据对象 methods：方法 二、本地应用vue指令添加到html标签中，相当于给html标签；元素增加一个属性 内容绑定、事物绑定 v-text：只会解析为文本；改变里面所有的文本 v-html：内容中有html结构，会被解析为标签 v-on：绑定事件,可简写为@；@click = “”; @mouseenter=””; 123456789101112131415161718&lt;div id=\"app\"&gt;{{message}}&lt;/div&gt;&lt;input type=\"button\" value=\"单击\" @click=\"btn1\"&gt;&lt;script&gt;new Vue({ el:\"#app\", data:{ message:\"哈哈\" }, methods:{ btn1:function(){ this.message = \"嘻嘻嘻嘻！\", // 方法内部通过this，访问data中的数据 alert(\"单击，我被弹出！\") } }})&lt;/script&gt; 显示切换、属性绑定 v-show=“true/false”；布尔值；通过操纵样式；display:none；会导致重绘 v-show=”isShow” ；在vue实例中的data数据对象里面写 isShow:false v-if=“表达式/数据对象” ； 根据表达式的真假，切换元素的显示和隐藏（操作dom元素）；会导致重绘和重排 v-bind；设置单个元素的属性（比如 src title class） 比如说给图片增加属性就用 v-bind : src = “数据对象”；然后v-bind可以省略；:src, :title(鼠标悬停显示出信息), :class 列表循环、表单元素绑定 v-for；循环生成列表结构；通常和数组结合使用 v-for=”(item,index) in arr” index 是索引；其中arr也可以是复杂数组对象；item.name、item.age去访问 *v-on *补充（事件） 可以传参；@click=”add(2,5)”；后面对应方法加形参；@keyup.enter=“sayHi”；敲回车键时会执行sayHi方法 v-model 双向数据绑定，设置表单元素的值； input 、select 、checkbox 、textarea &lt;input type=”text” v-model=”msg”&gt;; data:{ msg:”双向绑定的数据” } 记事本v-for 渲染数组列表；根据数组形成列表结构 v-model 获取用户输入的数据； v-on 绑定事件，@keyup.enter=”add”回车，add方法中新增数据； ​ 删除数据：@click：”remove(index)”；方法中写：this.lists.splice(index,1) 三、网络应用ajax、promise 、.then、 axios","link":"/2021/04/16/vue%E5%9F%BA%E7%A1%80-4%E5%B0%8F%E6%97%B6/"},{"title":"vue搭建appweb","text":"webapp 外卖系统（移动端） ！（前言：学习Vue项目搭建流程，记录心得（部分筆記為課件）。学习视频 -&gt; https://www.bilibili.com/video/av49099807 1. 使用 vue-cli(脚手架)搭建项目 Vue-cli 是 vue 官方提供的用于搭建基于 vue+webpack+es6 项目的脚手架工具 在线文档:https://github.com/vuejs/vue-cli 操作: npm install -g vue-cli vue init webpack gshop cd gshop npm install npm run dev 访问: localhost:8080 2. 项目结构分析gshop |– build : webpack 相关的配置文件夹(基本不需要修改) |– config: webpack 相关的配置文件夹(基本不需要修改) |– index.js: 指定的后台服务的端口号和静态资源文件夹 |– node_modules |– src : 源码文件夹 |– main.js: 应用入口 js |– static: 静态资源文件夹 |– .babelrc: babel 的配置文件 |– .editorconfig: 通过编辑器的编码/格式进行一定的配置 |– .eslintignore: eslint 检查忽略的配置 |– .eslintrc.js: eslint 检查的配置 |– .gitignore: git 版本管制忽略的配置 |– index.html: 主页面文件 |– package.json: 应用包配置文件 |– README.md: 应用描述说明的 readme 文件 3. 编码测试与打包发布项目 编码测试 npm run dev 访问:http://localhost:8080 编码, 自动编译打包(HMR), 查看效果 打包发布 npm run build npm install -g serve serve dist 访问:http://localhost:5000 4. 項目源碼目錄設計 src api 与后台交互模块文件夹 common（asstes） 通用资源文件夹，如fonts/img/stylus (stylus: css预编译器，Sass/Less npminstallstylusstylus-loader–save-dev） components 非路由组件文件夹 filters 自定义过滤器模块文件夹 mock 模拟数据接口文件夹 pages 路由组件文件夹 router 路由器文件夹-&gt;index.js/router.js 暴露router给入口文件main.js store vuex相关模块文件夹 App.vue 应用组件 main.js 入口JS 记录props的详解：组件示例的作用域是孤立的，意味着不能（也不应该）在子组件的模板内直接引用父组件的数据。父组件的数据要通过prop才能下发到子组件中。 props是子组件访问父组件数据的唯一接口 一个组件可以直接在模板里面渲染data里面的数据（双大括号）。 子组件不能直接在模板里面渲染父元素的数据。 如果子组件想要引用父元素的数据，那么就在prop里面声明一个变量（比如a），这个变量就可以引用父元素的数据。然后在模板里渲染这个变量（前面的a），这时候渲染出来的就是父元素里面的数据。 slot的详解：给元素指定一个name后可以分发多个内容 一个简单的小例子： 1.父组件传递了todos数组给子组件 2.子组件通过props接受了数组数据，这里应该没有任何问题 3.子组件拿到数组后v-for渲染列表，并且通过 的方式，把数组内的每一个todo对象，传递给父组件 4.父组件通过slot-scope=”slotProps”的方式，接受todo对象，之后就可以通过slotProps.todo.xxx的方式来使用了 所以数据的流动经历了 父组件传递todos数组给子组件 子组件遍历todos数组，把里面的todo对象传递给父组件 Swiper左右滑动插件 npm i swiper -D 先下载 ——可以去官网查看html结构，这样写会有好的css样式 import Swiper from ‘swiper’ 阿里巴巴iconfontinconfont矢量标记图标。登录账号，选择图标添加购物车，生成网上链接，可以直接使用。使用方式 去官网看。 Svg图片可以做验证码 $router.back()&lt;a href=”javascript:” class=”go_back” @click=”$router.back()”&gt; 返回到之前的路由 $route 代表当前路由 postman创建集合，以便归类请求 封装ajax请求跨域问题的解决总结总结01 项目开发准备 项目描述 技术选型 API接口（接口文档 -&gt; postman 测接口） 从此项目学到什么 开启项目开发 使用脚手架创建项目 安装依赖 开发环境运行 生产环境打包与发布 搭建项目整体界面结构 stylus的理解和使用（结构化，变量，函数/minxin（混合 vue-router的理解和使用 router-view/router-link/keep-alive $router: 路由对象，包含一些操作路由的功能函数，来实现编程式导航（跳转路由） $route: 当前路由对象，一些当前路由信息数据的容器，path/meta/query/params 项目路由拆分 一般组件和导航路由组件 抽取组件 登录路由组件 后台项目 前后台交互 ajax请求库：axios ajax请求函数封装：axios + promise 接口请求函数封装，每个后台接口","link":"/2020/03/13/vue%E6%90%AD%E5%BB%BAappweb/"},{"title":"人工智能简介","text":"人工智能发展必备三要素 数据 算法 计算力 CPU、GPU对比： CPU主要适合I\\O密集型的任务 GPU主要适合计算密集型任务 人工智能和机器学习，深度学习的关系： 机器学习是人工智能的一个实现途径/分支 深度学习是机器学习的一个方法发展而来 人工智能主要分支： 计算机视觉（CV）是指机器感知环境的能力；物体检测和人脸识别是比较成功的研究领域 语音识别；说出来的语言并将其转换成对应文本。语音识别领域任然面临着声纹识别和【鸡尾酒效应】 文本挖掘/分类；用于理解、组织、分类结构化或非结构化文本文档。 机器翻译 机器人 机器学习工作流程： 获取数据 数据基本处理 特征工程 机器学习（模型训练） 模型评估 结果达到要求，上线服务 没有达标，重新执行上面步骤 数据简介：在数据集D中一般： 一行数据称为一个样本 一列数据称为一个特征（属性） 有些数据有目标值（标签值），有些数据没有目标值 特征工程： 特征提取 将任意数据（文本或图像）转换为可用于机器学习的数学特征 特征预处理 通过一些转换函数将数据 转换成更加适合算法模型 对的特征数据 过程 特征降维","link":"/2021/10/13/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%AE%80%E4%BB%8B/"},{"title":"webpack相关","text":"webpack 本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 1.项目构建工具，基于node.js开发出来的前端工具 2.webpack能够处理JS文件的相互依赖关系 3.webpack能处理JS的兼容问题，把高级的、浏览器不识别的语法转换为能识别的 *4. *webpack 默认只能打包处理 .js 后缀名类型的文件。像.png .vue无法处理，所以需要配置第三方的loader； (vue-cli 会自动配置webpack） 在项目中安装和配置webpack​ 1.1. 运行 npm install webpack webpack-cli -D 命令，安装webpack相关的包 ​ 1.2. 在项目根目录中，创建名为webpack.config.js的webpack配置文件 ​ 1.3. 在webpack的配置文件中，初始化如下基本配置： 123module.exports = { mode: 'development' // mode 用来指定构建模式 }​ 1.4.在package.json配置文件中scripts节点下，新增dev脚本如下： 123\"scripts\": {\"dev\": \"webpack\" // script 节点下的脚本，可以通过npm run 来执行}​ 1.5. 在终端运行 npm run dev 命令，启动webpack进行项目打包 （将index.js 打包为 main.js） ​ 1.6. 在index.html中可以引用输出文件main.js 配置打包的入口与出口webpack的4.x版本中默认约定： 打包的入口文件为 src -&gt; index.js 在这里import js、css资源 打包的输出文件为 dist -&gt; main.js 如果要修改，就在webpack.config.js配置文件中添加一些节点 1234567const path = require(path)entry: path.join(__dirname, './src/index.js'),output: { path: path.join(__dirname, './dist'),//输出文件路径 filename: 'bundle.js' // 输出文件的名称} 配置webpack的自动打包功能 运行 npm install webpack-dev-server -D 命令，安装支持项目自动打包的工具 修改package.json -&gt; scripts中的 dev 命令如下： 123\"scripts\": { \"dev\": \"webpack-dev-server\"} 将src -&gt; index.html 中，script脚本引用路径，改为“/bundle.js” 运行 npm run dev 命令，重新进行打包 （这里会自动在根目录中生成一个bundle.js，在内存中生成的，物理目录中看不到） 在浏览器中访问 8080,地址，查看自动打包效果 注意： webpack-dev-server 会启动一个实时打包的http服务器 webpack-dev-server 打包生成的输出文件，默认放到了项目根目录中，而且是虚拟的、看不见的 html-webpack-plugin生成的预览页面（写在前面， 运行 npm install html-webpack-plugin -D 命令，安装生成预览页面的插件 修改 webpack.config.js文件头部区域，添加如下配置信息： 1234567// 导入生成预览页面的插件，得到一个构造函数const HtmlWebpackPlugin = require('html-webpack-plugin')// 创建插件的实例对象 new出来const htmlPlugin = new HtmlWebpackPlugin({ template: './src/index.html', filename: 'index.html'}) 修改webpack.config.js文件中向外暴露的配置对象，新增如下配置节点： 1plugins:[ htmlPlugin ] // plugins數組是webpack打包期间会用到的一些插件列表 配置自动打包相关的参数1234567// package.json中配置// --open 打包完成后自动打开浏览器页面// --host 配置IP地址// --port 配置端口\"scripts\" : [ \"dev\": \"webpack-dev-server --open --host 127.0.0.1 --port 8888\"], loader打包非js模块​ loader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。 本质上，webpack loader 将所有类型的文件，转换为应用程序的依赖图（和最终的 bundle）可以直接引用的模块。 注意，loader 能够 import 导入任何类型的模块（例如 .css 文件），这是 webpack 特有的功能，其他打包程序或任务执行器的可能并不支持。我们认为这种语言扩展是有很必要的，因为这可以使开发人员创建出更准确的依赖关系图。 less-loader sass-loader url-loader 打包处理css文件 运行 npm i style-loader css-loader -D 命令，安装处理css文件的loader 在webpack.config.js的module -&gt; rules 数组中，添加loader： 123456// 所有第三方文件模块的匹配规则module: { rules: [ { test: /\\.css$/, use: ['style-loader', 'css-loader']} ]} 其中，test 表示匹配的文件类型，use表示对应要调用的loader 注意： use 数组中指定的loader 顺序是固定的 多个loader的调用顺序是：从后往前调用 打包处理less文件 运行 npm i less-loader less -D 命令 在webpack.config.js 的module -&gt; rules 数组中，添加loader: 123456// 所有第三方文件模块的匹配规则module: { rules: [ { test: /\\.less$/, use: ['style-loader', 'css-loader', 'less-loader']} ]} 打包处理sass文件 运行 npm i sass-loader node-sass -D 命令 在webpack.config.js 的module -&gt; rules 数组中，添加loader: 123456// 所有第三方文件模块的匹配规则module: { rules: [ { test: /\\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader']} ]} 配置postCSS 自动添加css的兼容前缀 运行 npm i postcss-loader autoprofixer -D 命令 在项目根目录中创建 postcss 的配置文件 postcss.config.js 12345const autoprofixer = require('autoprofixer')module.exports = { plugins:[autoprofixer]} 在webpack.config.js的module -&gt; rules 数组中，修改css的loader： 12345module: { rules: [ { test: /\\.css$/, use: ['style-loader', 'css-loader', 'postcss-loader']} ]} 打包样式表中的图片和文字文件 运行 npm i url-loader file-loader -D 命令 在webpack.config.js 的module -&gt; rules数组中，添加loader： 12345module: { rules: [ { test: /\\.jpg|png|gif|bmp|ttf|svg|woff|woff2$/, use:'url-loader?limit=16940'} ]} 其中？之后的是loader的参数项 limit 用来指定图片的大小，单位是字节（byte），只有小于limit大小的图片，才会被转为 base64 图片 打包处理js文件中的高级语法 安装babel转换器相关的包：npm i babel-loader @babel/core @babel/runtime -D 安装babel语法插件相关的包： npm i @babel/preset-env @babel/plugin-transform-runtime @babel/plugin-proposal-class-properties -D 在项目根目录中，创建babel配置文件，babel.config.js，并初始化基本配置： 1234module.exports = { presets: ['@babel/preset-env'] plugins: ['@babel/preset-env', '@babel/plugin-transform-runtime', '@babel/plugin-proposal-class-properties']} 在webpack.config.js的module -&gt; rules数组中，已添加loader规则： 1{ test: /\\.js$/, use:'babel-loader', exclude: /node_modules/} 其中，exclude为排除项，表示babel-loader不需要处理node_modules中的js文件 打包vue组件.vue文件，需要安装相关的loader npm i vue-loader vue-temlate-compiler -D 在webpack.config.js配置文件中，新增loader配置项 1{ test: /\\.vue$/, use: 'vue-loader' } 总结梳理webpack中如何使用vue 1.安装vue的包：npm i vue -S 2.由于在webpack中，推荐使用.vue这个组件模板文件定义组件，所以，需要安装 能解析这种文件的loader cnpm i vue-template-complier -D 3.在输出文件main.js中，导入vue模块 import Vue from ‘vue’ 4.定义一个.vue结尾的组件，其中，组件有三部分组成：template script style 5.使用import导入这个组件 6.创建vm的实例 var vm = new Vue（ {el: '#app', render: c=&gt; c(login) }) 7.在页面中创建一个id为app的div元素，作为我们vm实例要控制的区域","link":"/2020/03/12/webpack%E7%9B%B8%E5%85%B3/"},{"title":"yfd实习记录 1","text":"ok！这部分算是记录的序章，入职前的一些事情记录 pt1 投简历–面试5月11中午吃饭的时候，看到猿辅导的招聘暑期兼职，工资可观，回去准备准备了简历就投了。当天下午那边发回了邮件通知周四面试。收到面试通知，加了hr微信，这才去百度搜了搜猿辅导公司的位置，去b站搜了搜猿辅导面试辅导老师的一些情况，也大致了解了猿辅导面试环节中所问的问题还是比较格式化的。“自我介绍”，“对辅导老师的看法”，“面对一些问题时你会怎么做”，hr小姐姐说明了加班的必要性，关于续保的占比。我对加班没有异议，公司说13-21点，其实应该是12-22点，这个时间我也能接受。（据说续报期是9-24点） pt2 收到offer–租房周五的时候就收到暑期兼职offer，入职时间是6月3号，入职的时候签订实习的劳务合同（要扣20%的税，到手4200左右），没有岗前培训，有岗后9天的培训。重庆猿辅导公司在朝天门来福士办公区A座，我在大学城这边，因为要租房子，16号的时候就和朋友一起去那边逛了逛（办公区没有权限是进不去的-..-）。19号的时候，和其他同事合租到了房子，租的3个月短租，押一付一。房子就在轻轨站出口，离来福士也10分钟左右的步行，已经很近了。 pt3 packaging stuff这边毕业设计和论文的事情算是基本结束了。我打包了一些冬季的衣服回家，又在网上买了一些办公所需的小物品和生活小物品。过几天要去那边线下签一个东西，顺便拿到房子钥匙，还有桌子板凳配齐了没有，顺便带一些衣服过去放着，学校宿舍这边就等17号回来再陆陆续续搬走。 pt4 上知乎了解辅导老师性质说回之前面试猿辅导辅导老师的事情，我当时投简历的时候，其实已经有大概的感觉自己能过，只要自己认真准备面试问题，勇敢的去回答就好了。但真正收到offer，我才想到去真正了解辅导老师的性质，hr说70%的续报，其实很明显就是职业定位是销售性质占很大一部分。知乎上对于各大机构的辅导老师的吐槽我都大致看了看，优势就是薪资高，劣势就是工作时间长，压力很大，我暗自觉得我还是能撑住3个月的时间的。 pt5 抽卡去b站的塔罗占卜 事件结果那个抽过两次塔罗牌。关于前期能否进入状态：海神的女儿；关于三个月工作的感受：雪中的独角兽。两张牌都是好牌。","link":"/2021/05/24/yfd%E5%AE%9E%E4%B9%A0%E8%AE%B0%E5%BD%95-1/"},{"title":"yfd实习记录 2（转折）","text":"体检 + 5.28 所发生的事情 pt1 体检几天前，去沙坪坝爱康国宾医院体检，体检完成后，一健传回hr，体检费用140。 体检就是常规的体检。 pt2 5.28事件5月28日下午4点多，微信的入职群和租房群被解散，然后接到一个重庆那边的电话，说猿辅导业务已满，暂停招人（借口），让我自愿放弃入职。当时我就十分的气愤，拿到offer以后，公司要求的什么，我都做了，什么都准备好了，就在入职前几天，先把微信群解散，再一个个打电话引导性的让我们放弃入职，我当时就坚决不自愿放弃入职。公司单方面毁offer，造成我的时间和金钱的损失谁来赔偿？让我相互理解？真的狗！ 后来有个和我一起面试通过的小姐姐加了我微信，她是在小红书上看到的。再后来微博上面有几个人在发微博指控，就知道了是全国的猿辅导都在毁offer，hr一律不回复（有些还是回了，有些没回的可能也被开了）。后来加了全国的猿辅导维权群，里面有人提议打电话到总部去申述。第二天早上我就打电话过去申述，她那边询问我的情况和我的诉求，我就说能入职就入职，但我不放弃入职的机会！下午的时候北京那边又打来电话，又询问我的诉求，我也是说，因为一切都准备好了，这样一通电话就让我放弃入职是不可能的！欺负大学生吗？我说能入职尽量入职，到6月3号的时候，如果实在不能入职，我这边也在找另外的工作。 当天下午，收到第一次打电话让我放弃入职的那个电话号码打来，就说可以6月3号入职，说是岗位稀缺（借口），让我不要给其他人说可以入职的事情。 （因为出了这种事，所有的打工人都是受害者，所以打电话时我只是控诉了公司的这种不诚信，不透明的恶劣方式，其余的也表示无奈） pt3 气愤–冷静28号上午的时候还在举行双选会，28号下午就停止招人，明显的不是因为岗位需求减少的原因，而是有什么文件下达，这种国家层面的要求我们谁也不能说什么。所以在挂断第一通电话过后，回想了一下，我又打了过去，就仔细说明了我的诉求：能正常入职就正常入职，不能那就等到6月3号再说。29号 上午的时候，我们学校居然还有人在发猿辅导招聘的广告，我加了QQ，他说可以把简历给他，我就说了我的情况，他就不说话了，然后boss直聘上还在招人，还有在线下举办招聘会的情况，我就想说这是混乱了吗？我不想搞什么阴谋论。 那个群里面真的是鱼龙混杂，居然还有人说 “与其在这维权，不如抓紧时间找下一份工作”，这种人什么成分一目了然。被毁offer的甚至有春招过来的，推掉其他很多offer过来的，错过了黄金春招，然后听信一句不如抓紧时间？？ 28号-29号，因为房租的问题，我必须在那边找到实习或者兼职，我也投了作业帮、清北教育等，但这个形势下，估计也不会招人了。我在boss直聘上看了看其他职位，有工资不高，但比较轻松的。（这算是当时以及现在的备用选项）。 pt4 在线教育这种在线教育真的，在国家的红线徘徊，谁也想不到哪一天会崩塌，然后失业。只能说，冲！考公务员！ pt5 打工人真难今天5月31号，我就想尽早入职，然后培训。毕竟培训期间是有工资的，即使说培训完过后把我开除，这下我也有准备去找下家。","link":"/2021/05/31/yfd%E5%AE%9E%E4%B9%A0%E8%AE%B0%E5%BD%95-2%EF%BC%88%E8%BD%AC%E6%8A%98%EF%BC%89/"},{"title":"前端UI框架小总结","text":"收集前端UI框架 包括移动端 PC端的官网 移动端UI框架 Mint UI（饿了么团队）中文官网：http://mint-ui.github.io/#!/zh-cn 描述：基于vue的移动端UI框架基于vue GitHub地址：https://github.com/ElemeFE/mint-ui/ Weui（微信官方设计团队）描述：WeUI 为微信 Web 服务量身设计,是一套同微信原生视觉体验一致的基础样式库，由微信官方设计团队为微信 Web 开发量身设计，可以令用户的使用感知更加统一。 GitHub地址：https://github.com/weui/weui Pure中文官网：https://www.purecss.cn/描述：纯CSS美国雅虎公司出品的一组轻量级、响应式纯css模块，适用于任何Web项目。GitHub：https://github.com/yahoo/pure/ PC 端 UI框架 Element UI（饿了么团队）官方地址：http://element-cn.eleme.io/#/zh-CN描述：基于 Vue 2.0 的桌面端组件库GitHub：https://github.com/ElemeFE/element iView官网地址：https://www.iviewui.com/描述：一套基于 Vue.js 的高质量 UI 组件库。iView 是一套基于 Vue.js 的开源 UI 组件库，主要服务于 PC 界面的中后台产品。GitHub地址：https://github.com/iview/iview layui官方地址：http://www.layui.com/ 描述：更多是为服务端程序员量身定做，你无需涉足各种前端工具的复杂配置，只需面对浏览器本身，让一切你所需要的元素与交互，从这里信手拈来。 layui 兼容人类正在使用的全部浏览器（IE6/7除外），可作为 PC 端后台系统与前台界面的速成开发方案。 GitHub：https://github.com/sentsin/layui/ Bootstrap中文官网：http://www.bootcss.com/描述：简洁、直观、强悍的前端开发框架，让web开发更迅速、简单。 GitHub地址：https://github.com/twbs/bootstrap jQuery UI官方网址：http://jqueryui.com/","link":"/2020/04/01/%E5%89%8D%E7%AB%AFUI%E6%A1%86%E6%9E%B6%E5%B0%8F%E6%80%BB%E7%BB%93/"},{"title":"机器学习算法分类","text":"机器学习算法分类 根据 数据集 组成不同，可以把机器学习算法分为： 监督学习（分类、回归） 无监督学习（聚类） 半监督学习 强化学习 1 监督学习定义：输入数据是由输入特征值feature 和 目标值所组成 函数的输出(目标值)可以是一个连续的值（称为回归） 函数的输出(目标值)是有限个离散值（称为分类） 2 无监督学习定义：输入数据是由输入特征值组成，没有目标值 输入数据没有被标记，也没有确定的结果。样本数据类别未知； 需要根据样本间的相似性对样本集进行类别划分 3 半监督学习4 强化学习定义：实质是make decisions 问题，即自动进行决策，并且可以做连续决策。 主要包含五个元素：agent, action, reward, environment, observation； 强化学习的目标就是获得最多的累计奖励。 监督学习 强化学习 反馈映射 输出的是之间的关系，可以告诉算法什么样的输入对应着什么样的输出。 输出的是给机器的反馈 reward function，即用来判断这个行为是好是坏。 反馈时间 做了比较坏的选择会立刻反馈给算法。 结果反馈有延时，有时候可能需要走了很多步以后才知道以前的某一步的选择是好还是坏。 输入特征 输入是独立同分布的。（掷骰子） 面对的输入总是在变化，每当算法做出一个行为，它影响下一次决策的输入。 5 小结 In Out 目的 案例 监督学习 (supervised learning) 有标签 有反馈 预测结果 猫狗分类 房价预测 无监督学习 (unsupervised learning) 无标签 无反馈 发现潜在结构 “物以类聚，人以群分” 半监督学习 (Semi-Supervised Learning) 部分有标签，部分无标签 有反馈 降低数据标记的难度 强化学习 (reinforcement learning) 决策流程及激励系统 一系列行动 长期利益最大化 学下棋","link":"/2021/10/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB/"},{"title":"前端需要注意的SEO","text":"SEO (搜索引擎优化) 合理的title、description、keywords：搜索对着三项的权重逐个减小，title值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面title要有所不同；description把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面description有所不同；keywords列举出重要关键词即可 语义化的HTML代码，符合W3C规范：语义化代码让搜索引擎容易理解网页 重要内容HTML代码放在最前：搜索引擎抓取HTML顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取 重要内容不要用js输出：爬虫不会执行js获取内容 少用iframe：搜索引擎不会抓取iframe中的内容 非装饰性图片必须加alt 提高网站速度：网站速度是搜索引擎排序的一个重要指标","link":"/2020/03/29/%E5%89%8D%E7%AB%AF%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84SEO/"},{"title":"移动Web开发--flex布局","text":"flex弹性布局 操作改变，布局简单，移动端应用很广泛 :fallen_leaf: :balance_scale::ear_of_rice::honey_pot::horse_racing: display: flex justify-content: center|space-around flex: 1 自适应 平均分配 在移动端比float浮动好用很多 flex是flexible Box的缩写，意为弹性布局，用来为盒装模型提供最大的灵活性，任何一个容器都可以指定为flex布局 当我们为父盒子设为flex 布局后，子元素的float、clear和vertical-align属性将失效 伸缩布局 = 弹性布局 = 伸缩盒布局 = flex布局 采用flex布局的元素，成为flex容器，它的所有子元素自动成为容器成员，成为flex项目。 （通过给父盒子添加flex属性，来控制盒子的位置和排列方式） 常见父项属性 以下由6个属性是对父元素设置的 flex-direction：设置主轴的方向 属性值 说明 row （默认）从左到右 row-reverse 从右到左 column 从上到下 column-reverse 从下到上 justify-content：设置主轴上的子元素排列方式 注意：使用这个属性之前，一定要确定好主轴是哪个 属性值 说明 flex-start （默认）从头部开始 flex-end 从尾部开始排列，顺序是不变的 center 在主轴居中对齐（如果主轴是x轴则居中）最常用 space-around 平均剩余空间 space-between 先两边贴边 再平分剩余空间（重要） flex-wrap：设置子元素是否换行 注意：默认情况下，项目都排在一条线（轴）上，flex-wrap属性定义flex布局中默认是不换行的 属性值 说明 nowrap 默认值，不换行 wrap 换行 align-items：设置侧轴上的子元素排列方式（单行） 属性值 说明 flex-start （默认）从上到下 flex-end 从下到上 center 挤在一起居中（垂直居中）最常用 stretch 拉伸 align-content：设置侧轴上的子元素的排列方式（多行） 设置子项在侧轴上的排列方式并且只能用于子项出现换行的情况（多行），在单行下是没有效果的 属性值 说明 flex-start 默认值在侧轴的头部开始排列 flex-end 在侧轴的尾部开始排列 center 在侧轴中间显示 space-around 子项在侧轴平分剩余空间 space-between 子项在侧轴 先分布在两头，再平分剩余空间 stretch 设置子项元素高度平分父元素高度 flex-flow ：复合属性，相当于同时设置了flex-direction和flex-wrap flex-flow ：row wrap； flex布局子项常见属性 flex子项目占的份数 flex ：1 ； flex ： 2 ； align-self控制子项自己在侧轴的排列方式 order属性定义子项的排列顺序（前后顺序）","link":"/2020/03/23/%E7%A7%BB%E5%8A%A8WEB%E5%BC%80%E5%8F%91%E4%B9%8Bflex%E5%B8%83%E5%B1%80/"},{"title":"移动Web开发--rem适配布局","text":"rem 移动开发中重要的一种布局 rem 基础rem 单位rem（root em）是一个相对单位，类似于em，em是父元素字体大小。em，比如，父元素的字体大小font-size = 12px，子元素中就可以以1em = 12px 用em 来表示单位去设置 宽高大小 等。 不同的是 rem 的基准是相对于 html 元素的字体大小 比如，根元素（html）设置font-size = 12px；非根元素width：2rem，则换成px表示就是24px rem 优点：可以通过修改html里面的文字大小，来改变页面中元素的大小，可以整体控制 媒体查询 媒体查询（Media Query）是CSS3新语法 使用@media 查询，可以针对不同的媒体类型定义不同的样式 @media 可以针对不同的屏幕尺寸设置不同的样式 当你重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面 目前针对很多苹果手机，Android手机，平板等设备都用得到多媒体查询 语法规范 @media mediatype and|not|only （media feature）{CSS-Code；} 用@media开头，注意@符号 mediatype 媒体类型 值 说明 all 用于所有设备 print 用于打印机和打印预览 screen（常用） 用于电脑屏幕、平板电脑、智能手机 关键字 and not only and（常用）：可以将多个媒体特性链接到一起，相当于“且” not：排除某个媒体类型，相当于“非” only：指定某个特性的媒体类型 media feature 媒体特性 必须要有小括号包含 值 说明 width 定义输出设备中页面课件区域的宽度 min-width 定于输出设备中页面最小可见区域宽度 max-width 定于输出设备中页面最大可见区域宽度 eg：当宽度小于800px时，body背景色为粉色，当宽度小于400px时，背景色为黄色 123456789101112&lt;style&gt; @media screen and (max-width:800px){ body{ background-color: pink; } } @media screen and (max-width:400px){ body{ background-color: yellow; } }&lt;/style&gt; 媒体查询+rem实现元素动态大小变化 rem单位是跟着html 根元素字体大小来变化的 媒体查询可以根据不同设备宽度来修改样式 1234567891011121314151617181920212223242526&lt;style&gt; @media screen and (min-width:320px){ html{ font-size:50px; } } @media screen and (min-width:640px){ html{ font-size:100px; } } .top{ height:1rem; width:.5rem; background-color:green; color:#fff; text-align:center; line-height:1rem; }&lt;/style&gt;&lt;body&gt; &lt;div class=\"top\"&gt; 購物車 &lt;/div&gt;&lt;/body&gt; 引入资源（理解） rem 适配方案 让一些不能等比自适应的元素，达到当设备尺寸发生改变的时候，等比例适配当前设备 使用媒体查询根据不同设备按比例设置html 的字体大小，然后页面元素使用rem 做尺寸单位，当html 字体大小变化，元素尺寸也会发生变化， 从而达到等比缩放的适配 rem 实际开发适配方案① 按照设计稿与设备宽度的比例，动态计算并设置html 根标签的 font-size大小；（媒体查询） ② CSS中，设计稿元素的宽、高、相对位置等取值，按照同比例换算为rem为单位的值 rem 适配方案技术使用技术方案1： less 媒体查询 rem 设计稿中，常见宽度 750px or 720px；将宽度750px划分为15份，每一份为50px 通过媒体查询设置，当最小宽度为750px时，将html 的font-size 设置为50px；min-width：320px，font-size：21.33px。这样就能在不同屏幕下，进行等比例缩放 技术方案2(推荐)： flexible.js rem 总结： 两种方案现在都存在 方案2 更简单，因为flexible.js解决了很大一部分","link":"/2020/03/23/%E7%A7%BB%E5%8A%A8WEB%E5%BC%80%E5%8F%91%E4%B9%8Brem%E9%80%82%E9%85%8D%E5%B8%83%E5%B1%80/"},{"title":"计网1","text":"概述 第一节 计算机网络体系结构的概述 计算机网络的定义（考纲）计算机网络就是一些 互联的、自治的计算机系统的集合。计算机网络是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享、信息传递的系统。 计算机网络组成 计算机网络功能（考纲）主要有以下五大功能： 数据通信：最基本最重要的功能，实现联网计算机之间的各种信息的传输，并将分散在不同地理位置的计算机联系起来，统一分配、控制、管理。 资源共享：资源共享可以是软件共享、数据共享、硬件共享。 分布式处理 提高可靠性 负载均衡：将工作任务均衡地分配给计算机网络中的各台计算机。 计算机网络分类按分布范围分类后面会有详细讲解 广域网（WAN）：远程，因特网核心 城域网（MAN）：大多采用以太网技术 局域网（LAN）：传统上，局域网使用广播技术、而广域网使用交换技术；校园网 个人区域网（PAN）：平板、手机 按传输技术分类 广播式网络：所有互联计算机共享一个公共通信信道。局域网基本采用广播式通信技术，广域网中无线、卫星通信网络也采用广播式网络。 点对点网络：每条物理线路连接一对计算机。 拓扑结构分类（考纲）网络拓扑结构是指由网中结点（路由器、主机等）与通信设备（网线）之间的几何关系表示的网络结构，主要指通信子网的拓扑结构。 （理解每一个拓扑结构的基本概念）：总线型、星型、环形、网状型网络；其中总线型、星型、环形多用于局域网、网状形多用于广域网。 按使用者分类公用网、专用网 按交换技术分类电路交换、报文交换、分组交换 按传输介质分类有线无线 计算机网络性能指标（考纲） 性能指标 解释 带宽 “最高数据率” 单位比特/秒（b/s） 时延 ①.发送时延（传输时延）：发送时延 = 分组长度 / 信道宽度；②.传播时延：电磁波在信道中传播一定的距离需要花费的时间：传播时延 = 信道长度 / 电磁波在信道上的传播速率；③.处理时延 ④.排队时延。总时延：为四个时延相加。 时延带宽积 时延带宽积 = 传播时延*信道带宽 往返时延 Round-Trip Time ，RTT，发送端发送数据开始，到发送端收到接收端的确认，总共经历的时延。 吞吐量 Throughput，单位时间内通过某个网络（或信道、接口）的数据率，吞吐量受网络额定速率的限制。 速率 数据率、比特率；单位为b/s 比特/秒；kb/s、Mb/s、Gb/s 。 信道利用率 信道利用率 = 有数据通过时间 / （有+无）数据通过时间","link":"/2020/05/06/%E8%AE%A1%E7%BD%911/"},{"title":"网络安全之攻守道","text":"网络安全，就是攻守之间的对抗 学习地址指路 https://www.bilibili.com/video/BV1yW411q7GF Http 传输数据存在的问题http协议传输，超文本传输协议HTTP协议被用于在Web浏览器和网络服务器之间传递信息。HTTP协议以明文方式发送内容，不提供任何方式的数据加密。所以如果黑客截取了Web浏览器和网站服务器之间的传输报文，就可以直接读取重要信息（密码 账号 卡号等）。 Https 简介https协议，安全套接字层超文本传输协议HTTPS。是在HTTP的基础上加了SSL（Secure，Sockets，Layer，安全套接字层）。SSL依靠证书来验证服务器的身份，为浏览器和服务器之间的通信加密。 Https 和Http 的区别 https协议需要到 ca 申请证书，一般都要收费 http是超文本传输协议，信息是明文传输，连接很简单，https协议是由SSL+HTTP协议构建的 可进行 加密传输、身份认证的网络协议。安全性更高 http 和 https 使用的是完全 不同 的连接方式，用的端口不一样。前者是 80 端口，后者是 443 SSL 定义 SSL(Secure Sockets Layer安全套接层,及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层与应用层之间对网络连接进行加密。 作用 认证用户和服务器，确保数据发送到正确的 客户机 和 服务器； 加密数据以防止数据中途被窃取； 维护数据的完整性，确保数据在传输过程中不被改变。 服务器类型 Tomcat 5.x Nginx IIS Apache 2.x IBM HTTP SERVER 6.0 SSL 安全加密方式了解加密方式，分为对称加密和非对称加密 对称加密(Symmetric Cryptography) 原理：加密算法是公开的，靠的是密钥来加密数据；使用一个密钥加密，使用相同的密钥解密 常用对称加密算法：DES, 3DES， AES(破解难度大) 注意：在传输加密数据之前，需要传递密钥 对称加密优缺点 优点：计算量较小，加密和解密的速度比较快，适合加密比较大的数据 缺点：密钥的传输容易泄露；一个用户需要对应一个密钥，服务器管理密钥比较麻烦 非对称加密 原理：算法公开，一个公钥(public key)和一个私钥(private key)。 公钥加密只能私钥解密；私钥加密只能公钥解密，加密和解密的钥匙不同，即非对称加密 常用非对称加密算法：RSA 注意：公钥私钥需要加密算法生成 非对称加密优缺点 优点：加密和解密使用不同钥匙，可以传输公钥，数据传输是安全的 缺点：计算量大，加密解密速度较慢 Https 传输Https加密、解密及验证过程，两种加密方式结合使用 先使用非对称加密，服务器传输公钥 SSL数字证书；浏览器生成随机码，通过公钥传输给服务器。服务器通过私钥解开随机码。 将随机码作为密钥，使用对称加密(速度快)，将用户的重要信息通过随机码也就是密钥加密传过去。服务器之前已经用私钥解开了随机码（密钥），所以服务器用随机码（密钥）解开重要信息。 服务器实现Https 协议 配置 生成密钥库 确保环境变量配置了%JAVA_HOME%\\bin, 因为生成密钥库是使用 jdk 中的 keytool工具 进入dos命令运行如下命令： keytool -genkeypair -alias test-cyq -validity 3650 -keyalg RSA -dname \\ 123456 配置tomcat 启用https 协议并指定密钥库 进入server.xml ，将http配置注释掉，打开https，并配置https两个属性，指定密钥库的位置和密钥库的密码 SSL 证书种类 域名型 DVSSL 企业型 OVSSL 增强型 EVSSL Https 优缺点优点：安全性高 缺点：收费，也不是绝对安全，耗电耗资源","link":"/2020/03/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B9%8B%E6%94%BB%E5%AE%88%E9%81%93/"},{"title":"计网2","text":"概述 第二节 计算机网络体系结构与参考模型 计算机网络分层结构 我们把计算机网络的各层及其协议的集合 称为网络的体系结构，是从功能上描述计算机网络结构，是计算机网络中的层次、各层的协议及层间接口的集合。体系结构是抽象的，而实现是具体的。 分成的五个基本原则： 每层都实现一种相对独立功能，降低大系统复杂度 各层之间界面自然清晰，易于理解，相互交流尽可能少 各层采用最合适的技术来实现 保持下层对上传的独立性，下层单项提供上层服务 整个分层结构促进标准化工作 在计网分层结构中，第n层中的活动元素通常称为n层实体。不同及其上的同一层称为对等层，同一层的实体称为对等实体。n 提供服务给 n+1层。 在计网分层结构中，每个报文都分为两部分：数据部分 SDU 和控制信息部分 PCI，SDU+PCI = PDU 服务数据单元（SDU）、协议控制信息（PCI）、协议数据单元（PDU）；在各层间传输数据时，把从第n+1层收到的PDU作为第n层的SDU，加上第n层的PCI，变成了第n层的PDU，交给第n-1层作为SDU发送，接收方接收时做相反的处理。 物理层的PDU称为比特；链路层的PDU称为帧、网络层的PDU称为分组、传输层的PDU称为报文； 计算机网络的协议、接口、服务的概念协议 协议，就是规则的集合。为网络中的数据交换建立的规则、标准、约定称为网络协议（Network Protocol）；控制两个或多个对等实体进行通信的规则集合，是水平的。不对等实体之间是没有协议的。 协议由语法、语义和同步三部分组成。语法规定传输数据的格式（比如二进制 01）；语义规定了所要完成的功能，需要发出何种控制信息、完成何种动作、答复；同步规定了执行各操作的条件、时序关系等。 一个完整的协议通常具有线路管理（建立、释放连接）、差错控制、数据转换等功能。 接口接口时同一结点内相邻两层间交换信息的连接点，是一个系统内部的规定。每层只能为紧邻的层次之间定义接口，不能跨层定义接口。服务访问点（Service Access Point , SAP），服务是通过SAP提供给上层使用的。每个SAP都有一个能够表示它的地址。SAP是一个抽象概念，实际上是一个逻辑接口。 服务服务是指下层为紧邻的上层提供的功能调用，是垂直的。对等实体在协议的控制下，使得本层能为上层提供服务。OSI中称为服务原语：请求、指示、响应、证实。 计算机网络提供的服务可按照以下分类 面向连接服务与无连接服务 可靠服务和不可靠服务 有应答服务和无应答服务 ISO/OSI参考模型和TCP/IP模型（考纲）目的：支持异构网络系统的互联互通。 OSI参考模型国际标准化组织ISO提出的网络体系结构模型，称为开放系统互联参考模型OSI/RM，简称为OSI参考模型，有7层。 总结下： 物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流(就是由1、0转化为电流强弱来进行传输，到达目的地后再转化为1、0，也就是我们常说的数模转换与模数转换)。这一层的数据叫做比特。 数据链路层：定义了如何让格式化数据以进行传输，以及如何让控制对物理介质的访问。这一层通常还提供错误检测和纠正，以确保数据的可靠传输。 网络层：在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择。Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。 传输层：定义了一些传输数据的协议和端口号(WWW端口80等)，如：TCP(传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据)，UDP(用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做段。 会话层：通过传输层(端口号：传输端口与接收端口)建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求(设备之间需要互相认识可以是IP也可以是MAC或者是主机名)。 表示层：可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换吗(EBCDIC)，而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。 应用层：是最靠近用户的OSI层。这一层为用户的应用程序(例如电子邮件、文件传输和终端仿真)提供网络服务。 TCP/IP模型事实标准 4层 总结下： TCP/IP参考模型是首先由ARPANET所使用的网络体系结构。这个体系结构在它的两个主要协议出现以后被称为TCP/IP参考模型(TCP/IP Reference Model)。这一网络协议共分为四层：网络访问层、互联网层、传输层和应用层 TCP/IP协议不是 TCP和 IP这两个协议的合称，而是指因特网整个TCP/IP协议族。","link":"/2020/05/06/%E8%AE%A1%E7%BD%912/"},{"title":"计网4","text":"物理层 第四节 传输介质与物理层设备 双绞线、同轴电缆、光纤与无线传输介质传输介质，又称传输媒体，是发送设备和接收设备之间的物理通路，并非物理层的设备！！！。传输介质可分为导向传输介质和非导向传输介质。导向传输：电磁波被导向沿着固体媒介(铜线或光纤)传播；非导向传输：传输介质是空气、真空或海水。 双绞线 最常用的古老传输介质，两根采用一定规则并排绞合、相互绝缘的铜导线组成。 绞合减少对相邻导线电磁干扰。无层的双绞线是(UTP)，双绞线外面加一层金属丝编织成的屏蔽层，这就是屏蔽双绞线(STP)。 双绞线便宜，在局域网和传统电话网中普遍使用。双绞线带宽取决于铜线粗细和传输距离。模拟传输和数字传输都可以使用双绞线，通信距离一般几千米到数十千米。距离太远，模拟传输需要用放大器放大衰减信号；数字传输需要用中继器将失真的信号整形。 同轴电缆 同轴电缆由内导体、绝缘层、网状编织层屏蔽层和塑料外层构成。共用一个轴心。按特性阻抗数值的不同，分为两类：基带同轴电缆传输基带数字信号，用于局域网；宽带同轴电缆传输宽带信号，用于有线电视系统。 外导体屏蔽层，良好抗干扰特性，广泛用于传输较高速率的数据，其传输距离更远，比双绞线贵。 光纤（考纲） 光纤通信利用光导纤维（简称光纤）传递光脉冲来通信。有光脉冲为1，无光脉冲为0。光纤通信系统的带宽范围极大。 光纤由纤芯（实心）和包层组成，光波通过纤芯进行传导，包层较纤芯有较低的折射率。当光纤从高折射率介质射向低折射率介质，其折射角大于入射角。如果入射角足够大，会形成全反射，即光线碰到包层时会折射回纤芯，这个过程不断重复，光沿着光纤传输下去。 两种光纤： 多模光纤：入射角不同，形成多束光纤传输。光源是发光二极管。光脉冲在多模光纤传输逐渐展宽，易失真，只适合短距离传输。 单模光纤：光纤直径减小到一个光波长度，光纤就像一根波导，可使光纤一直向前传播，不会产生过多反射。光源是定向性好的激光二极管，制作成本高，衰减小，适合远距离传输。 光纤特点： 传输损耗小，中继距离长，对远距离传输特别经济 抗雷电和电磁干扰好 无串音干扰，保密性好 体积小，重量轻 无线传输介质 无线电波：信号向所有方向扩散；广泛用于通信领域：无线手机通信、计算机网络中的无线局域网（WLAN）等。 微波、红外线和激光：高频率带宽；信号固定方向传播，直线；卫星通信使用微波信号。 物理层接口的特性主要任务：确定与传输媒体的接口有关的一些特性： 机械特性、电器特性、功能特性、规程特性 中继器 中继器，又称转发器。主要功能，将信号整形并放大再转发出去，信号再生。放大器是放大模拟信号，中继器整形数字信号。 具有5-4-3规则 集线器 集线器（Hub）实质上是一个多端口的中继器，也工作在物理层。由Hub组成的网络是共享式网络，但逻辑上仍是一个总线网。Hub只能在半双工状态下工作。 对信号进行放大后发到其他所有端口。 星型拓扑结构的中间就是集线器。","link":"/2020/05/07/%E8%AE%A1%E7%BD%914/"},{"title":"计网3","text":"物理层 第三节 通信基础：基本概念、奈奎斯特定理香浓定理、编码与调制 基本概念数据、信号与码元通信的目的是传递消息。 数据是指传送信息的实体。信号是指数据的电气或电磁表现，是数据在传输过程中的存在形式。数据和信号都可以用“模拟的”和“数字的”来修饰。 连续变化的数据（或信号）称为模拟数据（模拟信号）； 取值仅允许为有限的几个离散数值的数据（或信号）称为数字数据（数字信号）； 数据的传输方式可分为串行传输、并行传输。 串行传输是指：一个一个的比特按照时间顺序传输（对经济考虑，远距离通信通常采用串行传输）； 并行传输是指：多个比特通过多条通信信道同时传输；速度快，费用高，适用于近距离，用于计算机内部数据传输； 码元：是指用一个固定时长的信号波形（数字脉冲）表示一位k进制数字，代表不同离散数值的基本波形，是数字通信中数字信号的计量单位，这个时长内的信号称为k进制码元，而该时长称为码元宽度。1码元可以携带多个比特的信息量。eg：在使用二进制编码时，只有两种不同的码元：一种代表0状态，一种代表1状态；在使用四进制编码时，2bit位可以表示四种码元：00 01 10 11；使用n进制编码，就有n中码元，即有 2的x次方 = n ，x个bit来表示。 信源、信道与信宿 数据通信是指数字计算机或其他数字终端之间的通信。一个数据通信系统主要划分为信源、信道和信宿三部分。 信源是产生和发送数据的源头。信宿是接收数据的终点，它们通常都是计算机或其他数字终端转置。需要通过变换器（调制解调器）转换成合适于在信道上传输的信号，也需要反转换器转成原始信息。 信道与电路不等同，信道是信号的传输媒介。噪声源是信道上的噪声（对信号的干扰）。 信道分为模拟信道和数字信道；也可分为无线信道和有线信道。 信道上传送信号有基带信号和宽带信号。 基带信号：将数字信号 1 和 0 直接用不同电压表示，然后传到数字信道上（基带传输）； 宽带信号：将基带信号进行调制形成频分复用模拟信号，然后传到模拟信道上（宽带传输）； 通信双方信息交互方式，可分为三种基本方式： 单工通信：无线电、广播、电视广播 半双工：任何一方不能同时发送和接收信息 全双工 信道的极限容量是指信道的最高码元传输速率或信道的极限信息传输速率。 速率、波特和带宽 速率也称数据率，指数据传输速率，表示单位时间内传输的数据量（s = vt）。 码元传输速率。又称码元速率、波形速率。表示单位时间数字通信系统所传码元个数（也是脉冲个数或信号变化的次数），单位波特Baud。1 Baud = 1码元 / S。码元可多进制；码元速率与进制数无关。 信息传输速率。又称信息速率，比特率。表示单位时间内数字通信系统传输的二进制码元个数（即比特数），单位比特/秒（b/s）。 若一个码元携带n比特的信息量，则M波特率的码元传输速率所对应的信息传输速率为 Mn b/s。 eg：若一码元携带2bit信息量，则5Baud的码元传输速率对应的信息传输速率为：10 b/s。 一码元携带2bit，即2*5=10 b/s。 带宽原指具有的频带宽度，单位hz。在实际网络中，带宽表示最高数据率 b/s。 奈奎斯特定理与香浓定理（考纲）奈斯定理 奈奎斯特（Nyquist）定理又称奈氏准则，在理想低通（没有噪声、宽带有限）的信道，极限码元传输速率为2W波特。W是理想低通信道的带宽，单位Hz。若用V表示每个码元离散电平的数目（即多少种不同的码元，即多少进制），则极限数据率为： 理想低通信道下的极限传输率 = 2Wlog2V b/s 奈氏准则结论： 任何信道，码元传输速率有上限。超过上限会出现码间串扰。 信道频带越宽（通过的信号高频分量越多），就可用更高的速率进行码元的有效传输。 给出了码元传输速率的限制，但未限制每个码元可以对应多少个二进制位。 提高数据传输速率，就设法使每个码元携带更多个比特的信息量，此时需要采用多元制的调制方法。 香浓定理 香浓（Shannon）定理给出了 带宽受限 且 有高斯白噪音干扰 的信道极限数据传输率，可以做到不产生误差。定理定义为： 信道的极限数据传输率 = Wlog2（1+S/N） b/s （W为信道带宽，S/N为信噪比；S为传输信号平均功率，N为信道内部高斯噪声功率） 单位转换：信噪比 = 10log10（S/N）dB 香浓定理结论： 信道带宽或信道中的信噪比越大，信息极限传输速率越高。 对一定的传输宽带和一定的噪声比，信息传输速率的上限是确定的。 只要信息的传输速率低于极限传输速率，就能找方法实现无差错的传输。 香浓定理得出信息极限传输速率，实际要低很多。 若S/N没有上限，那么极限信息传输速率也没有上限。虽然实际信噪比有限制的。 限制了一个码元对应的二进制位数。 编码与调制编码 –&gt;数字信号 调制 –&gt;模拟信号 数字数据编码为数字信号（考纲） 归零编码 非归零编码 反向非归零编码 曼彻斯特编码（考纲） 注意：以太网使用的编码方式就是 曼彻斯特编码。 查分曼彻思编码（考纲） 数字数据调制为模拟信号（考纲）发送端数字数据调制为模拟信号在模拟信道上传输，在接收端将模拟信号还原为数字信号。对应调制解调器的调制和解调过程。 调幅 调频 调相 调幅+调相","link":"/2020/05/06/%E8%AE%A1%E7%BD%913/"},{"title":"重绘和重排","text":"HTML页面进行重绘和重排（回流） 浏览器运行机制： 构建DOM树 生成内容树（html结构） 构建渲染树 css样式 布局渲染树 从根节点(&lt;html&gt;)递归调用，计算每一个元素的大小，位置等；给出每个节点所在屏幕上出现的确定坐标 绘制渲染树 遍历渲染树，使用UI层来绘制每个节点 重绘​ 重绘指的是，一个元素外观（颜色、背景）的改变，所触发的浏览器行为，即浏览器会根据新属性重新绘制页面 重排（回流）​ 重排指的是，一个元素或多个元素因为规模尺寸、布局、隐藏等改变页面需要重新构建页面。注意：每个页面至少需要回流一次，就是第一次加载的时候。 重排一定会导致重绘！！重排和重绘都会导致浏览器速度变慢！ 优化方法： 浏览器自己的优化：浏览器会维护1个队列，把所有会引起重绘和重拍的操作放在队列中，达到一定数量或者一定时间间隔，浏览器就会更新队列，进行一次批处理。（维护队列，后批处理） 我们要注意的优化：减少对渲染树的操作，我们可以合并多次DOM和样式的修改，并减少对style样式的请求 直接改变元素的className 需要多次重排的元素，position可以改为 absolute 或 fixed 。元素脱离了文档流，他的变化不会影响到其他元素了","link":"/2021/04/13/%E9%87%8D%E7%BB%98%E5%92%8C%E9%87%8D%E6%8E%92/"},{"title":"面试基础篇01","text":"面试基础篇01 1.call 和 apply 的区别是什么，哪个性能更好一些？答：1.都是function原型上的方法，每一個函數作爲function函數的实例，可以调取原型上的call和apply方法；2.都是改变this指向的，唯一区别是call是一个个传参，而apply是以数组的形式传参。3.相类似方法bind，但是没有立即执行这个方法，预先处理改变this指向（异步可以用）。4.call性能要优于apply（尤其是传递给函数的参数超过三个的时候），所以开发的时候使用call多一点。 123456789fn.call(obj, 10, 20, 30); // 傳參是一個個fn.apply(obj, [10,20,30]);// 以數組的形式保存起來let arr = [10, 20, 30]; obj = {};function fn(x, y, z) {}fn.apply(obj, arr); //x=10,y=20,z=30fn.call(obj, arr); //x=[10, 20, 30] y=z=undefinedfn.call(obj, ...arr); //基于ES6的展开运算符也可以实现把数组中的每一项依次传递给函数 自己实现性能测试（只供参考）：任何的代码性能测试都是和测试的环境有关系的，例如CPU、内存、GPU等电脑当前性能。（电脑性能一般不稳定） console.time可以测试出一段程序执行的时间 1234567console.time('A');//let t1 = new Date();for(let i = 0; i&lt;1000000; i++){}//console.log(new Date() - t1);console.timeEnd('A'); 2.实现(5).add(3).minus(2), 使其结果输出为：6arr.push(); arr是Array的实例，可以调用Array.prototype上的方法，push就是Array.prototype上的一个方法。 123456789101112131415161718192021~function(){ //每一個方法執行完，都要返回Number这个类的实例，这样才可以继续调取Number类原型中的方法（链式写法） function check(n){ n = Number(n); return isNaN(n) ? 0 : n; } function add(n){ n = check(n); return this + n; } function minus(n){ n = check(n); return this - n; } Number.prototype.add = add; Number.prototype.minus = minus; /* [\"add\", \"minus\"].forEach(item =&gt; { Number.prototype[item] = eval(item); });*/}();console.log((5).add(3).minus(2)); 3.箭头函数与普通函数（function）的区别是什么？ 构造函数（function）可以使用new生成实例，那么箭头函数可以吗？ 为什么？1.箭头函数es6语法比普通函数更简洁 12345678910functuon fn (x){ return function(y){ return x + y; }}let fn = (x) =&gt;{ return (y) =&gt;{ return x + y; };}; 2.箭头函数没有自己的this，他里面this是继承函数所处的上下文中的this，使用call/apply无法改变this的指向 123456789101112let obj = { name: 'OBJ'};function fn1(){ console.log(this); //this 指向obj}fn1.call(obj);// 箭头函数let fn2 = () =&gt; { console.log(this); //this 指向window}fn2.call(obj); 4.如何把一个字符串的大小写取反，例如‘AbC’变成’aBc’12345678910111213let str = 'abcdEFG的單詞！*';/*for (let str i=0; i&lt;str.length; i++) { }*///正則str = str.replace(/[a-zA-Z]/g, (content) =&gt; { //content：每一次正则匹配的结果 //验证是否为大写字母；把字母转换为大写后看和之前是否一样，如果一样，那么之前也是大写的；在ASCII表中找到大学字母的取值范围进行判断（65-90）。 //content.charCodeAt()&gt;=65 &amp;&amp; content.charCodeAt()&lt;=90 return content.toUpperCase() === content ? content.toLowerCase() : content.toUpperCase(); });console.log(str); 5.实现一个字符串匹配算法，从字符串S中，查找是否存在字符串T，若存在 返回所在位置，不存在返回-1.123456789101112131415161718192021222324252627282930313233343536indexOf/includes //内置方法~function () { //闭包 /* 循环原始字符串中的每一项，让每一项从当前位置向后截取 T.length个字符，和T比较，如果不一样，继续循环；如果一样 返回当前索引值即可，循环结束； */ function myIndexOf(T){ //this：S let lenT = T.length, lenS = this.length， res = -1; if(lenT&gt;lenS){ return -1; } for(let i = 0; i &lt;= lenS - lenT; i++){ if(this.substr(i,lenT) === T){ res = i; break; } } return res;//从当前字符i，截取lenT个，并与T对比。 } //用正则的方式做 function myIndexOf(T){ let reg = new RegExp(T), //这里是把T字符串变成了正则 res = reg.exec(this); return res === null ? -1 :res.index; } //把myIndexOf这个方法挂载到String的原型方法上 String.prototype.myIndexOf = myIndexOf;}();let S = 'helloworld', T = 'world';console.log(S.myIndexOf(T));","link":"/2020/02/23/%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80%E7%AF%8701/"},{"title":"计网5","text":"数据链路层 第五节 数据链路层的功能 + 组帧 +差错控制 数据链路层的功能（考纲）数据链路层（小秘） 使用下层 物理层的服务，并提供服务给上层 网络层。这三层是通信子网；主要作用，加强物理层传输原始比特流的功能，将物理层（傻子）提供的可能出差错的链路改造成逻辑上无差错的数据链路，使之对网络层（boss）表现为一条无差错链路。 为网络层提供服务 无确认的无连接服务 机器发送数据帧时不需先建立链路连接，收到帧也不用确认，对丢失的帧，链路层也不重发（真随缘发送）。适用于实时通信或误码率较低的通信信道，如以太网：通信质量好，有线传输链路。 有确认的无连接服务 机器发送数据帧时不需先建立链路连接，收到帧要发回确认。丢失帧重传。误码率高的比如无线传输。 有确认的面向连接服务 帧传输三阶段：建立数据链、传输帧、释放数据链路。 注：不存在无确认的面向连接服务。 链路管理数据链路层连接的“建立、维持、释放”过程称为链路管理。主要用于有确认的面向连接服务。 帧定界、帧同步与透明传输https://blog.csdn.net/cainv89/article/details/50603699?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase 我们需要对网络层（boss）的分组封装成帧，以帧传输。将一段数据的前后分别添加首部、尾部就构成帧。首尾部包含很多控制信息，主要作用是确定帧的界限，即帧定界。帧同步：接收方能从接收到的二进制比特流中区分出帧的起始与终止。 透明传输：不管所传输的数据是什么样的比特组合，都应当能在链路上传送。 流量控制控制发送速率。（大题必考！！！后面会有流量控制与可靠传输机制详细讲解，停等协议和滑动窗口协议）。发送方发送速度大于接收方接收速度，控制发送方的发送速率。 组帧（考纲）将比特组合成帧，以帧为单位传输，为了在出错时只发送帧，而不是全部比特数据。 差错控制差错检测防止差错的无效数据帧，浪费网络资源 检错编码纠错编码海明码","link":"/2020/05/07/%E8%AE%A1%E7%BD%915/"},{"title":"面试基础篇02","text":"面试基础篇02 1.var a = ?;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//var a = ?;var a = { n: 0, //私有的属性方法 toString: function () { return ++ this.n; }}//a.toString() //此时调取的不是Object.prototype.toString了，调取的是自己私有的方法if ( a == 1 &amp;&amp; a == 2 &amp;&amp; a ==3 ) { console.log('ok')}/* == 進行比较，如果左右两边数据类型不一样，则先转换为相同的数据类型，然后再进行比较 1.{} == {} 不相等，两个对象进行比较，比较的是堆内存的地址 2.null == undefined 相等， null === undefined 不相等 3.NaN == NaN 都不成立， NaN和谁都不相等 4.[12] == '12' 成立，对象和字符串比较，是把对象toString转化为字符串后进行类型比较 5.剩余所有情况在进行比较的时候，都是转换为数字（前提数据类型不一样） 对象转数字：先toString转换为字符串，然后再转换为数字 字符串转数字：只要传一个非数字字符，结果就是NaN 布尔转数字：true -&gt; 1 false -&gt; 0 null转数字：0 undefined转数字 NaN *[12] == true =&gt; Number([12].toString()) == 1 fasle *[1] == trur =&gt; 1 == 1 true *[] == false =&gt; 0 == 0 true *[] == 1 =&gt; 0 == 1 false *'1' == 1 =&gt; 1 == 1 true *true == 2 =&gt; 1 == 2 false *///shift(); 删除数组第一项，把删除的内容返回，原有数组改变let a = [1, 2, 3];a.toString = a.shift; //添加私有的toString方法if ( a == 1 &amp;&amp; a == 2 &amp;&amp; a ==3 ) { console.log('ok')}/*es6中新增加的一些方法 String.fromCharCode() Array.from() Array.isArray()*/ 2.let obj = {}12345678910111213141516171819Array.prototype.push = function (val) { this[this.length] = val //this.length在原来的基础上加1 return this.length;}/*[12, 23].push(100)[12, 23, 100]arr=[12,23]arr[arr.length] = 100;*/let obj = { 2: 3, 3: 4, length: 2, push: Array.prototype.push}obj.push(1)obj.push(2)console.log(obj)","link":"/2020/02/26/%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80%E7%AF%8702/"},{"title":"面试基础篇03","text":"从浏览器地址栏输入url到显示页面的步骤 学习文档转自http://blog.poetries.top/FE-Interview-Questions/base/ 基础版本 浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求； 服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）； 浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）； 载入解析到的资源文件，渲染页面，完成。 详细版 在浏览器地址栏输入URL 浏览器查看 缓存 ，如果请求资源在缓存中并且新鲜，跳转到转码步骤 如果资源未缓存，发起新请求 如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。 检验新鲜通常有两个HTTP头进行控制 1Expires 和 1Cache-Control ： HTTP1.0提供Expires，值为一个绝对时间表示缓存新鲜日期 HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的最大新鲜时间 浏览器解析URL获取协议，主机，端口，path 浏览器组装一个HTTP（GET）请求报文 浏览器 获取主机ip地址 ，过程如下： 浏览器缓存 本机缓存 hosts文件 路由器缓存 ISP DNS缓存 DNS递归查询（可能存在负载均衡导致每次IP不一样） 打开一个socket与目标IP地址，端口建立TCP链接 ，三次握手如下： 客户端发送一个TCP的SYN=1，Seq=X的包到服务器端口 服务器发回SYN=1， ACK=X+1， Seq=Y的响应包 客户端发送ACK=Y+1， Seq=Z TCP链接建立后发送HTTP请求 服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用HTTP Host头部判断请求的服务程序 服务器检查HTTP请求头是否包含缓存验证信息如果验证缓存新鲜，返回304等对应状态码 处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作 服务器将响应报文通过TCP连接发送回浏览器 浏览器接收HTTP响应，然后根据情况选择 关闭TCP连接或者保留重用，关闭TCP连接的四次握手如下 ： 主动方发送Fin=1， Ack=Z， Seq= X报文 被动方发送ACK=X+1， Seq=Z报文 被动方发送Fin=1， ACK=X， Seq=Y报文 主动方发送ACK=Y， Seq=X报文 浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同 如果资源可缓存，进行缓存 对响应进行解码（例如gzip压缩） 根据资源类型决定如何处理（假设资源为HTML文档） 解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行js脚本，这些操作没有严格的先后顺序，以下分别解释 构建DOM树 ： Tokenizing：根据HTML规范将字符流解析为标记 Lexing：词法分析将标记转换为对象并定义属性和规则 DOM construction：根据HTML标记关系将对象组成DOM树 解析过程中遇到图片、样式表、js文件，启动下载 构建 CSSOM树 ： Tokenizing：字符流转换为标记流 Node：根据标记创建节点 CSSOM：节点创建CSSOM树 根据DOM树和CSSOM树构建渲染树 : 从DOM树的根节点遍历所有可见节点，不可见节点包括：1）script,meta这样本身不可见的标签。2)被css隐藏的节点，如display: none 对每一个可见节点，找到恰当的CSSOM规则并应用 发布可视节点的内容和计算样式 js解析如下 ： 浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时document.readystate为loading HTML解析器遇到没有async和defer的script时，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用document.write()把文本插入到输入流中。同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作script和他们之前的文档内容 当解析器遇到设置了async属性的script时，开始下载脚本并继续解析文档。脚本会在它下载完成后尽快执行，但是解析器不会停下来等它下载。异步脚本禁止使用document.write()，它们可以访问自己script和之前的文档元素 当文档完成解析，document.readState变成interactive 所有defer脚本会按照在文档出现的顺序执行，延迟脚本能访问完整文档树，禁止使用document.write() 浏览器在Document对象上触发DOMContentLoaded事件 此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些内容完成载入并且所有异步脚本完成载入和执行，document.readState变为complete，window触发load事件 显示页面（HTML解析过程中会逐步显示页面） 详细简版 从浏览器接收url到开启网络请求线程（这一部分可以展开浏览器的机制以及进程与线程之间的关系） 开启网络线程到发出一个完整的HTTP请求（这一部分涉及到dns查询，TCP/IP请求，五层因特网协议栈等知识） 从服务器接收到请求到对应后台接收到请求（这一部分可能涉及到负载均衡，安全拦截以及后台内部的处理等等） 后台和前台的HTTP交互（这一部分包括HTTP头部、响应码、报文结构、cookie等知识，可以提下静态资源的cookie优化，以及编码解码，如gzip压缩等） 单独拎出来的缓存问题，HTTP的缓存（这部分包括http缓存头部，ETag，catch-control等） 浏览器接收到HTTP数据包后的解析流程（解析html-词法分析然后解析成dom树、解析css生成css规则树、合并成render树，然后layout、painting渲染、复合图层的合成、GPU绘制、外链资源的处理、loaded和DOMContentLoaded等） CSS的可视化格式模型（元素的渲染规则，如包含块，控制框，BFC，IFC等概念） JS引擎解析过程（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等） 其它（可以拓展不同的知识模块，如跨域，web安全，hybrid模式等等内容）","link":"/2020/02/26/%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80%E7%AF%8703/"},{"title":"Brakebills","text":"Chapte I ‘’ Step of the path “ “ 紧急情况！” 简走向校长。 “ 一直都是紧急情况 ” 校长看着报纸，平淡的说。 “ 已经发生了 ” 简把手中死去的飞蛾放在校长面前。 “ 他们都还没到Brakebills ” “ 我知道，把他们带来那儿，至少当他到来时，他们会有些自保能力 ” - 简。 “ 你对我们能操纵所有事物能力的想法总是让我惊讶不已 ” - 校长 Henry。 “ 我必须试一下，把他们带到Brakebills是你的责任，特别是他，你最近有关注那个男孩吗？” - 简。 “ Chatwin家的双胞胎和他们的哥哥被送到乡下，从小，Martin Chatwein就有抑郁症，为了减轻他的痛苦，他沉溺于精彩传奇故事中。他将她的姐姐Jane Chatwein 和哥哥 Rupert 从一个竖立钟表中穿梭进入到了一个神奇美丽的地方，魔法世界–fillory。” Julia敲开门，走向躺在床上的Quentin Coldwater。“我这一周都在找你，你去哪儿了” Julia想让Q振作起来，“我在我父亲家里面呆着 ” Q也沉浸于魔法故事中，逃走了现实中的面试。 第二天，Julia带着Q来到了面试地点，却惊讶的发现有个老头子死在了里面，并且看到了他在小说中描述的那个钟表。等到警察来解决事情过后，Julia和Q又因为Q的沉迷而吵架。 “ you have to stop！” “ stop what？” “ 你不能这样逃离生活，你别再管fiilory这些破事会怎样 ” “ 你以前喜欢fillory的 ” - Q ” 是的，我喜欢，它陪伴着我们的高中时光，但是这已经过去了，我们要面对现实。我知道你上周去了哪里，是医院，你跟上次感觉一模一样，感到虚幻无力 “ - Julia “ 每个人生活都有不如意的地方 ” - Q “ 生活开始变了，变得真实了。听着，我只是说，你擅长的东西很多，随便选一样去工作 ” - Julia 两人分开后，Julia去找男友了，Q独自在路边走着。此时Q手中的纸被风吹走，然后引导着他走进了一个很大的绿色草坪之上，面前是一个学院。同时Julia莫名其妙也被引领到此地。 “ Quentin Coldwater？” 一个名叫Eliet的高年级学长打量着Q “ 这是哪？” “ Brakebills University，你迟到了 ” 此时学校正在举行一场考试，Julia和Q都在这场考试当中。但最终Julia没能通过考试，会被消除记忆后送回原本世界。 ” 你们不能这样驱逐我，这些题目都是变化的，我要求申请重新考试 “ Julia对着一个教授Lee说到。 ” 这就是规则，没能通过这次考试的，就不能入学 “ - Lee “ 当我知道魔法都是真的之后，我还怎么能回到原本的世界中继续生活？” - Julia “ 所以我们将会使用记忆消除药水，没关系，回去之后，你就什么都不记得了 ” - Lee 趁着 Lee 拿药水之际，Julia将自己的手臂用戒指划出一大道伤口，试图想一次记住这些事情。 学长Eliet和学姐Margo去挑逗这个弱不经风的Q，带他逛着校园。校园里有各种魔法师，通灵的，幻术，治疗师等。此时有几个紧张兮兮的学生走过。 “ 他们是。。？” - Q “ 他们是三年级的学生，据说一个班30多个人，最终只剩几个人去了，有人说他们退学了，有人说他们疯了，传闻很多不是吗？“ Eliet和Margo互相打趣着说。 “ Step on the garden path ” Margo对Q说到。 他们三个在校园里坐着，此时一个人低着头默默走过，她叫Alice。 “ 她的父母也是魔法师，她姑姑是这里的老师，如果能巴结到她，没准就能顺利毕业了。但校园里总有这些性格奇奇怪怪的孩子，他们并不受人欢迎 ” - Margo “ hello，Alice，交个朋友吧！” - Margo挑逗的说到。 Alice瞟了一眼他们，就走开了。 Q后来找到Alice，说Eliet和Margo只是想表示善意。而且自己很羡慕她这种魔法世家。而Alice并不在乎，因为她的父母并不关心她的生活她的学业。 “ 我可以帮助你 ” - Q “ 帮助什么？” - Alice “ whatever you need，只是，我懂得这种没人理解的心情 ” - Q Julia的男友James打来电话。 “ hei，you jerk！你忘记了Julia的生日了吗？” - James “ hei ，James，I’m glad you call.” - Q “ look, Julia最近魂不守舍的，可能是马上要入学了，有点紧张，我打算给她办个party “ - James party现场。Q把Eliet 和 Margo带来了，他们俩在旁边嗨着玩。Q走向Julia。 “ 我要你告诉他们，他们看错我了 ” - Julia “ Who ? ” - Q “ Brakebills ,如果你说什么是 Brakebills 我会拿刀捅你，让他们再给我测试一下 ” - Julia “ 你怎么会？ ” - Q “ 会记得？，我让自己不忘记的 ” - Julia “ 你不是该去耶鲁吗？ ” - Q “ 那是我还不知道有其他，谁还会在乎商学院？你在乎吗？ ” - Julia “ 那你必须有某种能力 ” - Q 此时Julia向Q展示了一个小小的花火魔法，她学了很久才学会的。 “ 人们在醉意或者无意识的时候或许会展现出某些奇怪的东西，但这不意味你有魔法潜能 ” - Q “ 真伤人 ” - Julia “ 你知道你只是不想输 ” - Q “ 什么？” - Julia “ 你知道你除此之外什么都在行，即使不擅长这个也没关系，你在伤害你自己。“ - Q ” 他们斩断了我的人生之路 ” - Julia “ 你的生活在这里 ” - Q Julia来到卫生间，此时Julia的衣服扣子一颗颗掉，然后身体突然被提起到空中，然后被魔法推到了墙上。这时走过来一个男人，叫做Pete。他抚摸着Julia。Julia突然手冒火光，将捆绑在手上的衣物解开。 “ what the hell ，你是什么强奸犯吗？” - Julia “ No，当然不是，我也不会那样做，我只是来看看我是否做错了，看样子我没错，你以为只有从那所破学校学习到的东西才叫魔法吗？，我们已经观察你很久了 Julia ” - Pete “ ’我们‘ 是谁？ ” - Julia 回到学校，Q正在图书馆翻阅书，此时他貌似进入幻境，那个人正是书中的Jane，也就是Jane chatwin。 ” 你以为你找到了归宿感 Brakebills ” - Jane “ 别再踌躇不前，step of the path，赶快学会提问题 ，Brakebills 只是一个工具，你找到了归属感不是Brakebills，而是你开始掌握自己的命运” - Jane Alice找到Q，说她需要帮助。 “ 我需要你帮忙，我在学习一个魔法仪式 ” - Alice “ OK，just tell me what to do ” - Q 午夜时分，他们来到教室，开始准备做仪式。在Penny脑海中，一直出现Q的声音，都快烦死了，就顺势找到了他们，并带来了Kate。 他们四个围在一起开始施咒，但什么都没发生，Penny气冲冲走了。当他们四人走后，镜子里面出现了一个用血画的笑脸。 第二天，教授Lee 正在上课。突然学校的时钟开始不动了，校长意识到了危机，赶紧奔向教室。此时教室里面，所有人除了眼睛其他什么都不能动。从镜子里面出来了一个满脸是飞蛾的西装男人，走到前面，把教授杀死了。校长推开门用魔法还击，但不敌野兽。他也被控制住了，还被挖了眼珠放在桌上。 此时Q手上的硬币掉在了桌上，野兽注意到了，一步步慢慢逼近。 “ Quentin Coldwater ，there you are ，我们还是把一切扼杀在摇篮中吧 。“ 野兽捂住了Q的嘴。 此时校长用移物术将简给他的小钟表交到了Q手中，Q集中注意力按下了钟表，整个教室的时间开始流动，所有人开始惊慌的逃出教室。此时Penny脑海中突然传出一个女声 “ help！“ Katy开始用战斗魔法还击野兽，可不敌野兽，一挥手把她头撞到了桌子上。Alice开始使用魔法将野兽脸上的飞蛾驱散，野兽捂住脸连连后退到镜子里面。Penny拿起凳子砸向了镜子。他们四个人都知道，这个野兽是怎么来的。 校园医务室的人来到教室，收拾着残局，调查者此次背后的野兽。 “ 你是如何知道战斗魔法的？” - 教授 Sunderland “ 我知道学校不允许使用战斗魔法，但是，这种情况了。再说，我们能现在离开这里吗？please？！ ” - Kate “ 你说校长给了你什么东西 ” - Sunderland “ 校长给了我个钟表，我按了下去，校长还活着吗？ ” - Q “ 他只是受了伤 ” - Sunderland “ 我知道你们想知道发生了什么，我能告诉你们的是， 我们生活的世界只是多个世界中的一个，你们所看到的野兽来自其他地方。我们看不到本质，只知道它既强大又邪恶 。Brakebills有守卫和护盾的保护。我们目前在调查野兽是如何进入校园的，每个人将会被重新审查，该为此次袭击负责的人，将会被逐出校园。明天停课，星期三会有一个测试 ” - Sunderland","link":"/2021/10/22/Brakebills/"},{"title":"Hedge witches","text":"Chapter II “ Level 50, Top bitch in NY, for starters ” Pete 把 Julia 带到一个废旧的仓库，里面还有几个类似小混混的人，这里的环境简直比Brakebills差了好几万倍。 “ 他们是谁？” - Julia “ 跟你一样，new ” - Pete “ Marina 和 Julia 跟我走 ” - Pete Pete引领着她俩，然后将Marina和Julia关进了冷冻室里，并反锁了门。 “ Don‘t be an asshole！open the door！ ” - Julia 敲打着门。 “ 真的见鬼了，这里也太冷了，我们被困在这里了，他们想要杀了我们 ” Marina颤抖的说。 “ 他们不会杀了我们，这些人不是杀人犯 “ Julia正在打量着这里的环境和物品。 “ 你怎么知道？” - Marina “ 他们没这种，这就像是一个欺负新人的惯例，一个测试 ” - Julia 学校这边，Margo和Eliet带着Alice和Q来到无忧小屋里。 “ 你知道什么东西袭击了你吗？” - Margo “ 不，我不知道 ” - Alice “ 我还以为你出身魔法世家，可能奇闻异事见得多 ” - Margo “ 你没有参加学院的考试，而是直接来的，为什么？有什么东西吸引着你吗？是学校的防御系统？还是珍贵的图书？” - Margo “ 我父母有这里的钥匙，所以我偷了一把 ” - Alice “ 你在这里总有原因的吧 ” - Margo “ there is no reason ” - Alice “ 我只是想和你做朋友 ” - Margo “ 我不这样觉得，还是算了吧 ” - Alice起身离开 “ Ok, 这里有个谜语，我们翻翻这些报纸，没准能找到些东西 ” - Marina “ 并不会这么简单的 ” - Julia Pete在门外看了看，说到 “ come on “，然后是施了一点小魔法。 “ 啊啊！” Marina被面前突然起身的死尸下了一跳，那具死尸居然活了过来追赶着他们。 “ easy, it’me pete, Julia, 你想不想学魔法？ 如果你连这个都解决不了，那怎么对付我们将要做的事情，你们有没有四处找找 ” 最终，Julia和Marina找到了单子上的材料，施展了魔法，出来了。 “ This is shit test, I almost die there ” Julia对Pete凶道。 “ 我已经想你证明过我自己了，在我生日那天的卫生间里，你看到我施展过魔法 ” - Julia “ 你是在向我证明你自己 ” Marina转头对Julia说，并展示出自己手上的五颗星印记。 “ 来点轻松的，我们去喝一杯吧 ” - Pete Alice找到Q，而Q不现在不想理Alice “ 你跟我说那是什么提升潜能的魔法仪式，结果招来了，招来了满脸飞蛾的野兽 ，你一开始就不该说谎的 ” - Q “ 对不起，我不该把你卷入这件事情当中，只是你手上的那个印记和我寻找那本书上的印记是一样的，还有我的哥哥，我意思是我哥哥的灵魂让你帮助我他取得联系 ” - Alice “ 你哥哥？我听说过，你哥哥死在了学校里，你是想调查你哥哥的死因？” - Q “ 我真的不确定这是不是真实的，我手上这个印记，是在我梦到fillory的时候出现的，是来自jane的 ” - Q “ Jane Chatwin，the fillry book ” - Q “ 我现在没空花时间听你讲这些玄幻的小说 ” - Alice “ 深入费洛里这本书可能是虚构的，但Chatwin家族是真的 ” - Q Q和Alice一起查看了当年30多年前的录影，是采访作家Christopher Plover的邻居的。当年chatwin双胞胎jane和martin送到了这里，由Plover收养。但当双胞胎神秘失踪过后，Plover心力憔悴，这就是他写的作品都比较阴沉的原因吧，过后Plover也神秘消失了。后来是Plover的姐姐打理着这件房子。他们都是好人，收养了很多孩子。后人为纪念Plover，这座房子现在可以供人参观浏览。 Sunderland已经通过魔法查到了昨晚上，他们四个有在教室里施展魔法。他们被叫去审问。 Q 和 Alice 都说只是学习魔法。Penny 出来对 Kate说 “ we can go now ”。原来是Penny出卖了Q，把所有责任推给了Q。 这下Q要被逐出校园了。他试着打电话给Julia，问她是如何不被抹除记忆的。但Julia那边没接电话。 Q 来到教室，审问他的是简，不过这时她自称克莱尔。 “ 你并非十分出色，你很聪明，但并非天才，你有魔法能力，但仅此而已。最糟糕的是，你太渴望归属感，而忘记了你为什么会来到这里。 ” - 简 “ 你梦见过是吧，fillory，在被野兽攻击之前的fillory。我也梦见过；我曾经目视过野兽那双眼睛 ” - 简 “ 什么？” “ 你相信使命吗？” - 简 “ 是的 ” “ 我以前也相信使命，只是我尽量乐观对待事情。虽然我不能告诉你为什么野兽会找上你，但接下来怎么做，是你的选择 ” - 简 “ who are you？ ” “ 我只是一个不及格的魔法师罢了 ” - 简 “ 今天我不会抹去你的记忆，我会向学校申请再给你一次机会。他们会尊重我的决定。” - 简 “ Quentin，别让我失望 ，别再不安分的回到花园小径上，否则为了你好，我会抹除一切。” - 简 简来到医院 “ 你怎么样 Henry？” 简满脸歉意的看着躺在床上的校长。校长双眼被挖走，手指也被野兽弄断了。 “ 对不起，我知道他来了，但我发誓我没有想到这么快 ” - 简 “ 没有人准备好了 ，我们需要更多时间，还有一个看得见的双手正常的老师 ” 校长无奈的说到。 “ 我们会帮助你的，治好你的手和眼睛 ” - 简 “ 这是你该想办法解决的麻烦，Quentin，Penny 他们现在还不足以对抗 ，你应该回去，找到野兽，然后杀掉他 ” - 校长生气的说到。 “ 你说的就像我随便搭个公交车就能回去一样，你以为我有办法的话，我们俩就该去喝酒庆祝而不是我在这里看着你失去眼睛和手的样子 ” - 简急着说又表现出担忧的样子。 “ 我们能做的只能把他们培养成经验丰富的魔法师 ” - 校长 “ 这远远不够 ” - 简 “ 我知道 ” - 校长 Quentin拖着行李返回学校。 “ Quentin！ Here ” Eliet在远处拿着酒招呼着Q “ You little poor guy , come here , get some wine ” Margo 也叫道","link":"/2021/10/22/Hedge-witches/"},{"title":"Niffen","text":"Chapter III “ 他全身燃烧了起来，直到不复存在，他变成了Niffen ” “ 是时候该学些魔法了，慢慢来 ” - Pete对Julia说到，Julia开始慢慢体会到魔法的滋味。 “ 某种程度上，魔法师一直都在获得力量，远超自己的能量，元素。但是能量也会有代价。我们严格按照我们的处事方式开设这门课程是有原因的。自由散漫， 只关注在错误的事情上，缺乏引导，这些行为极其危险。有些咒语，有些能量太过强大，单凭一个魔法师无法驾驭。如果失控，它们就会反噬，会杀了你，改变你成为另外的样子 ” - 校长 （ 相比于Brakebills，Hedge witches的行为就太过危险 ） “ 现在你们要进行测试，来识别你们的能力类型。这样会更好的引导，更好的了解自己，发觉自己的潜能，到达更高的高度 ” - 校长 Alice会折射光线，Kate明显是一个战斗魔法师。Q因为找不到自己的类型而自怨自哀当中。 Alice和Q来到无忧小屋 Alice主动找到了Margo “ 我之前并不是故意表现出这种态度的 ” - Alice “ 没关系，每个人都有bitch的时候。你身上围绕着一种，不幸下，有一丝愤怒 ” - Margo “ 我来Brakebills，是为了调查我哥哥的死因 ” - Alice Margo找到了五年前的照片，“ 当时Charlie喜欢一个女孩叫做Emily ” Margo和Alice找到了Emily Emily 看到他俩后想离开，“ Emily, Charlie 是我哥哥 ” 这才叫住了Emily “ 五年前，我迷恋上了我的教授，为了他我做了一个很坏的事情，我用魔法去整容，但我失败了。我的一半的脸都垮塌了，Charlie当时想帮助我恢复容貌，他将各种魔法混合在一起，在施展的时候，控制不住自己，他全身燃烧了起来，直到不复存在，他变成了Niffen ” - Emily “ 你们知道什么是Niffen吗？” - Emily Alice和Margo对视了一下，Alice知道。 “ you loser ,stop sing that ” Penny对Q吼道 “ 我没有唱… ” - Q “ I know, I mean in your head, in your mind ” - Penny “ 你观察我的大脑，你个恶心的疯子 ” - Q “ 你以为我想，别唱了，信不信我捶死你 ” - Penny Q被Penny吓到连连后退跑了 Penny最近脑袋中经常有各种声音，这让他十分难受。 最后经过测试得知他的魔法类型是穿越者，是很罕见的一种。学校找来了唯一的穿越者老师来授课。 之前有Hedgewitch的人借书，是Eliet收费借给他们的。现在Eliet和Q一起去找书回来。因为那本魔法书要繁殖，需要上册。 来到废弃的工厂旁边，走进去，Q见到了正在学习魔法的Julia，他无奈也不敢相信Julia会跟这些业余魔法师混在一起。转身就要走，Julia拦下了他 “ 就这样？就这样走了？ ” - Julia上前质问道 “ 怎么，你想让我说什么？ ” - Q摇着头失望的说 “ 要不说声 对不起？最开始我以为是他们给我的测试，入学之前的测试，结果我等了一周、两周，我以为会有人来给我抹去记忆。然后我才意识到，你根本没有向他们提及我 ” - Julia “ look，Jules “ - Q “ 你曾是我最好的朋友 ” - Julia “ 是的，所以我放手了 ” - Q “ 什么叫你放手了 ” - Julia “ Brakebills里的人，他们可以操纵光线，可以读心，可以飞，而你不过是会些把戏 ” - Q “ 就是这样吗？真实的你？” - Julia “ 你有想过你一直怎么对我的吗？” - Q “ 什么，我.. ” - Julia “ 当然，你永远都是很好的，都是对的，对待你什么都做不到的小Q非常贴心非常友好 “ - Q “ 不要那么说我，那是你的说法 ” - Julia “ 你和James不过都是同情我罢了 ” - Q “ 你为什么要这么说 ” - Julia “ 因为这是事 Julia ” - Q “ 这不是事实 ” - Julia “ 承认吧，承认吧，就承认吧 ” - Q “ 所以你就要因此惩罚我 ” - Julia “ 我不知道我还能说些什么，你不能怪我，是你自己没有魔法天赋，你男友知道你在这里吗？你跟一群把魔法当把戏的混混们一起 ” - Q “ 你在开玩笑吗？这些人… ” - Julia “ 不要在沦落至此了，我很抱歉，但我认真的，你会付出惨重的代价，清醒点吧 ” - Q Q的无情和自私让Julia有些伤心 “ 你差点就被开除了，下次可不要这么粗心了 ” - Marina高傲的对着Kate说 “ 只是突然出现了个满脸都是飞蛾的怪物，用了什么麻痹人的魔法，我不得已这么做 ” - Kate Niffen学校禁止讨论的话题。她找到了对应的咒语，想让她哥哥复活。她告诉了Quentin，但Q因为担心Alice会做出一些出格的事情，所以提前准备了一个绑定器，可以讲灵魂绑定在这个小盒子里，以便她哥哥出现时失控了，可以有东西控制住他。 夜晚，Alice来到学校喷泉旁边，开始施魔法。她哥哥从温泉中冒出来，全身上下的血管中不时冒出蓝色的火焰，面目凶残。Quentin突然出现叫住Alice “ 他不是你哥哥，他是Niffen ” - Q喊道 Alice焦急得施展着魔法，急切的想唤起Charlie心中的理智 “ 我知道你在里面Charlie ”。Q想靠近，却被Charlie一挥手仍向了远处。 “ Alice… Don’t… ” - Q Alice自己快掌控不住魔法的时候，Q突然拿出那个小盒子喊道 “ cksooids danbyim, I bound you! ”. 只见Charlie的灵魂被吸入小盒子中。 “ 我马上就成功了 ” - Alice有些歇斯底里和绝望的喊道 “ 对不起 Alice ” Alice收拾行李准备离开学院了。 “ 你去哪儿？小可爱 ” - Margo “ 我要走了，你开心了，少了竞争对手 ” - Alice","link":"/2021/10/22/Niffen/"},{"title":"scikit learn","text":"scikit-learn 机器学习的库。其他还有tensorflow、pytorch Scikit-learn 有六个API大类classfication regression clustering 分类、回归、聚类 dimensionality reduction model selection preprocessing 降维（调优） 模型选择 特征工程（数据预处理） 12345678910111213141516171819202122232425from sklearn.datasets import load_irisfrom sklearn.model_selection import train_test_splitfrom sklearn.preprocessing import StandardScalerfrom sklearn.neighbors import KNeighborsClassifieriris = load_iris()x_train, x_test, y_train, y_test = train_test_split(iris.data, iris.target, test_size=0.2)# 特征化工程transfer = StandardScaler()x_train = transfer.fit_transform(x_train)x_test = transfer.transform(x_test)# 机器学习(模型训练)estimator2 = KNeighborsClassifier(n_neighbors=9)estimator2.fit(x_train,y_train)# 模型评估y_predict = estimator2.predict(x_test)print(\"预测结果为：\\n\", y_predict)print(y_predict == y_test)","link":"/2021/10/23/scikit-learn/"},{"title":"迷幻师的困局","text":"“ Stop playing , start living ” Quentin从病床上起来，面对一切陌生的环境，好像是在一个精神疗养院。","link":"/2021/10/22/%E8%BF%B7%E5%B9%BB%E5%B8%88%E7%9A%84%E5%9B%B0%E5%B1%80/"},{"title":"numpy学习","text":"Numpy数组运算库Numpy（Numerical Python）是一个开源的Python科学计算库，用于快速处理任意维度的数组。 Numpy支持常见的数组和矩阵操作。对于同样的数值计算任务，使用Numpy比直接使用Python要简洁的多。 Numpy使用ndarray对象来处理多维数组，该对象是一个快速而灵活的大数据容器。 ndarray的优势： 内存块风格 list – 分离式存储,存储内容多样化 ndarray – 一体式存储,存储类型必须一样 ndarray支持并行化运算（向量化运算） ndarray底层是用C语言写的,效率更高,释放了GIL 1 ndarray的属性 属性名字 属性解释 ndarray.shape 数组维度的元组 ndarray.ndim 数组维数 ndarray.size 数组中的元素数量 ndarray.itemsize 一个数组元素的长度（字节） ndarray.dtype 数组元素的类型 123456789101112131415import numpy as np# 通过np.array来创建一个ndarray对象score = np.array([[80, 89, 86, 67, 79],[78, 97, 89, 67, 81],[90, 94, 78, 67, 74],[91, 91, 90, 67, 69],[76, 87, 75, 67, 86],[70, 79, 84, 67, 84],[94, 92, 93, 67, 64],[86, 85, 83, 67, 80]])# 生成0和1的数组ones = np.ones([4,8]) 2 浅拷贝和深拷贝12345a = np.array([[1,2,3],[4,5,6]])# 从现有的数组当中创建，深拷贝a1 = np.array(a)# 相当于索引的形式，并没有真正的创建一个新的a2 = np.asarray(a) 3 生成固定范围数组 np.linspace(start,stop,num,endpoint) start 开始值 ；stop 终止值 num 要生成的等间隔样例数量，默认为50 endpoint 序列中是否包含stop值，默认为true 12345# 生成等间隔的数组np.linspace(0, 100, 11)# 返回结果array([ 0., 10., 20., 30., 40., 50., 60., 70., 80., 90., 100.]) np.arange() step – 步长 1np.arange(10, 50, 2) np.logspace() 生成以10的N次幂的数据 4 生成随机数组（ np.random模块 ） 正态分布 1234567891011121314# 生成均值为1.74，标准差为1的正态分布数据，100000000个# 第三个参数 也可以是（4,5），这样是生成4行5列矩阵x1 = np.random.normal(1.75, 1, 100000000)# 画图看分布状况# 1）创建画布plt.figure(figsize=(20, 10), dpi=100)# 2）绘制直方图plt.hist(x1, 1000)# 3）显示图像plt.show() 均匀分布 12345678910111213# 生成均匀分布的随机数x2 = np.random.uniform(-1, 1, 100000000)# 画图看分布状况# 1）创建画布plt.figure(figsize=(10, 10), dpi=100)# 2）绘制直方图plt.hist(x=x2, bins=1000) # x代表要使用的数据，bins表示要划分区间数# 3）显示图像plt.show()","link":"/2021/10/24/numpy%E5%AD%A6%E4%B9%A0/"},{"title":"pandas学习","text":"Pandas学习以Numpy为基础，借力Numpy模块在计算方面性能高的优势 基于matplotlib，能够简便画图 独特的数据结构（Series、DataFrame、MultiIndex） 1 Series的创建123456789# 导入pandasimport pandas as pdpd.Series(data=None, index=None, dtype=None)参数：data：传入的数据，可以是ndarray、list等index：索引，必须是唯一的，且与数据的长度相等。如果没有传入索引参数，则默认会自动创建一个从0-N的整数索引。dtype：数据的类型 2 Series的属性为了更方便地操作Series对象中的索引和数据，Series中提供了两个属性index和values 123456789color_count = pd.Series({'red':100, 'blue':200, 'green': 500, 'yellow':1000})color_count# 查看索引color_count.index# 查看值color_count.values# 可用索引获取值color_count[2] 3 DataFrame的创建DataFrame是一个类似于二维数组或表格(如excel)的对象，既有行索引，又有列索引 123456789101112131415161718# 导入pandasimport pandas as pdpd.DataFrame(data=None, index=None, columns=None)x1 = pd.DataFrame(np.random.randn(2,3))# 使用Pandas中的数据结构score_df = pd.DataFrame(score)# 构造行索引序列subjects = [\"语文\", \"数学\", \"英语\", \"政治\", \"体育\"]# 构造列索引序列stu = ['同学' + str(i) for i in range(score_df.shape[0])]# 添加行索引data = pd.DataFrame(score, columns=subjects, index=stu) 4 DataFrame属性12345678910111213141516171819202122data.shape# 结果(10, 5)# 行索引data.index# 列索引data.columns# 直接获取其中array的值data.values# 转置T# 如果不补充参数，默认5行。填入参数N则显示前N行data.head(5)data.tail(5)# 重新添加索引123456data.reset_index(drop = True / Fales)# 重新设置其中一列作为索引data.set_index() 5 文件读写12345# 读取，查看结果pd.read_csv(\"./data/test.csv\")# 选取10行数据保存,便于观察数据data[:10].to_csv(\"./data/test.csv\", columns=['open'])","link":"/2021/10/24/pandas%E5%AD%A6%E4%B9%A0/"},{"title":"matplotlib学习","text":"Matplotlib画图 1 matplotlib.pyplot模块matplotlib.pytplot包含了一系列类似于matlab的画图函数。 画各种图，折线图、统计图、散点图、饼状图、柱状图等利用不同的函数 1234567891011121314import matplotlib.pyplot as plt各种图的API：plt.plot(x,y) 折线图plt.scatter(x, y) 散点图plt.bar(x, width, align='center') 柱状图plt.hist(x,bins) 直方图 # x是数据 bins是多少一组plt.pie(x, labels=,autopct=,colors) 饼状图Parameters: x:数量，自动算百分比labels:每部分名称autopct:占比显示指定%1.2f%%colors:每部分颜色 2 画图流程12345678910import matplotlib.pyplot as plt# 1.创建画布plt.figure(figsize=(10, 10), dpi=100)# 2.绘制折线图plt.plot([1, 2, 3, 4, 5, 6 ,7], [17,17,18,15,11,11,13])# 3.显示图像plt.show() 12345678910111213141516171819import matplotlib.pyplot as pltimport random# 画出温度变化图# 0.准备x, y坐标的数据x = range(60)y_shanghai = [random.uniform(15, 18) for i in x]# 1.创建画布plt.figure(figsize=(20, 8), dpi=80)# 2.绘制折线图plt.grid(True, linestyle='--', alpha=0.5) # 添加网格plt.plot(x, y_shanghai)# 3.显示图像plt.show() 3 中文显示问题解决12345from pylab import mpl# 设置显示中文字体mpl.rcParams[\"font.sans-serif\"] = [\"SimHei\"]# 设置正常显示符号mpl.rcParams[\"axes.unicode_minus\"] = False","link":"/2021/10/24/matplotlib%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"es6","slug":"es6","link":"/tags/es6/"},{"name":"Django","slug":"Django","link":"/tags/Django/"},{"name":"验证","slug":"验证","link":"/tags/%E9%AA%8C%E8%AF%81/"},{"name":"案件","slug":"案件","link":"/tags/%E6%A1%88%E4%BB%B6/"},{"name":"mock","slug":"mock","link":"/tags/mock/"},{"name":"node","slug":"node","link":"/tags/node/"},{"name":"promise axios 异步","slug":"promise-axios-异步","link":"/tags/promise-axios-%E5%BC%82%E6%AD%A5/"},{"name":"rest","slug":"rest","link":"/tags/rest/"},{"name":"react","slug":"react","link":"/tags/react/"},{"name":"电影","slug":"电影","link":"/tags/%E7%94%B5%E5%BD%B1/"},{"name":"TS","slug":"TS","link":"/tags/TS/"},{"name":"Typora技巧","slug":"Typora技巧","link":"/tags/Typora%E6%8A%80%E5%B7%A7/"},{"name":"mongodb","slug":"mongodb","link":"/tags/mongodb/"},{"name":"jQuery","slug":"jQuery","link":"/tags/jQuery/"},{"name":"npm","slug":"npm","link":"/tags/npm/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"机器学习","slug":"机器学习","link":"/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"webpack","slug":"webpack","link":"/tags/webpack/"},{"name":"实习","slug":"实习","link":"/tags/%E5%AE%9E%E4%B9%A0/"},{"name":"UI","slug":"UI","link":"/tags/UI/"},{"name":"SEO","slug":"SEO","link":"/tags/SEO/"},{"name":"网页布局","slug":"网页布局","link":"/tags/%E7%BD%91%E9%A1%B5%E5%B8%83%E5%B1%80/"},{"name":"考研803","slug":"考研803","link":"/tags/%E8%80%83%E7%A0%94803/"},{"name":"网络安全","slug":"网络安全","link":"/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"前端面试题","slug":"前端面试题","link":"/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"fillory","slug":"fillory","link":"/tags/fillory/"},{"name":"filler","slug":"filler","link":"/tags/filler/"},{"name":"机器学习库","slug":"机器学习库","link":"/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%BA%93/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"侦探案件","slug":"侦探案件","link":"/categories/%E4%BE%A6%E6%8E%A2%E6%A1%88%E4%BB%B6/"},{"name":"电影","slug":"电影","link":"/categories/%E7%94%B5%E5%BD%B1/"},{"name":"Typescript","slug":"Typescript","link":"/categories/Typescript/"},{"name":"Vue","slug":"Vue","link":"/categories/Vue/"},{"name":"机器学习","slug":"机器学习","link":"/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"实习","slug":"实习","link":"/categories/%E5%AE%9E%E4%B9%A0/"},{"name":"Css","slug":"Css","link":"/categories/Css/"},{"name":"考研笔记","slug":"考研笔记","link":"/categories/%E8%80%83%E7%A0%94%E7%AC%94%E8%AE%B0/"},{"name":"前端面经","slug":"前端面经","link":"/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E7%BB%8F/"}]}