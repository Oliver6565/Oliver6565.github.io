<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>TypeScript01</title>
    <url>/2020/03/17/TypeScript01/</url>
    <content><![CDATA[<h4 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h4><p>Typescript 是微软推出的一门语言，是JavaScript的超集，包含ES567</p>
<p>新增了类型系统和完整的面向对象</p>
<a id="more"></a>

<h4 id="第一章-TypeScript-基础"><a href="#第一章-TypeScript-基础" class="headerlink" title="第一章 TypeScript 基础"></a>第一章 TypeScript 基础</h4><h4 id="01-TypeScript-环境安装"><a href="#01-TypeScript-环境安装" class="headerlink" title="01.TypeScript 环境安装"></a>01.TypeScript 环境安装</h4><ol>
<li><p>需要一个工具，将ts代码转换为浏览器或者nodejs识别的js代码，就需要ts环境（npm，nodejs的包管理器，用npm下载ts环境；网上下载安装nodejs，cmd node -v 查看）-&gt;cmd中 tsc -v 查看</p>
<ul>
<li>全局安装： <em>npm i -g typescript</em></li>
<li>校验typescript： <em>tsc -v</em></li>
<li>tsc的作用：<em>负责将ts代码转为浏览器、nodejs识别的js代码</em></li>
</ul>
</li>
<li><p>第一个ts程序</p>
<ul>
<li><p>在后缀名为.ts文件中写typescript代码</p>
</li>
<li><p>使用tsc工具将typescript代码编译为浏览器、nodejs识别的js代码</p>
</li>
<li><p>在浏览器或者nodejs中执行js代码</p>
<p><em>ts -&gt; js -&gt; html scprit标签引入</em></p>
</li>
</ul>
</li>
<li><p>在nodejs中执行typescript代码</p>
<ul>
<li>执行tsc转换过后的js代码   <em>node xxx.js</em></li>
</ul>
</li>
<li><p>ts-node ： 自动将ts代码转换为js代码，并将其在nodejs中执行</p>
<ul>
<li>安装 <em>npm i -g ts-node</em></li>
<li>使用 <em>ts-node xxx.ts</em>文件名</li>
</ul>
</li>
</ol>
<h4 id="02-TypeScript-数据类型-变量"><a href="#02-TypeScript-数据类型-变量" class="headerlink" title="02. TypeScript 数据类型 | 变量"></a>02. TypeScript 数据类型 | 变量</h4><ol>
<li><p>在JavaScript中，变量中可以存储任意类型的数据</p>
<p><em>var a = 10； a = “jack” ； a=true；</em></p>
</li>
<li><p>但是在TS语法规定：在声明变量的时候，必须制定变量的类型</p>
</li>
<li><p>声明变量的语法： </p>
<p><u>let 变量名：变量类型</u></p>
<p><em>let age： number</em></p>
<p><em>let myName： String</em></p>
</li>
<li><p>变量的类型一旦指定后，这个变量只能存储这个类型的数据</p>
<p><em>age = 18</em>； 这样可以的</p>
<p><em>age = “jack”</em> 错误 -&gt; 因为上面age指定了类型为number</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>TS</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise相关</title>
    <url>/2020/03/14/Promise%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><a id="more"></a>

<h3 id="1-Promise用法"><a href="#1-Promise用法" class="headerlink" title="1.Promise用法"></a>1.Promise用法</h3><h4 id="1-1-异步调用"><a href="#1-1-异步调用" class="headerlink" title="1.1 异步调用"></a>1.1 异步调用</h4><ul>
<li><p>异步效果分析</p>
<ul>
<li><p>定时任务 setTimeout setInterver</p>
</li>
<li><p>Ajax 异步ajax请求（jqurey）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ret = <span class="string">''</span></span><br><span class="line">$ajax&#123;(</span><br><span class="line">	url:<span class="string">'http://localhost:3000/...'</span>,</span><br><span class="line">	success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(data)</span><br><span class="line">		ret = data;</span><br><span class="line">    	<span class="built_in">console</span>.log(ret)  <span class="comment">// 这里可以</span></span><br><span class="line">	&#125;</span><br><span class="line">)&#125;</span><br><span class="line"><span class="built_in">console</span>.log(ret)  <span class="comment">// 这里的ret是获取不到里面的东西的</span></span><br><span class="line"><span class="comment">// 只能在回调函数中，获得值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>事件函数</p>
</li>
</ul>
</li>
<li><p>多次异步调用的依赖分析</p>
<ul>
<li><p>多次异步调用的<u>结果顺序不确定</u></p>
</li>
<li><p>异步调用结果如果存在依赖，那么我们需要多次多次嵌套，就是传说中的“十八层地域”，回调地狱。</p>
</li>
</ul>
</li>
</ul>
<h4 id="1-2-Promise-概述"><a href="#1-2-Promise-概述" class="headerlink" title="1.2 Promise 概述"></a>1.2 Promise 概述</h4><p>Promise 是异步编程的一种解决方案，从语法上讲，Promise是一个对象，从它可以获取异步操作的消息。</p>
<ul>
<li>可以避免多层异步调用嵌套问题（回调地狱）。</li>
<li>Promise对象提供了简介的API，使得控制异步操作更加容易</li>
</ul>
<h4 id="1-3-Promise-基本用法"><a href="#1-3-Promise-基本用法" class="headerlink" title="1.3 Promise 基本用法"></a>1.3 Promise 基本用法</h4><ul>
<li><p>实例化Promise 对象，构造函数中传递函数，该函数中用于处理异步任务</p>
</li>
<li><p>resolve和reject两个参数（都是方法，可以调用）用于处理成功和失败两种情况，并通过p.the获取处理结果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 成功时调用 resolve()</span></span><br><span class="line">    <span class="comment">// 失败时调用 reject()</span></span><br><span class="line">&#125;)</span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">ret</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 返回成功的结果ret</span></span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 返回失败的结果</span></span><br><span class="line">&#125;) </span><br><span class="line"></span><br><span class="line">-------------------------------------------------</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> flag = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">            <span class="comment">// 正常情况</span></span><br><span class="line">            resolve(<span class="string">'hello'</span>)</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 异常情况</span></span><br><span class="line">            reject(<span class="string">'出错'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">100</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="1-4-基于Promise处理Ajax请求"><a href="#1-4-基于Promise处理Ajax请求" class="headerlink" title="1.4 基于Promise处理Ajax请求"></a>1.4 基于Promise处理Ajax请求</h4><ol>
<li>处理原生Ajax</li>
</ol>
<h4 id="1-5-then参数中的函数返回值"><a href="#1-5-then参数中的函数返回值" class="headerlink" title="1.5 then参数中的函数返回值"></a>1.5 then参数中的函数返回值</h4><p>1.返回Promise实例对象</p>
<ul>
<li>返回的该实例对象会调用下一个then</li>
</ul>
<p>2.返回普通值</p>
<ul>
<li>返回的普通值会直接传递给下一个then，通过then参数中函数的参数接收该值</li>
</ul>
<h4 id="1-6-Promise常用的API"><a href="#1-6-Promise常用的API" class="headerlink" title="1.6 Promise常用的API"></a>1.6 Promise常用的API</h4><p>1.实例方法（在原型中的方法，需要用实例去调用）</p>
<ul>
<li>p.then() 得到异步任务的正确结果</li>
<li>p.catch() 获取异常信息</li>
<li>p.finally() 成功与否都会执行（尚且不是正式标准）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">           <span class="comment">// resolve(123);</span></span><br><span class="line">            reject(error)</span><br><span class="line">        &#125;,<span class="number">100</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line">	.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    	<span class="built_in">console</span>.log(data)</span><br><span class="line">	&#125;)</span><br><span class="line">	.catch(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>))</span>&#123;</span><br><span class="line">     	<span class="built_in">console</span>.log(data)      </span><br><span class="line">    &#125;)</span><br><span class="line">    .finally(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'finished'</span>)</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>2.对象方法</p>
<ul>
<li>Promise.all() 并发处理多个异步任务，所有任务都执行完成才能得到结果</li>
<li>Promise.race() 并发处理多个异步任务，只要有一个任务完成就能得到结果</li>
</ul>
<h3 id="2-接口调用-fetch用法"><a href="#2-接口调用-fetch用法" class="headerlink" title="2 接口调用 -fetch用法"></a>2 接口调用 -fetch用法</h3><h4 id="2-1-基本特性"><a href="#2-1-基本特性" class="headerlink" title="2.1 基本特性"></a>2.1 基本特性</h4><ul>
<li>更加简单的数据获取方式，功能更强大，更灵活，可以看做是xhr的升级版</li>
<li>基于Promise实现</li>
</ul>
<h4 id="2-2-语法结构"><a href="#2-2-语法结构" class="headerlink" title="2.2 语法结构"></a>2.2 语法结构</h4><p>fetch(url).then(fn2)</p>
<p>​                .then(fn3)</p>
<p>​                …</p>
<p>​                .catch(fn)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fetch(<span class="string">'http://localhost:3000/fdata'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> data.text(); <span class="comment">//text()方法属于fetchAPI的一部分，它返回一个Promise实例对象，用于获取后台返回的数据</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="2-3-fetch请求参数"><a href="#2-3-fetch请求参数" class="headerlink" title="2.3 fetch请求参数"></a>2.3 fetch请求参数</h4><ol>
<li>常用配置选项<ul>
<li>method(String): HTTP请求方法，默认为GET POST PUT DELETE</li>
<li>body(String): HTTP请求参数</li>
<li>header(Object): HTTP的请求头，默认为{}</li>
</ul>
</li>
</ol>
<h3 id="3-axios-用法"><a href="#3-axios-用法" class="headerlink" title="3. axios 用法"></a>3. axios 用法</h3><h4 id="3-1-axios-的基本特性"><a href="#3-1-axios-的基本特性" class="headerlink" title="3.1 axios 的基本特性"></a>3.1 axios 的基本特性</h4><p>axios（官网：<a href="https://github.com/axios/axios）是一个基于Promise用于浏览器和node.js的HTTP客户端" target="_blank" rel="noopener">https://github.com/axios/axios）是一个基于Promise用于浏览器和node.js的HTTP客户端</a></p>
<p>它有以下特性：</p>
<ul>
<li>支持浏览器和node.js</li>
<li>支持promise</li>
<li>能拦截请求和响应</li>
<li>自动转换JSON数据</li>
</ul>
<h4 id="3-2-axios-的基本用法"><a href="#3-2-axios-的基本用法" class="headerlink" title="3.2 axios 的基本用法"></a>3.2 axios 的基本用法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios.get(<span class="string">'/adata'</span>)</span><br><span class="line">	.then(<span class="function"><span class="params">ret</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//data属性名称是固定的，用于获取后台响应的数据</span></span><br><span class="line">    <span class="built_in">console</span>.log(ret.data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="3-3-axios-常用API"><a href="#3-3-axios-常用API" class="headerlink" title="3.3 axios 常用API"></a>3.3 axios 常用API</h4><ul>
<li>get：      添加数据</li>
<li>post：    删除数据</li>
<li>put：      修改数据</li>
<li>delete： 删除数据</li>
</ul>
<ol>
<li>GET 传递参数<ul>
<li>通过 URL 传递参数</li>
<li>通过params 选项传递参数</li>
</ul>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios.get(<span class="string">'/adata?id=123'</span>)</span><br><span class="line">	.then(<span class="function"><span class="params">ret</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(ret.data)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后台接口</span></span><br><span class="line">app.get(<span class="string">'/axios'</span>,(req,res) =&gt; &#123;</span><br><span class="line">    res.send(<span class="string">'axios get 传递参数'</span> + req.query.id)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios.get(<span class="string">'/adata/123'</span>)</span><br><span class="line">	.then(<span class="function"><span class="params">ret</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(ret.data)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后台接口</span></span><br><span class="line">app.get(<span class="string">'/axios/:id'</span>,(req,res) =&gt; &#123;</span><br><span class="line">    res.send(<span class="string">'axios get (Restful) 传递参数'</span> + req.params.id)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios.get(<span class="string">'/adata'</span>,&#123;</span><br><span class="line">	params:&#123;</span><br><span class="line">		id:<span class="number">123</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">ret</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(ret.data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>POST 传递参数</p>
<p>axios.post(‘<a href="http://localhost:3000/axios’,{" target="_blank" rel="noopener">http://localhost:3000/axios’,{</a></p>
<p>​    uname: ‘lily’</p>
<p>​    pwd: 123</p>
<p>}).then(function(ret){</p>
<p>​    console.log(ret.data)</p>
<p>})</p>
<p>post传参，这样默认传过去的是以json格式传</p>
</li>
</ol>
<h4 id="3-4-axios-的响应结果"><a href="#3-4-axios-的响应结果" class="headerlink" title="3.4 axios 的响应结果"></a>3.4 axios 的响应结果</h4><p>响应结果的主要属性（axios自己包装了，有这些属性</p>
<ul>
<li>data：实际响应回来的数据</li>
<li>headers：响应头信息</li>
<li>status：响应状态码</li>
<li>statusText：响应状态信息</li>
</ul>
<h4 id="3-5-axios-的全局配置"><a href="#3-5-axios-的全局配置" class="headerlink" title="3.5 axios 的全局配置"></a>3.5 axios 的全局配置</h4><p>axios.defaults.timeout = 3000； //超时时间</p>
<p>axios.defaults.aseURL = ‘<a href="http://localhost:3000/app’" target="_blank" rel="noopener">http://localhost:3000/app’</a>; //默认地址</p>
<p>axios.defaults.headers[ ‘mytoken’ ] = ‘xxxx’ //设置请求头</p>
<h4 id="3-6-axios-的拦截器"><a href="#3-6-axios-的拦截器" class="headerlink" title="3.6  axios 的拦截器"></a>3.6  axios 的拦截器</h4><ol>
<li><p>请求拦截器</p>
<p>在请求发出之前设置一些信息</p>
<p>//添加一个请求拦截器 token拦截</p>
<p>axios.interceptors.request.use(function(config){</p>
<p>​    // 在请求发出之前进行一些信息设置</p>
<p>​    config.headers.mytoken = ‘ nihao’</p>
<p>​    return config</p>
<p>}，function（err）{</p>
<p>// 处理响应的错误信息</p>
<p>})</p>
<p>2.响应拦截器</p>
<p>在获取数据之前，对数据做一些加工处理</p>
<p>添加一个响应拦截器</p>
<p>axios.interceptors.request.use(function(res){</p>
<p>​    // 在这里对返回的数据进行处理</p>
<p>​    return res</p>
<p>}，function（err）{</p>
<p>// 处理响应的错误信息</p>
<p>})</p>
</li>
</ol>
<h3 id="4-接口调用-async-await用法-（常用）"><a href="#4-接口调用-async-await用法-（常用）" class="headerlink" title="4. 接口调用 -async /await用法 （常用）"></a>4. 接口调用 -async /await用法 （常用）</h3><ul>
<li>async/await是ES7 引入的新语法，可以更加方便的进行一步操作</li>
<li>async 关键字用于函数上（async函数的返回值是Promise实例对象）</li>
<li>await 关键字用于async 函数当中（await可以得到异步的结果）</li>
</ul>
<p>async function queryData(id){</p>
<p>​    const ret = await axios.get(‘/data’)</p>
<p>​    return ret;</p>
<p>}</p>
<p>queryData.then(ret =&gt; {</p>
<p>​    console.log(ret)</p>
<p>})</p>
]]></content>
      <tags>
        <tag>promise axios 异步</tag>
      </tags>
  </entry>
  <entry>
    <title>vue搭建appweb</title>
    <url>/2020/03/13/vue%E6%90%AD%E5%BB%BAappweb/</url>
    <content><![CDATA[<h2 id="webapp-外卖系统（移动端）"><a href="#webapp-外卖系统（移动端）" class="headerlink" title="webapp 外卖系统（移动端）"></a>webapp 外卖系统（移动端）</h2><p>！（前言：学习Vue项目搭建流程，记录心得（<strong>部分筆記為課件</strong>）。<strong>学习视频</strong> -&gt; <a href="https://www.bilibili.com/video/av49099807" target="_blank" rel="noopener">https://www.bilibili.com/video/av49099807</a></p>
<a id="more"></a>

<h4 id="1-使用-vue-cli-脚手架-搭建项目"><a href="#1-使用-vue-cli-脚手架-搭建项目" class="headerlink" title="1. 使用 vue-cli(脚手架)搭建项目"></a>1. 使用 vue-cli(脚手架)搭建项目</h4><ol>
<li>Vue-cli 是 vue 官方提供的用于搭建基于 vue+webpack+es6 项目的脚手架工具 </li>
<li>在线文档:<a href="https://github.com/vuejs/vue-cli" target="_blank" rel="noopener">https://github.com/vuejs/vue-cli</a> </li>
<li>操作: npm install -g vue-cli vue init webpack gshop cd gshop npm install npm run dev 访问: localhost:8080</li>
</ol>
<h4 id="2-项目结构分析"><a href="#2-项目结构分析" class="headerlink" title="2. 项目结构分析"></a>2. 项目结构分析</h4><p>gshop </p>
<ul>
<li>|– build : webpack 相关的配置文件夹(基本不需要修改) </li>
<li>|– config: webpack 相关的配置文件夹(基本不需要修改) </li>
<li>|– index.js: 指定的后台服务的端口号和静态资源文件夹 </li>
<li>|– node_modules </li>
<li>|– src : 源码文件夹 </li>
<li>|– main.js: 应用入口 js </li>
<li>|– static: 静态资源文件夹 </li>
<li>|– .babelrc: babel 的配置文件 </li>
<li>|– .editorconfig: 通过编辑器的编码/格式进行一定的配置 </li>
<li>|– .eslintignore: eslint 检查忽略的配置 </li>
<li>|– .eslintrc.js: eslint 检查的配置 </li>
<li>|– .gitignore: git 版本管制忽略的配置 </li>
<li>|– index.html: 主页面文件 </li>
<li>|– package.json: 应用包配置文件 </li>
<li>|– README.md: 应用描述说明的 readme 文件</li>
</ul>
<h4 id="3-编码测试与打包发布项目"><a href="#3-编码测试与打包发布项目" class="headerlink" title="3. 编码测试与打包发布项目"></a>3. 编码测试与打包发布项目</h4><ol>
<li>编码测试 npm run dev 访问:<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> 编码, 自动编译打包(HMR), 查看效果 </li>
<li>打包发布 npm run build npm install -g serve serve dist 访问:<a href="http://localhost:5000" target="_blank" rel="noopener">http://localhost:5000</a></li>
</ol>
<h4 id="4-項目源碼目錄設計"><a href="#4-項目源碼目錄設計" class="headerlink" title="4. 項目源碼目錄設計"></a>4. 項目源碼目錄設計</h4><ul>
<li><p>src</p>
<ul>
<li><p>api    与后台交互模块文件夹</p>
</li>
<li><p>common（asstes） 通用资源文件夹，如fonts/img/stylus</p>
<p>(stylus: css预编译器，Sass/Less</p>
<p><em>npminstallstylusstylus-loader–save-dev</em>）</p>
</li>
<li><p>components    非路由组件文件夹</p>
</li>
<li><p>filters    自定义过滤器模块文件夹</p>
</li>
<li><p>mock     模拟数据接口文件夹</p>
</li>
<li><p>pages    路由组件文件夹</p>
</li>
<li><p>router    路由器文件夹-&gt;index.js/router.js 暴露router给入口文件main.js</p>
</li>
<li><p>store    vuex相关模块文件夹</p>
</li>
<li><p>App.vue    应用组件</p>
</li>
<li><p>main.js    入口JS</p>
</li>
</ul>
</li>
</ul>
<h3 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h3><h4 id="props的详解："><a href="#props的详解：" class="headerlink" title="props的详解："></a><strong>props</strong>的详解：</h4><p>组件示例的作用域是孤立的，意味着不能（也不应该）在子组件的模板内直接引用父组件的数据。父组件的数据要通过prop才能下发到子组件中。</p>
<p>props是子组件访问父组件数据的唯一接口</p>
<ul>
<li>一个组件可以直接在模板里面渲染data里面的数据（双大括号）。</li>
</ul>
<ul>
<li>子组件不能直接在模板里面渲染父元素的数据。</li>
</ul>
<ul>
<li>如果子组件想要引用父元素的数据，那么就在prop里面声明一个变量（比如a），这个变量就可以引用父元素的数据。然后在模板里渲染这个变量（前面的a），这时候渲染出来的就是父元素里面的数据。 </li>
</ul>
<h4 id="slot的详解："><a href="#slot的详解：" class="headerlink" title="slot的详解："></a><strong>slot</strong>的详解：</h4><p>给<slot>元素指定一个name后可以分发多个内容</p>
<p>一个简单的小例子：</p>
<ul>
<li>1.父组件传递了todos数组给子组件</li>
<li>2.子组件通过props接受了数组数据，这里应该没有任何问题</li>
<li>3.子组件拿到数组后v-for渲染列表，并且通过 <slot :todo="todo">的方式，把数组内的每一个todo对象，传递给父组件</li>
<li>4.父组件通过slot-scope=”slotProps”的方式，接受todo对象，之后就可以通过slotProps.todo.xxx的方式来使用了</li>
</ul>
<p>所以数据的流动经历了</p>
<ul>
<li>父组件传递todos数组给子组件</li>
<li>子组件遍历todos数组，把里面的todo对象传递给父组件</li>
</ul>
<h4 id="Swiper"><a href="#Swiper" class="headerlink" title="Swiper"></a><strong>Swiper</strong></h4><p>左右滑动插件 npm i swiper -D 先下载 ——<em>可以去官网查看html结构，这样写会有好的css样式</em></p>
<p>import Swiper from ‘swiper’</p>
<h4 id="阿里巴巴iconfont"><a href="#阿里巴巴iconfont" class="headerlink" title="阿里巴巴iconfont"></a><strong>阿里巴巴iconfont</strong></h4><p>inconfont矢量标记图标。登录账号，选择图标添加购物车，生成网上链接，可以直接使用。<em>使用方式</em> 去官网看。</p>
<h4 id="Svg图片"><a href="#Svg图片" class="headerlink" title="Svg图片"></a>Svg图片</h4><p>可以做验证码</p>
<h4 id="router-back"><a href="#router-back" class="headerlink" title="$router.back()"></a>$router.back()</h4><p>&lt;a href=”javascript:” class=”go_back” @click=”$router.back()”&gt;</p>
<p>返回到之前的路由</p>
<p>$route 代表当前路由</p>
<h4 id="postman"><a href="#postman" class="headerlink" title="postman"></a>postman</h4><p>创建集合，以便归类请求</p>
<h4 id="封装ajax请求"><a href="#封装ajax请求" class="headerlink" title="封装ajax请求"></a>封装ajax请求</h4><h4 id="跨域问题的解决"><a href="#跨域问题的解决" class="headerlink" title="跨域问题的解决"></a>跨域问题的解决</h4><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><h4 id="01"><a href="#01" class="headerlink" title="01"></a>01</h4><ol>
<li><p>项目开发准备</p>
<ul>
<li>项目描述</li>
<li>技术选型</li>
<li>API接口（接口文档 -&gt; postman 测接口）</li>
<li>从此项目学到什么</li>
</ul>
</li>
<li><p>开启项目开发</p>
<ul>
<li>使用脚手架创建项目</li>
<li>安装依赖</li>
<li>开发环境运行</li>
<li>生产环境打包与发布</li>
</ul>
</li>
<li><p>搭建项目整体界面结构</p>
<ul>
<li><p>stylus的理解和使用（结构化，变量，函数/minxin（混合</p>
</li>
<li><p>vue-router的理解和使用</p>
<ul>
<li>router-view/router-link/keep-alive</li>
<li>$router: 路由对象，包含一些操作路由的功能函数，来实现编程式导航（跳转路由）</li>
<li>$route: 当前路由对象，一些当前路由信息数据的容器，path/meta/query/params</li>
</ul>
</li>
<li><p><strong>项目路由拆分</strong></p>
<p>一般组件和导航路由组件</p>
</li>
<li><p>抽取组件</p>
</li>
<li><p>登录路由组件</p>
</li>
<li><p>后台项目</p>
</li>
<li><p>前后台交互</p>
<p>ajax请求库：axios</p>
<p>ajax请求函数封装：axios + promise</p>
<p>接口请求函数封装，每个后台接口</p>
</li>
</ul>
</li>
</ol>
<h4 id="02"><a href="#02" class="headerlink" title="02"></a>02</h4>]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack相关</title>
    <url>/2020/03/12/webpack%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h4 id="webpack概念"><a href="#webpack概念" class="headerlink" title="webpack概念"></a>webpack概念</h4><p>本质上，<em>webpack</em> 是一个现代 JavaScript 应用程序的<em>静态模块打包器(module bundler)</em>。当 webpack 处理应用程序时，它会递归地构建一个<em>依赖关系图(dependency graph)</em>，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 <em>bundle</em>。</p>
<a id="more"></a>

<p>1.项目构建工具，基于node.js开发出来的前端工具</p>
<p>2.webpack能够处理JS文件的相互依赖关系</p>
<p>2.webpack能处理JS的兼容问题，把高级的、浏览器不识别的语法转换为能识别的</p>
<p>(<strong>vue-cli 会自动配置webpack</strong>）</p>
<h4 id="1-在项目中安装和配置webpack"><a href="#1-在项目中安装和配置webpack" class="headerlink" title="1. 在项目中安装和配置webpack"></a>1. 在项目中安装和配置webpack</h4><ol>
<li><p>运行<u><em>npm install webpack webpack-cli -D</em></u> 命令，安装webpack相关的包</p>
</li>
<li><p>在项目根目录中，创建名为<em>webpack.config.js</em>的webpack配置文件</p>
</li>
<li><p>在webpack的配置文件中，初始化如下基本配置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode: <span class="string">'development'</span> <span class="comment">// mode 用来指定构建模式 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在package.json配置文件中scripts节点下，新增dev脚本如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line"><span class="string">"dev"</span>: <span class="string">"webpack"</span> <span class="comment">// script 节点下的脚本，可以通过npm run 来执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在终端运行 <u>npm run dev</u> 命令，启动webpack进行项目打包 （将index.js 打包为 main.js）</p>
</li>
<li><p>在index.html中可以引用输出文件main.js</p>
</li>
</ol>
<h4 id="2-配置打包的入口与出口"><a href="#2-配置打包的入口与出口" class="headerlink" title="2. 配置打包的入口与出口"></a>2. 配置打包的入口与出口</h4><p><strong>webpack</strong>的<strong>4.x</strong>版本中默认约定：</p>
<ul>
<li>打包的入口文件为 <em>src -&gt; index.js</em>    <em>在这里import js、css资源</em></li>
<li>打包的输出文件为 <em>dist -&gt; main.js</em></li>
</ul>
<p>如果要修改，就在webpack.config.js配置文件中添加一些节点</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(path)</span><br><span class="line"></span><br><span class="line">entry: path.join(__dirname, <span class="string">'./src/index.js'</span>),</span><br><span class="line">output: &#123;</span><br><span class="line">    path: path.join(__dirname, <span class="string">'./dist'</span>),<span class="comment">//输出文件路径</span></span><br><span class="line">    filename: <span class="string">'bundle.js'</span> <span class="comment">// 输出文件的名称</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-配置webpack的自动打包功能"><a href="#3-配置webpack的自动打包功能" class="headerlink" title="3. 配置webpack的自动打包功能"></a>3. 配置webpack的自动打包功能</h4><ol>
<li><p>运行<u><em>npm install webpack-dev-server -D</em></u>命令，安装支持项目<strong>自动打包</strong>的工具</p>
</li>
<li><p>修改<em>package.json -&gt; scripts</em>中的 dev 命令如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">	<span class="string">"dev"</span>: <span class="string">"webpack-dev-server"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将<em>src -&gt; index.html</em> 中，script脚本引用路径，改为“/bundle.js”</p>
</li>
<li><p>运行 <u><em>npm run dev</em></u> 命令，重新进行打包</p>
<p>（这里会自动在根目录中生成一个bundle.js，在内存中生成的，物理目录中看不到）</p>
</li>
<li><p>在浏览器中访问 8080,地址，查看自动打包效果</p>
</li>
</ol>
<p>注意：</p>
<ul>
<li>webpack-dev-server 会启动一个实时打包的http服务器</li>
<li>webpack-dev-server 打包生成的输出文件，默认放到了项目根目录中，而且是虚拟的、看不见的</li>
</ul>
<h4 id="4-html-webpack-plugin生成的预览页面"><a href="#4-html-webpack-plugin生成的预览页面" class="headerlink" title="4. html-webpack-plugin生成的预览页面"></a>4. html-webpack-plugin生成的预览页面</h4><p>（写在前面，</p>
<ol>
<li><p>运行 <u><em>npm install html-webpack-plugin -D</em></u> 命令，安装生成预览页面的插件</p>
</li>
<li><p>修改 webpack.config.js文件头部区域，添加如下配置信息：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入生成预览页面的插件，得到一个构造函数</span></span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"><span class="comment">// 创建插件的实例对象 new出来</span></span><br><span class="line"><span class="keyword">const</span> htmlPlugin = <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">    template: <span class="string">'./src/index.html'</span>,</span><br><span class="line">    filename: <span class="string">'index.html'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改webpack.config.js文件中向外暴露的配置对象，新增如下配置节点：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">plugins:[ htmlPlugin ] <span class="comment">// plugins數組是webpack打包期间会用到的一些插件列表</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="5-配置自动打包相关的参数"><a href="#5-配置自动打包相关的参数" class="headerlink" title="5. 配置自动打包相关的参数"></a>5. 配置自动打包相关的参数</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package.json中配置</span></span><br><span class="line"><span class="comment">// --open 打包完成后自动打开浏览器页面</span></span><br><span class="line"><span class="comment">// --host 配置IP地址</span></span><br><span class="line"><span class="comment">// --port 配置端口</span></span><br><span class="line"><span class="string">"scripts"</span> : [</span><br><span class="line">	<span class="string">"dev"</span>: <span class="string">"webpack-dev-server --open --host 127.0.0.1 --port 8888"</span></span><br><span class="line">],</span><br></pre></td></tr></table></figure>

<h4 id="6-loader打包非js模块"><a href="#6-loader打包非js模块" class="headerlink" title="6. loader打包非js模块"></a>6. loader打包非js模块</h4><p><em>loader</em> 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效<a href="https://www.webpackjs.com/concepts/modules" target="_blank" rel="noopener">模块</a>，然后你就可以利用 webpack 的打包能力，对它们进行处理。</p>
<p>本质上，webpack loader 将所有类型的文件，转换为应用程序的依赖图（和最终的 bundle）可以直接引用的模块。</p>
<p><em>注意，loader 能够</em> <code>import</code> <em>导入任何类型的模块（例如</em> <code>.css</code> <em>文件），这是 webpack 特有的功能，其他打包程序或任务执行器的可能并不支持。我们认为这种语言扩展是有很必要的，因为这可以使开发人员创建出更准确的依赖关系图。</em></p>
<ul>
<li><p>less-loader</p>
</li>
<li><p>sass-loader</p>
</li>
<li><p>url-loader</p>
<p><img src="F:%5Cproject%5CHexo%5Csource_posts%5Cwebpack%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%5C22d.jpg" alt=""></p>
</li>
</ul>
<h4 id="7-打包处理css文件"><a href="#7-打包处理css文件" class="headerlink" title="7. 打包处理css文件"></a>7. 打包处理css文件</h4><ol>
<li><p>运行 *<u>npm i style-loader css-loader -D</u>* 命令，安装处理css文件的loader</p>
</li>
<li><p>在webpack.config.js的module -&gt; rules 数组中，添加loader：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 所有第三方文件模块的匹配规则</span></span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">	rules: [</span><br><span class="line">		&#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">use</span>: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>]&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，test 表示匹配的文件类型，use表示对应要调用的loader</p>
<p>注意：</p>
<ul>
<li>use 数组中指定的loader 顺序是固定的</li>
<li>多个loader的调用顺序是：从后往前调用</li>
</ul>
</li>
</ol>
<h4 id="8-打包处理less文件"><a href="#8-打包处理less文件" class="headerlink" title="8. 打包处理less文件"></a>8. 打包处理less文件</h4><ol>
<li><p>运行 <u><em>npm i less-loader less -D</em></u> 命令</p>
</li>
<li><p>在webpack.config.js 的module -&gt; rules 数组中，添加loader:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 所有第三方文件模块的匹配规则</span></span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">	rules: [</span><br><span class="line">		&#123; <span class="attr">test</span>: <span class="regexp">/\.less$/</span>, <span class="attr">use</span>: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'less-loader'</span>]&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="9-打包处理sass文件"><a href="#9-打包处理sass文件" class="headerlink" title="9. 打包处理sass文件"></a>9. 打包处理sass文件</h4><ol>
<li><p>运行 <u><em>npm i sass-loader node-sass -D</em></u> 命令</p>
</li>
<li><p>在webpack.config.js 的module -&gt; rules 数组中，添加loader:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 所有第三方文件模块的匹配规则</span></span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">	rules: [</span><br><span class="line">		&#123; <span class="attr">test</span>: <span class="regexp">/\.scss$/</span>, <span class="attr">use</span>: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'sass-loader'</span>]&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="10-配置postCSS-自动添加css的兼容前缀"><a href="#10-配置postCSS-自动添加css的兼容前缀" class="headerlink" title="10. 配置postCSS 自动添加css的兼容前缀"></a>10. 配置postCSS 自动添加css的兼容前缀</h4><ol>
<li><p>运行 <u><em>npm i postcss-loader autoprofixer -D</em></u> 命令</p>
</li>
<li><p>在项目根目录中创建 postcss 的配置文件 postcss.config.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> autoprofixer = <span class="built_in">require</span>(<span class="string">'autoprofixer'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins:[autoprofixer]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在webpack.config.js的module -&gt; rules 数组中，修改css的loader：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">	rules: [</span><br><span class="line">		&#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">use</span>: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'postcss-loader'</span>]&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="11-打包样式表中的图片和文字文件"><a href="#11-打包样式表中的图片和文字文件" class="headerlink" title="11. 打包样式表中的图片和文字文件"></a>11. 打包样式表中的图片和文字文件</h4><ol>
<li><p>运行 <u><em>npm i url-loader file-loader</em> -D</u> 命令</p>
</li>
<li><p>在webpack.config.js 的module -&gt; rules数组中，添加loader：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">	rules: [</span><br><span class="line">		&#123; <span class="attr">test</span>: <span class="regexp">/\.jpg|png|gif|bmp|ttf|svg|woff|woff2$/</span>, <span class="attr">use</span>:<span class="string">'url-loader?limit=16940'</span>&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中？之后的是loader的<strong>参数项</strong></p>
<p>limit 用来指定图片的大小，单位是字节（byte），只有小于limit大小的图片，才会被转为 base64 图片</p>
</li>
</ol>
<h4 id="12-打包处理js文件中的高级语法"><a href="#12-打包处理js文件中的高级语法" class="headerlink" title="12.  打包处理js文件中的高级语法"></a>12.  打包处理js文件中的高级语法</h4><ol>
<li><p>安装babel转换器相关的包：<em>npm i babel-loader @babel/core  @babel/runtime -D</em></p>
</li>
<li><p>安装babel语法插件相关的包： <em>npm i @babel/preset-env @babel/plugin-transform-runtime @babel/plugin-proposal-class-properties -D</em></p>
</li>
<li><p>在项目根目录中，创建babel配置文件，babel.config.js，并初始化基本配置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    presets: [<span class="string">'@babel/preset-env'</span>]</span><br><span class="line">    plugins: [<span class="string">'@babel/preset-env'</span>, <span class="string">'@babel/plugin-transform-runtime'</span>, <span class="string">'@babel/plugin-proposal-class-properties'</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li><p>在webpack.config.js的module -&gt; rules数组中，已添加loader规则：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">test</span>: <span class="regexp">/\.js$/</span>, <span class="attr">use</span>:<span class="string">'babel-loader'</span>, <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>&#125;</span><br></pre></td></tr></table></figure>

<p>其中，exclude为排除项，表示babel-loader不需要处理node_modules中的js文件</p>
</li>
</ol>
<h4 id="13-打包vue组件"><a href="#13-打包vue组件" class="headerlink" title="13. 打包vue组件"></a>13. 打包vue组件</h4><p>.vue文件，需要安装相关的loader </p>
<p><u><em>npm i vue-loader vue-temlate-compiler -D</em></u></p>
<p>在webpack.config.js配置文件中，新增loader配置项</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">test</span>: <span class="regexp">/\.vue$/</span>, <span class="attr">use</span>: <span class="string">'vue-loader'</span> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结梳理：webpack中如何使用vue："><a href="#总结梳理：webpack中如何使用vue：" class="headerlink" title="总结梳理：webpack中如何使用vue："></a>总结梳理：webpack中如何使用vue：</h3><p>1.安装vue的包：<u><em>npm i vue -S</em></u></p>
<p>2.由于在webpack中，推荐使用.vue这个组件模板文件定义组件，所以，需要安装 能解析这种文件的loader  <u><em>cnpm i vue-template-complier -D</em></u></p>
<p>3.在main.js中，导入vue模块 import Vue from ‘vue’</p>
<p>4.定义一个.vue结尾的组件，其中，组件有三部分组成：template script style </p>
<p>5.使用import导入这个组件</p>
<p>6.创建vm的实例，var vm = new Vue（ {el: ‘#app’, render: c=&gt; c(login) })</p>
<p>7.在页面中创建一个id为app的div元素，作为我们vm实例要控制的区域</p>
]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>面试基础篇02</title>
    <url>/2020/02/26/%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80%E7%AF%8702/</url>
    <content><![CDATA[<h4 id="面试基础篇02"><a href="#面试基础篇02" class="headerlink" title="面试基础篇02"></a>面试基础篇02</h4><a id="more"></a>

<h4 id="1-var-a"><a href="#1-var-a" class="headerlink" title="1.var a = ?;"></a>1.var a = ?;</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//var a = ?;</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    n: <span class="number">0</span>,</span><br><span class="line">    <span class="comment">//私有的属性方法</span></span><br><span class="line">    toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ++ <span class="keyword">this</span>.n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//a.toString() //此时调取的不是Object.prototype.toString了，调取的是自己私有的方法</span></span><br><span class="line"><span class="keyword">if</span> ( a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a ==<span class="number">3</span> ) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'ok'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	== 進行比较，如果左右两边数据类型不一样，则先转换为相同的数据类型，然后再进行比较</span></span><br><span class="line"><span class="comment">	1.&#123;&#125; == &#123;&#125; 不相等，两个对象进行比较，比较的是堆内存的地址</span></span><br><span class="line"><span class="comment">	2.null == undefined 相等， null === undefined 不相等</span></span><br><span class="line"><span class="comment">	3.NaN == NaN 都不成立， NaN和谁都不相等</span></span><br><span class="line"><span class="comment">	4.[12] == '12' 成立，对象和字符串比较，是把对象toString转化为字符串后进行类型比较</span></span><br><span class="line"><span class="comment">	5.剩余所有情况在进行比较的时候，都是转换为数字（前提数据类型不一样）</span></span><br><span class="line"><span class="comment">	对象转数字：先toString转换为字符串，然后再转换为数字</span></span><br><span class="line"><span class="comment">	字符串转数字：只要传一个非数字字符，结果就是NaN</span></span><br><span class="line"><span class="comment">	布尔转数字：true -&gt; 1  false -&gt; 0</span></span><br><span class="line"><span class="comment">	null转数字：0</span></span><br><span class="line"><span class="comment">	undefined转数字 NaN</span></span><br><span class="line"><span class="comment">	*[12] == true =&gt; Number([12].toString()) == 1 fasle</span></span><br><span class="line"><span class="comment">	*[1] == trur =&gt; 1 == 1 true</span></span><br><span class="line"><span class="comment">	*[] == false =&gt; 0 == 0 true</span></span><br><span class="line"><span class="comment">	*[] == 1     =&gt; 0 == 1 false</span></span><br><span class="line"><span class="comment">	*'1' == 1    =&gt; 1 == 1 true</span></span><br><span class="line"><span class="comment">	*true == 2	 =&gt; 1 == 2 false</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//shift(); 删除数组第一项，把删除的内容返回，原有数组改变</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">a.toString = a.shift;  <span class="comment">//添加私有的toString方法</span></span><br><span class="line"><span class="keyword">if</span> ( a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a ==<span class="number">3</span> ) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'ok'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">es6中新增加的一些方法</span></span><br><span class="line"><span class="comment">	String.fromCharCode() </span></span><br><span class="line"><span class="comment">	Array.from()</span></span><br><span class="line"><span class="comment">	Array.isArray()</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="2-let-obj"><a href="#2-let-obj" class="headerlink" title="2.let obj = {"></a>2.let obj = {</h4><h4 id=""><a href="#" class="headerlink" title="}"></a>}</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.push = <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>[<span class="keyword">this</span>.length] = val</span><br><span class="line">    <span class="comment">//this.length在原来的基础上加1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*[12, 23].push(100)</span></span><br><span class="line"><span class="comment">[12, 23, 100]</span></span><br><span class="line"><span class="comment">arr=[12,23]</span></span><br><span class="line"><span class="comment">arr[arr.length] = 100;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="number">2</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="number">3</span>: <span class="number">4</span>,</span><br><span class="line">    length: <span class="number">2</span>,</span><br><span class="line">    push: <span class="built_in">Array</span>.prototype.push</span><br><span class="line">&#125;</span><br><span class="line">obj.push(<span class="number">1</span>)</span><br><span class="line">obj.push(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>前端面试</tag>
      </tags>
  </entry>
  <entry>
    <title>面试基础篇01</title>
    <url>/2020/02/23/%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80%E7%AF%8701/</url>
    <content><![CDATA[<h4 id="面试基础篇01"><a href="#面试基础篇01" class="headerlink" title="面试基础篇01"></a>面试基础篇01</h4><a id="more"></a>

<h4 id="1-call-和-apply-的区别是什么，哪个性能更好一些？"><a href="#1-call-和-apply-的区别是什么，哪个性能更好一些？" class="headerlink" title="1.call 和 apply 的区别是什么，哪个性能更好一些？"></a>1.call 和 apply 的区别是什么，哪个性能更好一些？</h4><p>答：1.都是function原型上的方法，每一個函數作爲function函數的实例，可以调取原型上的call和apply方法；2.都是改变this指向的，唯一区别是call是一个个传参，而apply是以数组的形式传参。3.相类似方法bind，但是没有立即执行这个方法，预先处理改变this指向（异步可以用）。4.call性能要优于apply（尤其是传递给函数的参数超过三个的时候），所以开发的时候使用call多一点。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fn.call(obj, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>); <span class="comment">// 傳參是一個個</span></span><br><span class="line">fn.apply(obj, [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>]);<span class="comment">// 以數組的形式保存起來</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>];</span><br><span class="line">	obj = &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x, y, z</span>) </span>&#123;&#125;</span><br><span class="line">fn.apply(obj, arr); <span class="comment">//x=10,y=20,z=30</span></span><br><span class="line">fn.call(obj, arr); <span class="comment">//x=[10, 20, 30] y=z=undefined</span></span><br><span class="line">fn.call(obj, ...arr); <span class="comment">//基于ES6的展开运算符也可以实现把数组中的每一项依次传递给函数</span></span><br></pre></td></tr></table></figure>

<p>自己实现性能测试（只供参考）：任何的代码性能测试都是和测试的环境有关系的，例如CPU、内存、GPU等电脑当前性能。（电脑性能一般不稳定）</p>
<p><strong>console.time</strong>可以测试出一段程序执行的时间</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.time(<span class="string">'A'</span>);</span><br><span class="line"><span class="comment">//let t1 = new Date();</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;<span class="number">1000000</span>; i++)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//console.log(new Date() - t1);</span></span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'A'</span>);</span><br></pre></td></tr></table></figure>

<h4 id="2-实现-5-add-3-minus-2-使其结果输出为：6"><a href="#2-实现-5-add-3-minus-2-使其结果输出为：6" class="headerlink" title="2.实现(5).add(3).minus(2), 使其结果输出为：6"></a>2.实现(5).add(3).minus(2), 使其结果输出为：6</h4><p><em>arr.push();</em></p>
<p><em>arr是Array的实例，可以调用Array.prototype上的方法，push就是Array.prototype上的一个方法。</em></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">~<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//每一個方法執行完，都要返回Number这个类的实例，这样才可以继续调取Number类原型中的方法（链式写法）</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">        n = <span class="built_in">Number</span>(n);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isNaN</span>(n) ? <span class="number">0</span> : n;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">        n = check(n);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span> + n; </span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">minus</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">         n = check(n);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span> - n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Number</span>.prototype.add = add;</span><br><span class="line">    <span class="built_in">Number</span>.prototype.minus = minus;</span><br><span class="line"> <span class="comment">/* ["add", "minus"].forEach(item =&gt; &#123;</span></span><br><span class="line"><span class="comment">        Number.prototype[item] = eval(item);</span></span><br><span class="line"><span class="comment">    &#125;);*/</span></span><br><span class="line">&#125;();</span><br><span class="line"><span class="built_in">console</span>.log((<span class="number">5</span>).add(<span class="number">3</span>).minus(<span class="number">2</span>));</span><br></pre></td></tr></table></figure>

<h4 id="3-箭头函数与普通函数（function）的区别是什么？-构造函数（function）可以使用new生成实例，那么箭头函数可以吗？-为什么？"><a href="#3-箭头函数与普通函数（function）的区别是什么？-构造函数（function）可以使用new生成实例，那么箭头函数可以吗？-为什么？" class="headerlink" title="3.箭头函数与普通函数（function）的区别是什么？ 构造函数（function）可以使用new生成实例，那么箭头函数可以吗？  为什么？"></a>3.箭头函数与普通函数（function）的区别是什么？ 构造函数（function）可以使用new生成实例，那么箭头函数可以吗？  为什么？</h4><p>1.箭头函数es6语法比普通函数更简洁</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">functuon fn (x)&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> fn = <span class="function">(<span class="params">x</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">y</span>) =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2.箭头函数没有自己的this，他里面this是继承函数所处的上下文中的this，使用call/apply无法改变this的指向</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'OBJ'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);  <span class="comment">//this 指向obj</span></span><br><span class="line">&#125;</span><br><span class="line">fn1.call(obj);</span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">let</span> fn2 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);	<span class="comment">//this 指向window</span></span><br><span class="line">&#125;</span><br><span class="line">fn2.call(obj);</span><br></pre></td></tr></table></figure>

<h4 id="4-如何把一个字符串的大小写取反，例如‘AbC’变成’aBc’"><a href="#4-如何把一个字符串的大小写取反，例如‘AbC’变成’aBc’" class="headerlink" title="4.如何把一个字符串的大小写取反，例如‘AbC’变成’aBc’"></a>4.如何把一个字符串的大小写取反，例如‘AbC’变成’aBc’</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'abcdEFG的單詞！*'</span>;</span><br><span class="line"><span class="comment">/*for (let str i=0; i&lt;str.length; i++) &#123;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="comment">//正則</span></span><br><span class="line">str = str.replace(<span class="regexp">/[a-zA-Z]/g</span>, (content) =&gt; &#123;</span><br><span class="line">    <span class="comment">//content：每一次正则匹配的结果</span></span><br><span class="line">    <span class="comment">//验证是否为大写字母；把字母转换为大写后看和之前是否一样，如果一样，那么之前也是大写的；在ASCII表中找到大学字母的取值范围进行判断（65-90）。</span></span><br><span class="line">     <span class="comment">//content.charCodeAt()&gt;=65 &amp;&amp; content.charCodeAt()&lt;=90</span></span><br><span class="line">    <span class="keyword">return</span> content.toUpperCase() === content ? content.toLowerCase() : content.toUpperCase();</span><br><span class="line">   </span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(str);</span><br></pre></td></tr></table></figure>

<h4 id="5-实现一个字符串匹配算法，从字符串S中，查找是否存在字符串T，若存在-返回所在位置，不存在返回-1"><a href="#5-实现一个字符串匹配算法，从字符串S中，查找是否存在字符串T，若存在-返回所在位置，不存在返回-1" class="headerlink" title="5.实现一个字符串匹配算法，从字符串S中，查找是否存在字符串T，若存在 返回所在位置，不存在返回-1."></a>5.实现一个字符串匹配算法，从字符串S中，查找是否存在字符串T，若存在 返回所在位置，不存在返回-1.</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">indexOf/includes <span class="comment">//内置方法</span></span><br><span class="line">~<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;			<span class="comment">//闭包</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    循环原始字符串中的每一项，让每一项从当前位置向后截取			T.length个字符，和T比较，如果不一样，继续循环；如果一样</span></span><br><span class="line"><span class="comment">    返回当前索引值即可，循环结束；</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">myIndexOf</span>(<span class="params">T</span>)</span>&#123;</span><br><span class="line">      <span class="comment">//this：S</span></span><br><span class="line">    	<span class="keyword">let</span> lenT = T.length,</span><br><span class="line">      	 	lenS = <span class="keyword">this</span>.length，</span><br><span class="line">        	res = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(lenT&gt;lenS)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= lenS - lenT; i++)&#123;</span><br><span class="line">        	<span class="keyword">if</span>(<span class="keyword">this</span>.substr(i,lenT) === T)&#123;</span><br><span class="line">                res = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">       	 <span class="keyword">return</span> res;<span class="comment">//从当前字符i，截取lenT个，并与T对比。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用正则的方式做</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">myIndexOf</span>(<span class="params">T</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(T), <span class="comment">//这里是把T字符串变成了正则</span></span><br><span class="line">            res = reg.exec(<span class="keyword">this</span>);</span><br><span class="line">      	<span class="keyword">return</span> res === <span class="literal">null</span> ? <span class="number">-1</span> :res.index;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//把myIndexOf这个方法挂载到String的原型方法上</span></span><br><span class="line">    <span class="built_in">String</span>.prototype.myIndexOf = myIndexOf;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> S = <span class="string">'helloworld'</span>,</span><br><span class="line">	T = <span class="string">'world'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(S.myIndexOf(T));</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>前端面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>Nodejs相关</title>
    <url>/2020/02/18/Nodejs%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h4 id="NodeJS"><a href="#NodeJS" class="headerlink" title="NodeJS"></a>NodeJS</h4><p>前言：学了node的一些基础知识，理解了node的语法和建立服务器 连接数据库相关的知识。然后登录注册退出功能已完成。后续的学习把后台管理和展示内容部分做出来，然后部署上下测试。</p>
<a id="more"></a>

<p>2020.2.18</p>
<ul>
<li><strong>在ES6中</strong>，<em>导入模块</em>：import 模块名称 from ‘模块标识     import ’表示路径‘</li>
<li><em>向外暴露成员</em>：export default   和export</li>
<li><strong>在Node中</strong>，<em>导入模块</em>  使用 var 名称 = require(‘模块标识符’)</li>
<li><em>向外暴露成员</em>：module.exports 和exports来暴露成员</li>
</ul>
]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>mongodb</title>
    <url>/2020/02/18/mongodb%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h4 id="Mongodb："><a href="#Mongodb：" class="headerlink" title="Mongodb："></a>Mongodb：</h4><p>MongoDB是一个基于分布式文件存储的数据库，由<a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=51909&ss_c=ssc.citiao.link" target="_blank" rel="noopener">C++语言</a>编写。旨在为WEB应用提供可扩展的高性能数据<a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=63516207&ss_c=ssc.citiao.link" target="_blank" rel="noopener">存储解决方案</a>。</p>
<a id="more"></a>

<ul>
<li><p>在node.js中开启mongodb       mongod –dbpath 存放data\db的路径  （F:/mongodb/data/db）</p>
</li>
<li><p>node.js中连接数据库，用mongoose</p>
</li>
<li><p>model里面的</p>
<p>var mongoose = require(‘mongoose’)</p>
<p>// 连接数据库,只需连接一次<br>mongoose.connect(‘mongodb://localhost/blog’)</p>
<p>var Schema = mongoose.Schema</p>
<p>var userSchema = new Schema({<br>  email: {</p>
<pre><code>type: String,
required: true</code></pre><p>  },……数据集合</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title>npm相关</title>
    <url>/2020/02/18/npm%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h2 id="npm的常用操作"><a href="#npm的常用操作" class="headerlink" title="npm的常用操作"></a>npm的常用操作</h2><table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>npm init -y</td>
<td>初始化项目 会生成package.json和package-lock.json</td>
</tr>
<tr>
<td>npm install</td>
<td>安装  ，简写：npm  i</td>
</tr>
<tr>
<td>npm  i  express  mongoose</td>
<td>一次性安装多个模块</td>
</tr>
<tr>
<td>npm i -S</td>
<td>保存依赖</td>
</tr>
<tr>
<td>npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a></td>
<td>安装全局cnpm，使用淘宝镜像</td>
</tr>
<tr>
<td>npm -v</td>
<td>查看npm的版本</td>
</tr>
<tr>
<td>npm install npm -g</td>
<td>用npm来安装最新的npm</td>
</tr>
<tr>
<td>npm root</td>
<td><em>查看项目中模块所在的目录</em></td>
</tr>
<tr>
<td>npm root -g</td>
<td>查看全局安装的模块所在目录</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>Typora常用快捷键</title>
    <url>/2020/02/16/Typora%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<h4 id="Typora编写markdown快捷键"><a href="#Typora编写markdown快捷键" class="headerlink" title="Typora编写markdown快捷键"></a>Typora编写markdown快捷键</h4><a id="more"></a>

<ul>
<li><p>无序列表：输入-之后输入空格</p>
</li>
<li><p>有序列表：输入数字+“.”之后输入空格</p>
</li>
<li><p>任务列表：-[空格]空格 文字</p>
</li>
<li><p>标题：ctrl+数字</p>
<h3 id="ctrl-数字"><a href="#ctrl-数字" class="headerlink" title="ctrl+数字"></a>ctrl+数字</h3></li>
<li><p>表格：ctrl+t</p>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><p>生成目录：[TOC]按回车</p>
</li>
<li><p>选中一整行：ctrl+l</p>
</li>
<li><p>选中单词：ctrl+d</p>
</li>
<li><p>选中相同格式的文字：ctrl+e</p>
</li>
<li><p>跳转到文章开头：ctrl+home</p>
</li>
<li><p>跳转到文章结尾：ctrl+end</p>
</li>
<li><p>搜索：ctrl+f</p>
</li>
<li><p>替换：ctrl+h</p>
</li>
<li><p>引用：输入&gt;之后输入空格</p>
</li>
</ul>
<blockquote>
<p>引用格式</p>
</blockquote>
<ul>
<li>代码块：ctrl+alt+k</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'hello'</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>加粗：<strong>ctrl+b</strong></p>
</li>
<li><p>倾斜：<em>ctrl+i</em></p>
</li>
<li><p>下划线：<u>ctrl+u</u></p>
</li>
<li><p>删除线：<del>alt+shift+5</del></p>
</li>
<li><p>插入图片：直接拖动到指定位置即可或者ctrl+shift+i  也可以右击插入图片</p>
</li>
<li><p>插入链接：<a href="">ctrl+k</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Typora技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>MGQ时尚风云中</title>
    <url>/2020/02/16/MGQ%E6%97%B6%E5%B0%9A%E9%A3%8E%E4%BA%91%E4%B8%AD/</url>
    <content><![CDATA[<p><img src="F:%5Cproject%5CHexo%5Cthemes%5Cicarus%5Csource%5Cimages%5Cavatar.png" alt=""></p>
<h2 id="《明星大侦探第五季》第七案《MGQ时尚风云中》分析"><a href="#《明星大侦探第五季》第七案《MGQ时尚风云中》分析" class="headerlink" title="《明星大侦探第五季》第七案《MGQ时尚风云中》分析"></a>《明星大侦探第五季》第七案《MGQ时尚风云中》分析</h2><p>今天这一期的案件是发生在MGQ时尚杂志社里。杂志社的同事们约好在晚上十点给何社长办生日会，但是却在10点10分的时候发现杂志社的甄主编死在了楼梯间。</p>
<a id="more"></a>

<ul>
<li>本期侦探：何社长</li>
<li>涉案人员</li>
</ul>
<p>撒时装：40岁，与甄主编是上下级的关系，入职20年,身高175CM</p>
<p>侯助理：22岁，与甄主编并没有什么来往，入职一年，身高178CM</p>
<p>蓉美妆：30岁，与甄主编是师徒关系，入职八年，身高175CM</p>
<p>贾美妆：22岁，与甄主编是上下级的关系，入职一年，身高178CM</p>
<p>魏秘书：24岁，是甄主编的助理，入职不到一年，身高178CM</p>
<ul>
<li>死者：甄主编：42岁，入职22年。死因，被丝巾勒死，尸体放在了楼梯间的硬纸箱里，身高178CM</li>
</ul>
<p>郝秘书：2019年12月29日，因过劳死在了公司茶水间，时年30岁。</p>
<h4 id="案发时间梳理"><a href="#案发时间梳理" class="headerlink" title="案发时间梳理"></a>案发时间梳理</h4><p>根据线索，甄主编原本计划是在晚上9点50分回到公司，但是在何的朋友圈留言，显示其在8：05的时候就已经回来了。</p>
<p>根据保安的证词，甄主编在晚上9：30的时候又离开了公司。</p>
<p>根据现有的证据显示，甄主编是在晚上9：30-10：10间遇害身亡。</p>
<ul>
<li>在后面的证据搜索中，发现以下几个线索：</li>
</ul>
<ol>
<li>在撒和侯的办公室发现了一套与死者一模一样的衣服，还有一个灯光控制器</li>
<li>在整点的时候，保洁会来打扫卫生；在半点的时候保安会巡视</li>
<li>死者所在的楼梯间在晚上9：20-9：25的时候有油漆工人给地板刷油漆，而油漆在晚上9：35之前不会干</li>
<li>茶水间监控于2018年12月30日进行更换，并且每一个小时缓存一次</li>
<li>在茶水间的视频中可以看到，在晚上9：30的时候茶水间的门自动开了，甄主编出现在了茶水间外面，进入了楼梯间，然后灯灭了，过了15秒灯亮起，楼梯间的门紧紧关着。</li>
<li>据悉，从楼梯间的后门连接的是停车场，从后门回到正门需要半个小时</li>
<li>楼梯间的门只能由甄主编从里面开，其他人只能从杂志社内从楼梯间的外面开门</li>
</ol>
<ul>
<li>由以上证据，可以作出以下几个假设：</li>
</ul>
<ol>
<li>监控里出现的就是甄主编，甄主编是在9：30之后被害</li>
<li>监控视频里是凶手伪装的甄主编，甄主编在这很短的时间里遇害，凶手又在15秒的黑暗时间里离开楼梯间。</li>
<li>死者在9：20前就已经遇害，而凶手伪装成甄主编的样子，假装甄主编是在9：30之前遇害的假象。伪造不在场证明。</li>
</ol>
<p>根据分析，第三点假设更加成立。但是根据第三条线索，凶手在9：30今日楼梯，鞋底必然会沾上油漆，但是在现场的鞋子上并没有发现油漆，而根据监控视频，凶手确实是进入到了楼梯间。</p>
<p>那么只有一种可能，凶手并没有进入楼梯间。凶手伪造了现场。在现场找到了两面可以推动的镜子，通过实验发现，凶手是通过镜面的折射，伪造了进入楼梯间的假象，实则进入的是旁边的甄主编的办公室。</p>
<p>凶手在9：30的时候将镜子摆放成如图的样子，然后用力推开茶水间的门，伪装成甄主编的样子进入旁边的甄主编的办公室，在15秒的黑暗时间，将镜子推走。就这样伪造了一个监控视频。</p>
<p>由此可以确认甄主编在9：20之前就已经死亡了。</p>
<p>而根据涉案人员陈述的时间点，每个人都没有不在场证明。</p>
<ul>
<li>下面从每个人的动机分析</li>
</ul>
<ol>
<li>撒时装：家庭负担重，但是甄主编辞退了他，并表示会在何的生日会上宣布这件事。撒又因为年纪的原因被其他公司拒绝。</li>
<li>蓉美妆：与郝秘书曾经是恋爱关系。但是发现郝秘书赌博，并且并不是像大家以为的兢兢业业，而是在办公室进行网络赌博，所以相与郝秘书分手。郝秘书以曝光蓉的私照与谈恋爱的秘密为要挟，向蓉勒索。蓉与郝在茶水间争执，蓉失手将郝推倒，导致郝死亡。甄看到了，帮助蓉将现场伪造成郝过劳死。后来贾在一个月内得到了蓉奋斗了五年的职位，蓉又听到了贾威胁蓉的话，以为甄把自己的事情告诉了贾，所以怀恨在心。</li>
<li>贾美妆：他看到了甄与蓉的做的事情，于是威胁甄得到升职的机会。在最后一次威胁的时候，贾希望得到副主编的位置，但是甄主编表示，自己会在生日会的时候宣布离职，主编的位置会留给贾。但是就在26日的晚上八点四十分，贾知道了，甄已经和另一家杂志社签订了合同，并打算带走MGQ杂志社内所有的核心编辑。</li>
<li>魏秘书：他是名校毕业，原本在一家杂志社担任编辑，但是在甄主编的聘用下，决定来MGQ当秘书，但是干的是和编辑不相干的事情。他接到了一通以“郝秘书”的名义打来的电话，而且灯光熄灭，气氛非常诡异，而在电话里说，魏的下场就会和郝的下场一样。接下来他又收到了“郝秘书”送来的血书。因为“郝秘书”称他为“魏秘书”而不是“喂”，他觉得自己得到了尊重，所以，经常通过打字机与“郝秘书”聊天。而在任职期间，魏秘书希望可以去体检，但是甄主编却以工作为由，拒绝了他体检的理由。然后魏秘书就收到了诊断书，他患有百分之九十的心肌坏死，严重过劳，并且已经到了生命的尽头，所以他对杂志社的所有人都怀恨在心。他买了易燃的地毯，没有换甄主编让他换的地毯，买了蜡烛。只要何在10点10分吹蜡烛，就会引火。</li>
<li>侯助理：是郝秘书的弟弟，来公司调查哥哥的死因。在此期间，他文章被以撒的名义刊登在了撒主持编辑的版块。他又发现了魏秘书的境况，伪装成“郝秘书”与魏秘书交流，所以他用过灯光控制器。他意外收到了魏秘书的诊断书，将诊断书上的百分之十改成了百分之九十，诱导魏秘书对杂志社的人进行报复。</li>
</ol>
<p>根据以上线索，可以排除掉蓉，因为勒死一个身高比自己高的成年女性，还要在15秒内将两面大镜子推走，对于蓉来说是吃力的。</p>
<p>可以排除掉侯，因为侯已经利用了魏秘书，只需要等待魏秘书行动了。</p>
<p>至于撒和贾，并没有明确的计划，他们其实在在茶水间里等待机会。</p>
<p>剩下的只有魏了。魏秘书在这个案件中非常关键的一点就是那条地毯。因为甄主编是一个非常苛刻的人，所以当她回来看到地毯不是她要求魏秘书换的那条一定会让魏秘书换掉，而魏秘书的计划就没有办法实施了。但是他没有想到甄主编会提前回来，反正他是打算杀掉所有人，所以提前杀掉甄主编也可以。而如果甄主编一直不出现，所有人一定要会等她出现，所以他伪造了甄主编出去的假象，而所有人可以放心吹蜡烛。</p>
<p>以上就是对于本期《明星大侦探》的分析。</p>
<p>本片文章转自 原创 姑且如此 <a href="javascript:void(0);">不得甚解</a> <em>1月2日</em>  <em>侵私删</em></p>
]]></content>
      <tags>
        <tag>案件</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/02/16/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
