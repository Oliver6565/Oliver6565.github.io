<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ES6-class关键字02</title>
    <url>/2020/03/25/ES6-class%E5%85%B3%E9%94%AE%E5%AD%9702/</url>
    <content><![CDATA[<h4 id="class关键字-继承"><a href="#class关键字-继承" class="headerlink" title="class关键字(继承)"></a>class关键字(继承)</h4><a id="more"></a>

<p>class-继承</p>
<p>语法： class 子类 extends 父类 {}</p>
<p>父类 Person</p>
<p>子类 American</p>
<p>子类 Chinese</p>
<h5 id="继承公共实例属性"><a href="#继承公共实例属性" class="headerlink" title="继承公共实例属性"></a>继承公共实例属性</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把父类 理解成 原型对象 prototype</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name, age)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    	<span class="keyword">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在class类中，使用extends 关键字，实现子类继承父类</span></span><br><span class="line"><span class="comment">// 语法： class 子类 extends 父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">American</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a1 = <span class="keyword">new</span> American(<span class="string">'Jack'</span>, <span class="number">20</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c1 = <span class="keyword">new</span> Chinese(<span class="string">'张三'</span>, <span class="number">22</span>)</span><br><span class="line"><span class="built_in">console</span>.log(c1)</span><br></pre></td></tr></table></figure>

<h5 id="继承公共实例方法"><a href="#继承公共实例方法" class="headerlink" title="继承公共实例方法"></a>继承公共实例方法</h5><p>子类通过extends 关键字继承了父类，那么子类的 constructor 构造函数中，必须先调用一下 super() </p>
<p>super是一个函数 其实就是父类的 构造器</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name, age)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    	<span class="keyword">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实例方法</span></span><br><span class="line">    sayHello()&#123;</span><br><span class="line">        consolo.log(<span class="string">'大家好'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">American</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name, age)&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a1 = <span class="keyword">new</span> American(<span class="string">'Jack'</span>, <span class="number">20</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a1)</span><br><span class="line"><span class="built_in">console</span>.log(a1.sayHello)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name, age, IDNumber)&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, age)</span><br><span class="line">        <span class="keyword">this</span>.IDNumber = IDNumber	<span class="comment">//挂载子类独有的实例属性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c1 = <span class="keyword">new</span> Chinese(<span class="string">'张三'</span>, <span class="number">22</span>, <span class="string">'130020*****'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(c1)</span><br><span class="line"><span class="built_in">console</span>.log(c1.sayHello)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>Ajax和JSON</title>
    <url>/2020/03/29/Ajax%E5%92%8CJSON/</url>
    <content><![CDATA[<p>ajax and json</p>
<a id="more"></a>

<h5 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h5><blockquote>
<p>Ajax（Asynchronous <a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=2484&ss_c=ssc.citiao.link">JavaScript</a> and XML），用于创建更好更快以及交互性更强的<a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=159605&ss_c=ssc.citiao.link">Web应用程序</a>的技术，与传统的Web应用相比，Ajax通过浏览器与服务器进行少量的数据交换就可以实现网页的异步更新，在不重新加载整个网页的情况下，即可对网页进行更新。</p>
</blockquote>
<h5 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h5><blockquote>
<p>JSON(JavaScriptObject Notation, JS 对象简谱) 是一种<a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=7988600&ss_c=ssc.citiao.link">轻量级</a>的数据交换格式，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。JSON（常用于数据交互）和XML（常用于文件配置）可读性不相上下。</p>
</blockquote>
<p>在JS语言中，一切都是对象，因此任何JS支持的类型，都可以通过JSON来表示，例如字符串、数字、对象数组等。</p>
<ul>
<li>对象表示为键值对</li>
<li>数据由逗号分隔</li>
<li>花括号保存对象</li>
<li>方括号保存数组</li>
</ul>
<p>JSON是JS对象的字符串表示法，它使用文本表示一个JS对象的信息，本质是一个<strong>字符串</strong></p>
<h5 id="JSON和JS对象互转"><a href="#JSON和JS对象互转" class="headerlink" title="JSON和JS对象互转"></a>JSON和JS对象互转</h5><p>从JSON字符串转换为JS对象，使用JSON.parse()方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">JSON</span>.parse(<span class="string">'&#123;"a":"hello","b":"world"&#125;'</span>)</span><br></pre></td></tr></table></figure>

<p>从JS对象转换为JSON字符串，使用JSON.stringify()方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> json = <span class="built_in">JSON</span>.stringify(&#123;<span class="string">"a"</span>:<span class="string">"hello"</span>,<span class="string">"b"</span>:<span class="string">"world"</span>&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="jQuery-parseJSON-函数"><a href="#jQuery-parseJSON-函数" class="headerlink" title="jQuery.parseJSON()函数"></a>jQuery.parseJSON()函数</h5><p>用于将格式完好的JSON字符串转为与之对应的JavaScript对象。</p>
<p>所谓”格式完好”，就是要求指定的字符串必须符合严格的JSON格式，例如：属性名称必须加双引号、字符串值也必须用双引号。</p>
<p>如果传入一个格式不”完好”的JSON字符串将抛出一个JS异常，</p>
<p>例如：以下字符串均符合JSON格式，但它们不是格式完好的JSON字符串(因此会抛出异常)：</p>
<p>// 以下均是字符串值，省略了两侧的引号，以便于展现内容</p>
<p>{id: 1} // id是属性名称，必须加双引号<br>{‘id’: 1} // id是属性名称，必须用双引号(不能用单引号)<br>{“name”: ‘CodePlayer’} // name属性的值是字符串，必须用双引号(不能用单引号)</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>Django Vuejs</title>
    <url>/2020/03/28/Django-Vuejs/</url>
    <content><![CDATA[<p>django with vuejs</p>
<a id="more"></a>

<hr>
<blockquote>
<p>博客：<a href="https://zhuanlan.zhihu.com/p/25080236">https://zhuanlan.zhihu.com/p/25080236</a></p>
<p>github：<a href="https://github.com/tmpbook/django-with-vuejs">https://github.com/tmpbook/django-with-vuejs</a></p>
</blockquote>
<hr>
<img src="/2020/03/28/Django-Vuejs/d1.png" class>]]></content>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6-class关键字01</title>
    <url>/2020/03/25/ES6-class%E5%85%B3%E9%94%AE%E5%AD%9701/</url>
    <content><![CDATA[<h4 id="class关键字"><a href="#class关键字" class="headerlink" title="class关键字"></a>class关键字</h4><a id="more"></a>

<p>class关键字，是实现面向对象编程的新形式</p>
<p>静态属性：通过构造函数，直接访问到的属性，叫做静态属性</p>
<p>实例属性：通过 new 出来的实例 访问到的属性，叫做 实例属性</p>
<h5 id="传统"><a href="#传统" class="headerlink" title="传统"></a>传统</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// info属性 直接挂在给构造函数Person，所以info是静态属性</span></span><br><span class="line">Person.info = <span class="string">'aaaaa'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态方法</span></span><br><span class="line">Person.show = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'这是 Person 的静态 show方法'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将方法say挂在到Person的原型对象上，成为了实例方法</span></span><br><span class="line">Person.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'这是 Person 的实例方法'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Person(<span class="string">'xiaoyi'</span>, <span class="number">18</span>)</span><br><span class="line"><span class="comment">// 通过 new 出来的实例 访问到的属性，叫做 实例属性</span></span><br><span class="line"><span class="built_in">console</span>.log(p1)</span><br><span class="line"><span class="built_in">console</span>.log(p1.name)</span><br><span class="line"><span class="built_in">console</span>.log(p1.age)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 实例对象 .出来的方法，就叫实例方法</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.say)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态方法 和 属性，只能由构造函数访问，实例对象不能访问</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.info)</span><br><span class="line"><span class="built_in">console</span>.log(Person.show)</span><br></pre></td></tr></table></figure>

<h5 id="class创建"><a href="#class创建" class="headerlink" title="class创建"></a>class创建</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 每一个类中，都有一个构造器（或隐藏）；每当new 这个类的时候，必然会优先执行 构造器中的代码</span></span><br><span class="line">    <span class="keyword">constructor</span>(name ,age)&#123;</span><br><span class="line">        <span class="comment">// 实例属性</span></span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">        <span class="keyword">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在class内部，通过static修饰的属性，就是静态属性</span></span><br><span class="line">    <span class="keyword">static</span> info = <span class="string">'aaaaa'</span></span><br><span class="line">	<span class="comment">// 静态方法</span></span><br><span class="line">	<span class="keyword">static</span> show()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'这是 Animal 的静态方法'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这也是挂在到原型对象上的一个实例方法，同say</span></span><br><span class="line">	<span class="comment">// 经常会使用到实例方法</span></span><br><span class="line">	see()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'这是 Animal 的实例方法'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a1 = <span class="keyword">new</span> Animal(<span class="string">'milu,10)</span></span><br><span class="line"><span class="string">console.log(a1)</span></span><br><span class="line"><span class="string">console.log(a1.name)</span></span><br><span class="line"><span class="string">console.log(a1.age)</span></span><br><span class="line"><span class="string">console.log(a1.see)</span></span><br><span class="line"><span class="string">console.log(Animal.info)</span></span><br><span class="line"><span class="string">console.log(Animal.show)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<ol>
<li>在class的 { } 区间内，只能写 构造器、实例方法、静态方法和静态属性，其中 实例属性 在构造器中写</li>
<li>class 关键字的内部 ，还是用原来的方法实现的，所以我们把class关键字，称作 语法糖</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6-展开运算符</title>
    <url>/2020/03/25/ES6-%E5%B1%95%E5%BC%80%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<h4 id="展开运算符（spread-operator）"><a href="#展开运算符（spread-operator）" class="headerlink" title="展开运算符（spread operator）"></a>展开运算符（spread operator）</h4><a id="more"></a>

<p>展开运算符，允许一个表达式在某处展开。展开运算符在多个参数（用于函数调用）或多个元素（用于数组字面量）或者多个变量（用于解构赋值）的地方可以使用。</p>
<p>展开运算符不能用在对象当中，因为目前展开运算符只能在可遍历对象（iterables）可用。iterables的实现是依靠[Symbol.iterator]函数，而目前只有Array,Set,String内置[Symbol.iterator]方法，而Object尚未内置该方法，因此无法使用展开运算符。不过ES7草案当中已经加入了对象展开运算符特性。</p>
<h5 id="函数调用中使用展开运算符"><a href="#函数调用中使用展开运算符" class="headerlink" title="函数调用中使用展开运算符"></a>函数调用中使用展开运算符</h5><p>我们使用…展开运算符就可以把args直接传递给test()函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a,b,c</span>) </span>&#123; &#125;</span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line">test(...args);</span><br></pre></td></tr></table></figure>

<h5 id="数组字面量中使用展开运算符"><a href="#数组字面量中使用展开运算符" class="headerlink" title="数组字面量中使用展开运算符"></a>数组字面量中使用展开运算符</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">var</span> arr2=[...arr1,<span class="string">'d'</span>,<span class="string">'e'</span>]; <span class="comment">//['a','b','c','d','e']</span></span><br></pre></td></tr></table></figure>

<p>展开运算符也可以用在push函数中，可以不用再用apply()函数来合并两个数组：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">var</span> arr2=[<span class="string">'d'</span>,<span class="string">'e'</span>];</span><br><span class="line">arr1.push(...arr2); <span class="comment">//['a','b','c','d','e']</span></span><br></pre></td></tr></table></figure>

<h5 id="用于解构赋值"><a href="#用于解构赋值" class="headerlink" title="用于解构赋值"></a>用于解构赋值</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [arg1,arg2,...arg3] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">arg1 <span class="comment">//1</span></span><br><span class="line">arg2 <span class="comment">//2</span></span><br><span class="line">arg3 <span class="comment">//['3','4']</span></span><br></pre></td></tr></table></figure>

<p>展开运算符在解构赋值中的作用跟之前的作用看上去是相反的，将多个数组项组合成了一个新数组。</p>
<p>不过要注意，解构赋值中展开运算符只能用在最后</p>
<h5 id="类数组对象变成数组"><a href="#类数组对象变成数组" class="headerlink" title="类数组对象变成数组"></a>类数组对象变成数组</h5><p>展开运算符可以将一个类数组对象变成一个真正的数组对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> list=<span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>);</span><br><span class="line"><span class="keyword">var</span> arr=[..list];</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>JWT认证</title>
    <url>/2020/03/29/JWT%E8%AE%A4%E8%AF%81/</url>
    <content><![CDATA[<p>JSON Web Token（JWT）</p>
<a id="more"></a>

<hr>
<blockquote>
<p>学习文档转自 <a href="https://www.cnblogs.com/haha12/p/11796456.html">https://www.cnblogs.com/haha12/p/11796456.html</a></p>
</blockquote>
<hr>
<h5 id="JWT简介"><a href="#JWT简介" class="headerlink" title="JWT简介"></a>JWT简介</h5><p>JSON Web Token（JWT）是一个开放的标准（RFC 7519），它定义了一个紧凑且自包含的方式，用于在各方之间作为JSON对象安全地传输信息。由于此信息是经过数字签名的，因此可以被验证和信任。</p>
<h5 id="JWT认证和session认证的区别"><a href="#JWT认证和session认证的区别" class="headerlink" title="JWT认证和session认证的区别"></a>JWT认证和session认证的区别</h5><ol>
<li><p>session认证</p>
<p>http协议是一种无状态的协议，而这就意味着如果用户向我们的应用提供了用户名和密码来进行用户认证，那么下一次请求时，用户还要再一次进行用户认证才行，因为根据http协议，我们并不能知道是哪个用户发送的请求，所以为了让我们的应用能识别是哪个用户发出的，我们只能在服务器存储一份用户登陆的信息，这份登陆信息会在响应时传递给浏览器，告诉其保存为cookie，以便下次请求时发送给我们的应用，这样我们的应用个就能识别请求来自哪个用户了，这就是传统的基于sessino认证。</p>
</li>
<li><p>JWT认证</p>
<p>基于token的鉴权机制类似于http协议也是无状态的，它不需要在服务端去保留用户的认证信息或会话信息。这也就意味着JWT认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利。</p>
</li>
<li><p>JWT认证流程</p>
<img src="/2020/03/29/JWT%E8%AE%A4%E8%AF%81/j1.png" class>

<p>认证流程如下：</p>
<ol>
<li>用户使用账号和密码发出post请求；</li>
<li>服务器使用私钥创建一个jwt；</li>
<li>服务器返回这个jwt给浏览器；</li>
<li>浏览器将该jwt串在请求头中像服务器发送请求；</li>
<li>服务器验证该jwt；</li>
<li>返回响应的资源给浏览器。</li>
</ol>
</li>
<li><p>JWT组成</p>
<img src="/2020/03/29/JWT%E8%AE%A4%E8%AF%81/j2.png" class>

<p>从上图可以看到，JWT含有三部分：头部（header）、载荷（payload）、签名（signature）。</p>
<p>1.头部</p>
<p>JWT的头部有两部分信息：</p>
<ul>
<li>声明类型，这里是JWT</li>
<li>声明加密的算法，通常直接使用HMAC SHA256</li>
</ul>
<p>头部示例如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"alg"</span>: <span class="string">"HS256"</span>,</span><br><span class="line">  <span class="string">"typ"</span>: <span class="string">"JWT"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>头部一般使用base64加密，加密后密文：eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9</p>
<p>2.载荷</p>
<p>该部分一般存放一些有效的信息。JWT的标准定义包含五个字段：</p>
<ul>
<li>iss：该JWT的签发者</li>
<li>sub: 该JWT所面向的用户</li>
<li>aud: 接收该JWT的一方</li>
<li>exp(expires): 什么时候过期，这里是一个Unix时间戳</li>
<li>iat(issued at): 在什么时候签发的</li>
</ul>
<p>载荷示例如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"sub"</span>: <span class="string">"1234567890"</span>,</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"Java碎碎念"</span>,</span><br><span class="line">  <span class="string">"iat"</span>: <span class="number">1516239022</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.签名</p>
<p>前面两部分都是使用Base64进行编码的，即前端可以解开知道里面的信息。signature 需要使用编码后的header和payload以及我们提供的一个密钥，然后使用header中指定的签名算法（HS256）进行签名。签名的作用是保证 JWT 没有被篡改过。</p>
<p>三个部分通过.连接在一起就是我们的 JWT 了，所以我们生成的JWT如下：</p>
<p><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkphdmHnoo7noo7lv7UiLCJpYXQiOjE1MTYyMzkwMjJ9.LLJIkhJs6SVYlzn3n8fThQmhGutjTDI3RURTLtHV4ls</code></p>
<p>注意：密钥就是用来进行JWT的签发和JWT的验证，所以，它就是你服务端的私钥，在任何场景都不应该泄露出去。</p>
</li>
<li><p>JWT使用场景</p>
<p>JWT主要使用场景如下：</p>
<ul>
<li>授权</li>
</ul>
<p>这是JWT使用最多的场景，一旦用户登录，每个后续的请求将包括JWT，从而允许用户访问该令牌允许的路由、服务和资源。</p>
<ul>
<li>信息交换：JSON</li>
</ul>
<p>JWT可以用在各方之间安全地传输信息，因为JWT可以进行签名，所以您可以确定发件人是他们所说的人。另外，由于签名是使用标头和有效负载计算的，因此您还可以验证内容是否未被篡改。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>验证</tag>
      </tags>
  </entry>
  <entry>
    <title>MGQ时尚风云中</title>
    <url>/2020/02/16/MGQ%E6%97%B6%E5%B0%9A%E9%A3%8E%E4%BA%91%E4%B8%AD/</url>
    <content><![CDATA[<h2 id="《明星大侦探第五季》第七案《MGQ时尚风云中》分析"><a href="#《明星大侦探第五季》第七案《MGQ时尚风云中》分析" class="headerlink" title="《明星大侦探第五季》第七案《MGQ时尚风云中》分析"></a>《明星大侦探第五季》第七案《MGQ时尚风云中》分析</h2><p>今天这一期的案件是发生在MGQ时尚杂志社里。杂志社的同事们约好在晚上十点给何社长办生日会，但是却在10点10分的时候发现杂志社的甄主编死在了楼梯间。</p>
<a id="more"></a>

<ul>
<li>本期侦探：何社长</li>
<li>涉案人员</li>
</ul>
<p>撒时装：40岁，与甄主编是上下级的关系，入职20年,身高175CM</p>
<p>侯助理：22岁，与甄主编并没有什么来往，入职一年，身高178CM</p>
<p>蓉美妆：30岁，与甄主编是师徒关系，入职八年，身高175CM</p>
<p>贾美妆：22岁，与甄主编是上下级的关系，入职一年，身高178CM</p>
<p>魏秘书：24岁，是甄主编的助理，入职不到一年，身高178CM</p>
<ul>
<li>死者：甄主编：42岁，入职22年。死因，被丝巾勒死，尸体放在了楼梯间的硬纸箱里，身高178CM</li>
</ul>
<p>郝秘书：2019年12月29日，因过劳死在了公司茶水间，时年30岁。</p>
<h4 id="案发时间梳理"><a href="#案发时间梳理" class="headerlink" title="案发时间梳理"></a>案发时间梳理</h4><p>根据线索，甄主编原本计划是在晚上9点50分回到公司，但是在何的朋友圈留言，显示其在8：05的时候就已经回来了。</p>
<p>根据保安的证词，甄主编在晚上9：30的时候又离开了公司。</p>
<p>根据现有的证据显示，甄主编是在晚上9：30-10：10间遇害身亡。</p>
<ul>
<li>在后面的证据搜索中，发现以下几个线索：</li>
</ul>
<ol>
<li>在撒和侯的办公室发现了一套与死者一模一样的衣服，还有一个灯光控制器</li>
<li>在整点的时候，保洁会来打扫卫生；在半点的时候保安会巡视</li>
<li>死者所在的楼梯间在晚上9：20-9：25的时候有油漆工人给地板刷油漆，而油漆在晚上9：35之前不会干</li>
<li>茶水间监控于2018年12月30日进行更换，并且每一个小时缓存一次</li>
<li>在茶水间的视频中可以看到，在晚上9：30的时候茶水间的门自动开了，甄主编出现在了茶水间外面，进入了楼梯间，然后灯灭了，过了15秒灯亮起，楼梯间的门紧紧关着。</li>
<li>据悉，从楼梯间的后门连接的是停车场，从后门回到正门需要半个小时</li>
<li>楼梯间的门只能由甄主编从里面开，其他人只能从杂志社内从楼梯间的外面开门</li>
</ol>
<ul>
<li>由以上证据，可以作出以下几个假设：</li>
</ul>
<ol>
<li>监控里出现的就是甄主编，甄主编是在9：30之后被害</li>
<li>监控视频里是凶手伪装的甄主编，甄主编在这很短的时间里遇害，凶手又在15秒的黑暗时间里离开楼梯间。</li>
<li>死者在9：20前就已经遇害，而凶手伪装成甄主编的样子，假装甄主编是在9：30之前遇害的假象。伪造不在场证明。</li>
</ol>
<p>根据分析，第三点假设更加成立。但是根据第三条线索，凶手在9：30今日楼梯，鞋底必然会沾上油漆，但是在现场的鞋子上并没有发现油漆，而根据监控视频，凶手确实是进入到了楼梯间。</p>
<p>那么只有一种可能，凶手并没有进入楼梯间。凶手伪造了现场。在现场找到了两面可以推动的镜子，通过实验发现，凶手是通过镜面的折射，伪造了进入楼梯间的假象，实则进入的是旁边的甄主编的办公室。</p>
<p>凶手在9：30的时候将镜子摆放成如图的样子，然后用力推开茶水间的门，伪装成甄主编的样子进入旁边的甄主编的办公室，在15秒的黑暗时间，将镜子推走。就这样伪造了一个监控视频。</p>
<p>由此可以确认甄主编在9：20之前就已经死亡了。</p>
<p>而根据涉案人员陈述的时间点，每个人都没有不在场证明。</p>
<ul>
<li>下面从每个人的动机分析</li>
</ul>
<ol>
<li>撒时装：家庭负担重，但是甄主编辞退了他，并表示会在何的生日会上宣布这件事。撒又因为年纪的原因被其他公司拒绝。</li>
<li>蓉美妆：与郝秘书曾经是恋爱关系。但是发现郝秘书赌博，并且并不是像大家以为的兢兢业业，而是在办公室进行网络赌博，所以相与郝秘书分手。郝秘书以曝光蓉的私照与谈恋爱的秘密为要挟，向蓉勒索。蓉与郝在茶水间争执，蓉失手将郝推倒，导致郝死亡。甄看到了，帮助蓉将现场伪造成郝过劳死。后来贾在一个月内得到了蓉奋斗了五年的职位，蓉又听到了贾威胁蓉的话，以为甄把自己的事情告诉了贾，所以怀恨在心。</li>
<li>贾美妆：他看到了甄与蓉的做的事情，于是威胁甄得到升职的机会。在最后一次威胁的时候，贾希望得到副主编的位置，但是甄主编表示，自己会在生日会的时候宣布离职，主编的位置会留给贾。但是就在26日的晚上八点四十分，贾知道了，甄已经和另一家杂志社签订了合同，并打算带走MGQ杂志社内所有的核心编辑。</li>
<li>魏秘书：他是名校毕业，原本在一家杂志社担任编辑，但是在甄主编的聘用下，决定来MGQ当秘书，但是干的是和编辑不相干的事情。他接到了一通以“郝秘书”的名义打来的电话，而且灯光熄灭，气氛非常诡异，而在电话里说，魏的下场就会和郝的下场一样。接下来他又收到了“郝秘书”送来的血书。因为“郝秘书”称他为“魏秘书”而不是“喂”，他觉得自己得到了尊重，所以，经常通过打字机与“郝秘书”聊天。而在任职期间，魏秘书希望可以去体检，但是甄主编却以工作为由，拒绝了他体检的理由。然后魏秘书就收到了诊断书，他患有百分之九十的心肌坏死，严重过劳，并且已经到了生命的尽头，所以他对杂志社的所有人都怀恨在心。他买了易燃的地毯，没有换甄主编让他换的地毯，买了蜡烛。只要何在10点10分吹蜡烛，就会引火。</li>
<li>侯助理：是郝秘书的弟弟，来公司调查哥哥的死因。在此期间，他文章被以撒的名义刊登在了撒主持编辑的版块。他又发现了魏秘书的境况，伪装成“郝秘书”与魏秘书交流，所以他用过灯光控制器。他意外收到了魏秘书的诊断书，将诊断书上的百分之十改成了百分之九十，诱导魏秘书对杂志社的人进行报复。</li>
</ol>
<p>根据以上线索，可以排除掉蓉，因为勒死一个身高比自己高的成年女性，还要在15秒内将两面大镜子推走，对于蓉来说是吃力的。</p>
<p>可以排除掉侯，因为侯已经利用了魏秘书，只需要等待魏秘书行动了。</p>
<p>至于撒和贾，并没有明确的计划，他们其实在在茶水间里等待机会。</p>
<p>剩下的只有魏了。魏秘书在这个案件中非常关键的一点就是那条地毯。因为甄主编是一个非常苛刻的人，所以当她回来看到地毯不是她要求魏秘书换的那条一定会让魏秘书换掉，而魏秘书的计划就没有办法实施了。但是他没有想到甄主编会提前回来，反正他是打算杀掉所有人，所以提前杀掉甄主编也可以。而如果甄主编一直不出现，所有人一定要会等她出现，所以他伪造了甄主编出去的假象，而所有人可以放心吹蜡烛。</p>
<p>以上就是对于本期《明星大侦探》的分析。</p>
<p>本片文章转自 原创 姑且如此 <a href>不得甚解</a> <em>1月2日</em>  <em>侵私删</em></p>
]]></content>
      <categories>
        <category>侦探案件</category>
      </categories>
      <tags>
        <tag>案件</tag>
      </tags>
  </entry>
  <entry>
    <title>Mockjs</title>
    <url>/2020/04/07/Mockjs/</url>
    <content><![CDATA[<p>mockjs 生成随机数据</p>
<a id="more"></a>

<blockquote>
<p>所有内容資料來自<a href="https://www.csdn.net/"><img src="https://csdnimg.cn/cdn/content-toolbar/csdn-logo_.png?v=20190924.1" alt="img"></a></p>
</blockquote>
<p>前后端分离趋势，前端负责数据展示、页面动态效果等，后端负责编写应用程序接口，功页面、第三方等调用。有很多情况是，前端已经写好页面，一直等待后端接口的联调。所以现在就有造价数据的工具mockjs</p>
<p><strong>jquery 中 使用 mockjs来拦截ajax请求，并返回假数据。</strong></p>
<h5 id="引入mockjs"><a href="#引入mockjs" class="headerlink" title="引入mockjs"></a>引入mockjs</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Mock = <span class="built_in">require</span>(<span class="string">'mockjs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回字符串</span></span><br><span class="line">Mock.mock(<span class="string">'/api/data'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> Mock.mock(&#123;</span><br><span class="line">        <span class="string">'string|3'</span>: <span class="string">'*'</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回指定范围的整数</span></span><br><span class="line">Mock.mock(<span class="string">'/api/getInteger'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> Mock.mock(&#123;</span><br><span class="line">        <span class="string">'a|1-100'</span>: <span class="number">100</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回随机个数的对象</span></span><br><span class="line">Mock.mock(<span class="string">'/api/getObject'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> Mock.mock(&#123;</span><br><span class="line">        <span class="string">'brand|1-3'</span>: &#123;</span><br><span class="line">            a: <span class="string">'京东'</span>,</span><br><span class="line">            b: <span class="string">'国美'</span>,</span><br><span class="line">            c: <span class="string">'苏宁'</span>,</span><br><span class="line">            d: <span class="string">'当当'</span>,</span><br><span class="line">            e: <span class="string">'天猫'</span>,</span><br><span class="line">            f: <span class="string">'淘宝'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回随机数组</span></span><br><span class="line">Mock.mock(<span class="string">'/api/getArr'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> Mock.mock(&#123;</span><br><span class="line">        <span class="string">'data|1-10'</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="string">'name'</span>: <span class="string">'张三'</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回随机字符</span></span><br><span class="line">Mock.mock(<span class="string">'/api/getRandom1'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> Mock.mock(&#123;</span><br><span class="line">        <span class="string">'random1'</span>: <span class="regexp">/[a-z]&#123;2&#125;[A-Z]&#123;2&#125;[0-9]/</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回随机字符</span></span><br><span class="line">Mock.mock(<span class="string">'/api/getRandom2'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> Mock.mock(&#123;<span class="attr">random2</span>: <span class="string">'@string("lower", 5)'</span>&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回UUID</span></span><br><span class="line">Mock.mock(<span class="string">'/api/getUUID'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">'uuid'</span>: Mock.Random.id()&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"id|+1"</span>: <span class="number">1</span>, <span class="comment">//id的递增</span></span><br><span class="line"><span class="string">"name"</span>: <span class="string">"@cname"</span>, <span class="comment">// 姓名</span></span><br><span class="line"><span class="string">"email"</span>: <span class="string">"@email"</span>, <span class="comment">//邮箱</span></span><br><span class="line"><span class="string">"mobile"</span>: <span class="regexp">/^(13[0-9]|15[012356789]|166|17[3678]|18[0-9]|14[57])[0-9]&#123;8&#125;$/</span>, <span class="comment">//生成手机11位号  可以使用正则表达式</span></span><br><span class="line"><span class="string">"sex"</span>: <span class="string">"@boolean, // 随机boolean</span></span><br><span class="line"><span class="string">"</span>avatar<span class="string">":"</span>@image<span class="string">" // 图片</span></span><br><span class="line"><span class="string">"</span>avatar<span class="string">":"</span>@image(<span class="string">'50x50'</span>,<span class="string">'red'</span>,<span class="string">'#fff'</span>,<span class="string">'文字‘)"</span></span><br></pre></td></tr></table></figure>

<h5 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"Boolean"</span>: <span class="string">"@boolean"</span>, <span class="comment">// 布尔值</span></span><br><span class="line"><span class="string">"natural"</span>: <span class="string">"@natural"</span>, <span class="comment">// natural( min, max )</span></span><br><span class="line"><span class="string">"integer"</span>: <span class="string">"@integer"</span>, <span class="comment">// integer( min, max )</span></span><br><span class="line"><span class="string">"float"</span>: <span class="string">"@float(22,99,1,2)"</span>, <span class="comment">// float( min, max, dmin, dmax )</span></span><br><span class="line"><span class="string">"string"</span>: <span class="string">"@string"</span>, <span class="comment">//string(type,min,max) lower小写，upper大写，number数字，symbol符号，</span></span><br><span class="line"><span class="string">"range"</span>: <span class="string">"@range"</span>, <span class="comment">//range( start, stop, step ) step为间隔为，最后返回值为数组</span></span><br></pre></td></tr></table></figure>

<h5 id="時間"><a href="#時間" class="headerlink" title="時間"></a>時間</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"date"</span>: <span class="string">"@date"</span>, <span class="comment">// 日期</span></span><br><span class="line"><span class="string">"time"</span>: <span class="string">"@time"</span>, <span class="comment">// 时间</span></span><br><span class="line"><span class="string">"dataTime"</span>: <span class="string">"@datetime"</span>, <span class="comment">// 日期+时间</span></span><br><span class="line"><span class="string">"Now"</span>: <span class="string">"@now"</span>, <span class="comment">// 当前的日期时间</span></span><br></pre></td></tr></table></figure>

<h5 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h5><blockquote>
<p>凡是@后加c就是为中文；例如name为英文，cname则是中文</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"paragraph"</span>: <span class="string">"@cparagraph"</span>, <span class="comment">// 段落</span></span><br><span class="line"><span class="string">"title"</span>:<span class="string">"@ctitle(1,10)"</span>,<span class="comment">//标题，长度为1-10</span></span><br><span class="line"><span class="string">"sentence"</span>: <span class="string">"@csentence"</span>, <span class="comment">//句子</span></span><br><span class="line"><span class="string">"first"</span>: <span class="string">"@cfirst"</span>, <span class="comment">//姓氏</span></span><br></pre></td></tr></table></figure>

<h5 id="地方"><a href="#地方" class="headerlink" title="地方"></a>地方</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"region"</span>: <span class="string">"@region"</span>, <span class="comment">//方位</span></span><br><span class="line"><span class="string">"province"</span>: <span class="string">"@province"</span>, <span class="comment">//省份 </span></span><br><span class="line"><span class="string">"city"</span>: <span class="string">"@city"</span>, <span class="comment">// 城市 +(true)，可以获取到上一级，例如：@city(true) 可以获取到省市</span></span><br></pre></td></tr></table></figure>

<h5 id="对象和数组"><a href="#对象和数组" class="headerlink" title="对象和数组"></a>对象和数组</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"city|2-4"</span>: &#123;</span><br><span class="line">    <span class="string">"110000"</span>: <span class="string">"北京市"</span>,</span><br><span class="line">    <span class="string">"120000"</span>: <span class="string">"天津市"</span>,</span><br><span class="line">    <span class="string">"130000"</span>: <span class="string">"河北省"</span>,</span><br><span class="line">    <span class="string">"140000"</span>: <span class="string">"山西省"</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="string">"city|1"</span>: [</span><br><span class="line">    <span class="string">"北京市"</span>,</span><br><span class="line">    <span class="string">"天津市"</span>,</span><br><span class="line">    <span class="string">"河北省"</span>,</span><br><span class="line">    <span class="string">"山西省"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>mock</tag>
      </tags>
  </entry>
  <entry>
    <title>Nodejs相关</title>
    <url>/2020/02/18/Nodejs%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h4 id="NodeJS"><a href="#NodeJS" class="headerlink" title="NodeJS"></a>NodeJS</h4><p>Node.js® 是一个基于 <a href="https://v8.dev/">Chrome V8 引擎</a> 的 JavaScript 运行时。</p>
<a id="more"></a>

<p>Node.js是一个基于Chrome JavaScript运行时建立的平台， 用于方便地搭建响应速度快、易于扩展的网络应用。Node.js 使用事件驱动， 非阻塞I/O 模型而得以轻量和高效，非常适合在分布式设备上运行的数据密集型的实时应用。</p>
<p>Express 是一个基于 Node.js 平台的极简、灵活的 web 应用开发框架，它提供一系列强大的特性，帮助你创建各种 Web 和移动设备应用。Express 也是官方推荐的Web框架。</p>
<ol>
<li>下载安装node.js</li>
<li>新建文件，并<code>npm init -y</code> 初始化项目生成 package.jspn文件</li>
<li>安装 Express  <code>npm init express -S</code>  会生成node_modules</li>
</ol>
]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise相关</title>
    <url>/2020/03/14/Promise%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><a id="more"></a>

<p>ES6 原生提供了 Promise 对象。所谓 Promise，就是一个对象，用来传递异步操作的消息。它代表了某个未来才会知道结果的事件（通常是一个异步操作），并且这个事件提供统一的 API，可供进一步处理。</p>
<h3 id="1-Promise用法"><a href="#1-Promise用法" class="headerlink" title="1.Promise用法"></a>1.Promise用法</h3><h4 id="1-1-异步调用"><a href="#1-1-异步调用" class="headerlink" title="1.1 异步调用"></a>1.1 异步调用</h4><ul>
<li><p>异步效果分析</p>
<ul>
<li><p>定时任务 setTimeout setInterver</p>
</li>
<li><p>Ajax 异步ajax请求（jqurey）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ret = <span class="string">''</span></span><br><span class="line">$ajax&#123;(</span><br><span class="line">	url:<span class="string">'http://localhost:3000/...'</span>,</span><br><span class="line">	success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(data)</span><br><span class="line">		ret = data;</span><br><span class="line">    	<span class="built_in">console</span>.log(ret)  <span class="comment">// 这里可以</span></span><br><span class="line">	&#125;</span><br><span class="line">)&#125;</span><br><span class="line"><span class="built_in">console</span>.log(ret)  <span class="comment">// 这里的ret是获取不到里面的东西的</span></span><br><span class="line"><span class="comment">// 只能在回调函数中，获得值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>事件函数</p>
</li>
</ul>
</li>
<li><p>多次异步调用的依赖分析</p>
<ul>
<li><p>多次异步调用的<u>结果顺序不确定</u></p>
</li>
<li><p>异步调用结果如果存在依赖，那么我们需要多次多次嵌套，就是传说中的“十八层地域”，回调地狱。</p>
</li>
</ul>
</li>
</ul>
<h4 id="1-2-Promise-概述"><a href="#1-2-Promise-概述" class="headerlink" title="1.2 Promise 概述"></a>1.2 Promise 概述</h4><p>Promise 是异步编程的一种解决方案，从语法上讲，Promise是一个对象，从它可以获取异步操作的消息。</p>
<ul>
<li>可以避免多层异步调用嵌套问题（回调地狱）。</li>
<li>Promise对象提供了简介的API，使得控制异步操作更加容易</li>
</ul>
<h4 id="1-3-Promise-基本用法"><a href="#1-3-Promise-基本用法" class="headerlink" title="1.3 Promise 基本用法"></a>1.3 Promise 基本用法</h4><ul>
<li><p>实例化Promise 对象，构造函数中传递函数，该函数中用于处理异步任务</p>
</li>
<li><p>resolve和reject两个参数（都是方法，可以调用）用于处理成功和失败两种情况，并通过p.the获取处理结果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 成功时调用 resolve()</span></span><br><span class="line">    <span class="comment">// 失败时调用 reject()</span></span><br><span class="line">&#125;)</span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">ret</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 返回成功的结果ret</span></span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 返回失败的结果</span></span><br><span class="line">&#125;) </span><br><span class="line"></span><br><span class="line">-------------------------------------------------</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> flag = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">            <span class="comment">// 正常情况</span></span><br><span class="line">            resolve(<span class="string">'hello'</span>)</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 异常情况</span></span><br><span class="line">            reject(<span class="string">'出错'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">100</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="1-4-基于Promise处理Ajax请求"><a href="#1-4-基于Promise处理Ajax请求" class="headerlink" title="1.4 基于Promise处理Ajax请求"></a>1.4 基于Promise处理Ajax请求</h4><ol>
<li>处理原生Ajax</li>
</ol>
<h4 id="1-5-then参数中的函数返回值"><a href="#1-5-then参数中的函数返回值" class="headerlink" title="1.5 then参数中的函数返回值"></a>1.5 then参数中的函数返回值</h4><p>1.返回Promise实例对象</p>
<ul>
<li>返回的该实例对象会调用下一个then</li>
</ul>
<p>2.返回普通值</p>
<ul>
<li>返回的普通值会直接传递给下一个then，通过then参数中函数的参数接收该值</li>
</ul>
<h4 id="1-6-Promise常用的API"><a href="#1-6-Promise常用的API" class="headerlink" title="1.6 Promise常用的API"></a>1.6 Promise常用的API</h4><p>1.实例方法（在原型中的方法，需要用实例去调用）</p>
<ul>
<li>p.then() 得到异步任务的正确结果</li>
<li>p.catch() 获取异常信息</li>
<li>p.finally() 成功与否都会执行（尚且不是正式标准）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">           <span class="comment">// resolve(123);</span></span><br><span class="line">            reject(error)</span><br><span class="line">        &#125;,<span class="number">100</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line">	.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    	<span class="built_in">console</span>.log(data)</span><br><span class="line">	&#125;)</span><br><span class="line">	.catch(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>))</span>&#123;</span><br><span class="line">     	<span class="built_in">console</span>.log(data)      </span><br><span class="line">    &#125;)</span><br><span class="line">    .finally(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'finished'</span>)</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>2.对象方法</p>
<ul>
<li>Promise.all() 并发处理多个异步任务，所有任务都执行完成才能得到结果</li>
<li>Promise.race() 并发处理多个异步任务，只要有一个任务完成就能得到结果</li>
</ul>
<h3 id="2-接口调用-fetch用法"><a href="#2-接口调用-fetch用法" class="headerlink" title="2 接口调用 -fetch用法"></a>2 接口调用 -fetch用法</h3><h4 id="2-1-基本特性"><a href="#2-1-基本特性" class="headerlink" title="2.1 基本特性"></a>2.1 基本特性</h4><ul>
<li>更加简单的数据获取方式，功能更强大，更灵活，可以看做是xhr的升级版</li>
<li>基于Promise实现</li>
</ul>
<h4 id="2-2-语法结构"><a href="#2-2-语法结构" class="headerlink" title="2.2 语法结构"></a>2.2 语法结构</h4><p>fetch(url).then(fn2)</p>
<p>​                .then(fn3)</p>
<p>​                …</p>
<p>​                .catch(fn)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fetch(<span class="string">'http://localhost:3000/fdata'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> data.text(); <span class="comment">//text()方法属于fetchAPI的一部分，它返回一个Promise实例对象，用于获取后台返回的数据</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="2-3-fetch请求参数"><a href="#2-3-fetch请求参数" class="headerlink" title="2.3 fetch请求参数"></a>2.3 fetch请求参数</h4><ol>
<li>常用配置选项<ul>
<li>method(String): HTTP请求方法，默认为GET POST PUT DELETE</li>
<li>body(String): HTTP请求参数</li>
<li>header(Object): HTTP的请求头，默认为{}</li>
</ul>
</li>
</ol>
<h3 id="3-axios-用法"><a href="#3-axios-用法" class="headerlink" title="3. axios 用法"></a>3. axios 用法</h3><h4 id="3-1-axios-的基本特性"><a href="#3-1-axios-的基本特性" class="headerlink" title="3.1 axios 的基本特性"></a>3.1 axios 的基本特性</h4><p>axios（官网：<a href="https://github.com/axios/axios）是一个基于Promise用于浏览器和node.js的HTTP客户端">https://github.com/axios/axios）是一个基于Promise用于浏览器和node.js的HTTP客户端</a></p>
<p>它有以下特性：</p>
<ul>
<li>支持浏览器和node.js</li>
<li>支持promise</li>
<li>能拦截请求和响应</li>
<li>自动转换JSON数据</li>
</ul>
<h4 id="3-2-axios-的基本用法"><a href="#3-2-axios-的基本用法" class="headerlink" title="3.2 axios 的基本用法"></a>3.2 axios 的基本用法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios.get(<span class="string">'/adata'</span>)</span><br><span class="line">	.then(<span class="function"><span class="params">ret</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//data属性名称是固定的，用于获取后台响应的数据</span></span><br><span class="line">    <span class="built_in">console</span>.log(ret.data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="3-3-axios-常用API"><a href="#3-3-axios-常用API" class="headerlink" title="3.3 axios 常用API"></a>3.3 axios 常用API</h4><ul>
<li>get：      添加数据</li>
<li>post：    删除数据</li>
<li>put：      修改数据</li>
<li>delete： 删除数据</li>
</ul>
<ol>
<li>GET 传递参数<ul>
<li>通过 URL 传递参数</li>
<li>通过params 选项传递参数</li>
</ul>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios.get(<span class="string">'/adata?id=123'</span>)</span><br><span class="line">	.then(<span class="function"><span class="params">ret</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(ret.data)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后台接口</span></span><br><span class="line">app.get(<span class="string">'/axios'</span>,(req,res) =&gt; &#123;</span><br><span class="line">    res.send(<span class="string">'axios get 传递参数'</span> + req.query.id)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios.get(<span class="string">'/adata/123'</span>)</span><br><span class="line">	.then(<span class="function"><span class="params">ret</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(ret.data)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后台接口</span></span><br><span class="line">app.get(<span class="string">'/axios/:id'</span>,(req,res) =&gt; &#123;</span><br><span class="line">    res.send(<span class="string">'axios get (Restful) 传递参数'</span> + req.params.id)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios.get(<span class="string">'/adata'</span>,&#123;</span><br><span class="line">	params:&#123;</span><br><span class="line">		id:<span class="number">123</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">ret</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(ret.data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>POST 传递参数</p>
<p>axios.post(‘<a href="http://localhost:3000/axios’,{">http://localhost:3000/axios’,{</a></p>
<p>​    uname: ‘lily’</p>
<p>​    pwd: 123</p>
<p>}).then(function(ret){</p>
<p>​    console.log(ret.data)</p>
<p>})</p>
<p>post传参，这样默认传过去的是以json格式传</p>
</li>
</ol>
<h4 id="3-4-axios-的响应结果"><a href="#3-4-axios-的响应结果" class="headerlink" title="3.4 axios 的响应结果"></a>3.4 axios 的响应结果</h4><p>响应结果的主要属性（axios自己包装了，有这些属性</p>
<ul>
<li>data：实际响应回来的数据</li>
<li>headers：响应头信息</li>
<li>status：响应状态码</li>
<li>statusText：响应状态信息</li>
</ul>
<h4 id="3-5-axios-的全局配置"><a href="#3-5-axios-的全局配置" class="headerlink" title="3.5 axios 的全局配置"></a>3.5 axios 的全局配置</h4><p>axios.defaults.timeout = 3000； //超时时间</p>
<p>axios.defaults.aseURL = ‘<a href="http://localhost:3000/app’">http://localhost:3000/app’</a>; //默认地址</p>
<p>axios.defaults.headers[ ‘mytoken’ ] = ‘xxxx’ //设置请求头</p>
<h4 id="3-6-axios-的拦截器"><a href="#3-6-axios-的拦截器" class="headerlink" title="3.6  axios 的拦截器"></a>3.6  axios 的拦截器</h4><ol>
<li><p>请求拦截器</p>
<p>在请求发出之前设置一些信息</p>
<p>//添加一个请求拦截器 token拦截</p>
<p>axios.interceptors.request.use(function(config){</p>
<p>​    // 在请求发出之前进行一些信息设置</p>
<p>​    config.headers.mytoken = ‘ nihao’</p>
<p>​    return config</p>
<p>}，function（err）{</p>
<p>// 处理响应的错误信息</p>
<p>})</p>
<p>2.响应拦截器</p>
<p>在获取数据之前，对数据做一些加工处理</p>
<p>添加一个响应拦截器</p>
<p>axios.interceptors.request.use(function(res){</p>
<p>​    // 在这里对返回的数据进行处理</p>
<p>​    return res</p>
<p>}，function（err）{</p>
<p>// 处理响应的错误信息</p>
<p>})</p>
</li>
</ol>
<h3 id="4-接口调用-async-await用法-（常用）"><a href="#4-接口调用-async-await用法-（常用）" class="headerlink" title="4. 接口调用 -async /await用法 （常用）"></a>4. 接口调用 -async /await用法 （常用）</h3><ul>
<li>async/await是ES7 引入的新语法，可以更加方便的进行一步操作</li>
<li>async 关键字用于函数上（async函数的返回值是Promise实例对象）</li>
<li>await 关键字用于async 函数当中（await可以得到异步的结果）</li>
</ul>
<p>async function queryData(id){</p>
<p>​    const ret = await axios.get(‘/data’)</p>
<p>​    return ret;</p>
<p>}</p>
<p>queryData.then(ret =&gt; {</p>
<p>​    console.log(ret)</p>
<p>})</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>promise axios 异步</tag>
      </tags>
  </entry>
  <entry>
    <title>RESTfull</title>
    <url>/2020/04/06/RESTfull/</url>
    <content><![CDATA[<p>RESTfull <em>一种软件架构风格、设计风格</em>，不是标准，提供了一组设计原则和约束条件。</p>
<a id="more"></a>

<p>主要用于客户端和服务器交互类软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存机制。<a href="https://baike.sogou.com/v73300762.htm?fromTitle=RESTful">查看词条</a></p>
<h5 id="原则条件"><a href="#原则条件" class="headerlink" title="原则条件"></a>原则条件</h5><ol>
<li>REST 指的是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是 RESTful。</li>
<li>Web应用程序最重要的REST原则是，客户端和服务器之间的交互在请求之间是（http请求）无状态的。客户端到服务器的每一个请求都必须包含理解请求所必需的信息。</li>
<li>在服务器端，应用程序状态和功能可以分为各种资源。向客户端公开。每个资源都使用 URL 得到一个唯一的地址。所有资源都共享同一的接口，以便客户端和服务器之间传输状态。使用的是标准的 HTTP 方法，比如 GET、PUT、POST和DELETE</li>
</ol>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ol>
<li>每个URL代表 1 种资源</li>
<li>客户端使用GET、POST、PUT、DELETE4个表示操作方式的动词对服务端资源进行操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源；</li>
<li>资源的表现形式是 XML 或者 HTML</li>
<li>客户端与服务端之间的交互请求之间是无状态的。客户端到服务器的每一个请求都必须包含理解请求所必需的信息。</li>
</ol>
<h5 id="RESTful架构"><a href="#RESTful架构" class="headerlink" title="RESTful架构"></a>RESTful架构</h5><ol>
<li><p>RESTful架构是对MVC架构改进后所形成的一种架构，通过使用事先定义好的接口与不同的服务联系起来。在RESTful架构中，浏览器使用POST，DELETE，PUT和GET四种请求方式分别对指定的URL资源进行增删改查操作。因此，RESTful是通过URI实现对资源的管理及访问，具有扩展性强、结构清晰的特点。</p>
</li>
<li><p>RESTful架构将服务器分成前端服务器和后端服务器两部分，前端服务器为用户提供无模型的视图；后端服务器为前端服务器提供接口。浏览器向前端服务器请求视图，通过视图中包含的AJAX函数发起接口请求获取模型。</p>
</li>
</ol>
<h5 id="其他概念-更多"><a href="#其他概念-更多" class="headerlink" title="其他概念 (更多)"></a><a href="https://mp.weixin.qq.com/s?src=3&timestamp=1586138856&ver=1&signature=YaSPg7qpu0Qva1*0Fzsibkd*dUmaJaaRaWFCm3-pr1P-9LJdS0n17C0d*v1U1XkrVZ1MzAtvI5I*Euqi3Y9oBTCQGSLdTUalCdtpQVVTXLfAxGBasGoGcxLFxFzqUr7DADEmF*rpU-Hdyd0*7Pmvty3KNdVeA-ilKzurRx4iF5w=">其他概念 (更多)</a></h5><h6 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h6><ol>
<li>服务器设计接口，应当设计为无状态接口。即服务器端不保存任何与客户端相关的状态上下文信息。 客户端在每次调用接口时，需要提供足够的信息，以供服务器完成操作</li>
<li>无状态设计中，服务端减少了保存客户端相关上下文数据，因此，一方面服务端能够更加容易实现动态扩展；减少了服务端从故障中恢复的任务量</li>
<li>但无状态也会带来额外的问题。客户端将需要保存完整的用户状态信息，在每次与服务端交互时可能需要增加与用户状态相关的上下文信息，这样将导致请求数据的重复和增大</li>
</ol>
<h6 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h6><ol>
<li>接口设计中增加缓存策略，服务器可以决定是否可以缓存当前返回的数据。这样 减少服务器被请求的次数，提高网络访问性能</li>
<li>缓存要谨慎使用，需要缓存什么数据，缓存过期时间等，要根据实际情况设计。</li>
<li>一般而言，数据字典类数据、修改频率非常低的数据、实时性要求很低的数据等，这些数据可以设计一定的缓存策略，以提高系统运行效率。</li>
</ol>
<h6 id="系统分层"><a href="#系统分层" class="headerlink" title="系统分层"></a>系统分层</h6><ol>
<li><p>横向分层一般可以分为 交互层 、服务层 、数据层 </p>
</li>
<li><p>纵向分层则通常会按照不同的业务功能对系统进行切分</p>
</li>
</ol>
<h6 id="统一接口"><a href="#统一接口" class="headerlink" title="统一接口"></a>统一接口</h6><p>​    统一接口，即是不同系统模块之间的调用接口统一规范，使用统一的调用协议，统一的数据格式等。统一接口带来的是系统交互的规范化，接口调用与业务解耦，各模块独立进化。</p>
]]></content>
      <tags>
        <tag>rest</tag>
      </tags>
  </entry>
  <entry>
    <title>React 1</title>
    <url>/2020/03/23/React-1/</url>
    <content><![CDATA[<h4 id="React和Vue对比"><a href="#React和Vue对比" class="headerlink" title="React和Vue对比"></a>React和Vue对比</h4><a id="more"></a>

<h5 id="1-如何实现组件化"><a href="#1-如何实现组件化" class="headerlink" title="1.如何实现组件化"></a>1.如何实现组件化</h5><p>Vue: 通过 <em>.vue</em> 文件，来创建对应的<strong>组件</strong>;（Vue.component() 这也是一种)</p>
<p>(.vue 这种文件需要有vue-loader去编译（webpack里面的一个loader）)</p>
<p>eg: Home.vue</p>
<ul>
<li>template     结构</li>
<li>script           行为</li>
<li>style             样式</li>
</ul>
<p>App.js</p>
<p>import Home from ‘./Home.vue’</p>
<p>React: 有组件化的概念，但没有像vue这样的组件模板文件；React中，一切都是以JS来表现的；JS知识要合格，ES6和ES7(async await)需了解.</p>
<h5 id="2-团队"><a href="#2-团队" class="headerlink" title="2.团队"></a>2.团队</h5><p>React是有FaceBook前端官方团队进行维护和更新</p>
<p>Vue是以尤雨溪为主导的开源小团队</p>
]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>React 2</title>
    <url>/2020/03/24/React-2/</url>
    <content><![CDATA[<h4 id="React中几个核心的概念​"><a href="#React中几个核心的概念​" class="headerlink" title="React中几个核心的概念​"></a>React中几个核心的概念​</h4><a id="more"></a>

<h5 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h5><p>（为了实现页面中，DOM元素的高效更新）</p>
<ul>
<li>DOM的本质：浏览器中的概念，用JS对象来表示 页面上的元素，并提供了操作DOM对象的API</li>
<li>什么是React中的虚拟DOM：框架中的概念， 用JS对象来模拟页面上的DOM和DOM嵌套</li>
<li>用JS对象的形式，来模拟页面上DOM嵌套关系。</li>
<li>提供新旧DOM树</li>
</ul>
<h5 id="DOM树的概念"><a href="#DOM树的概念" class="headerlink" title="DOM树的概念"></a>DOM树的概念</h5><p>​    一個网页呈现的过程：</p>
<ol>
<li>浏览器请求服务器获取页面HTML代码</li>
<li>浏览器先在内存中解析DOM结构，并在浏览器内存中，渲染出一颗DOM树</li>
<li>浏览器把DOM树呈现到页面上</li>
</ol>
<h5 id="Diff算法"><a href="#Diff算法" class="headerlink" title="Diff算法"></a>Diff算法</h5><ul>
<li><p>tree diff： 新旧两个DOM树，逐层对比的过程，就是Tree Diff，当整颗DOM逐层对比完毕，则所有需要被按需更新的元素，必然能够找到；</p>
</li>
<li><p>component diff：在进行Tree Diff的时候，每一层中，组件级别的对比，叫做Component Diff；</p>
<ul>
<li>如果对比前后，组件的类型相同，则暂时认为此组件不需要被更新；</li>
<li>对比后，组件类型不同，则需要移除旧组件，创建新组件，并追加到页面上；</li>
</ul>
</li>
<li><p>element diff：在进行组件对比的时候，如果两个组件类型相同，则需要进行元素级别的对比，叫做element diff。</p>
<img src="/2020/03/24/React-2/diff.png" class>

<p>​    </p>
</li>
</ul>
]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>React 3</title>
    <url>/2020/03/24/React-3/</url>
    <content><![CDATA[<h4 id="React（转载）"><a href="#React（转载）" class="headerlink" title="React（转载）"></a>React（转载）</h4><a id="more"></a>

<blockquote>
<p>学习文档转自黑马教程</p>
</blockquote>
<h4 id="ReactJS简介"><a href="#ReactJS简介" class="headerlink" title="ReactJS简介"></a>ReactJS简介</h4><ul>
<li>React 起源于 Facebook 的内部项目，因为该公司对市场上所有 JavaScript MVC 框架，都不满意，就决定自己写一套，用来架设 Instagram 的网站。做出来以后，发现这套东西很好用，<strong>就在2013年5月开源了</strong>。</li>
<li>由于 React 的设计思想极其独特，属于革命性创新，性能出众，代码逻辑却非常简单。所以，越来越多的人开始关注和使用，认为它可能是将来 Web 开发的主流工具。</li>
<li>library</li>
<li>Framework</li>
</ul>
<h4 id="前端三大主流框架"><a href="#前端三大主流框架" class="headerlink" title="前端三大主流框架"></a>前端三大主流框架</h4><ul>
<li>Angular.js：出来最早的前端框架，学习曲线比较陡，NG1学起来比较麻烦，NG2开始，进行了一系列的改革，也开始启用组件化了；在NG中，也支持使用TS（TypeScript）进行编程；</li>
<li>Vue.js：最火的一门前端框架，它是中国人开发的，对我我们来说，文档要友好一些；</li>
<li>React.js：最流行的一门框架，因为它的设计很优秀；</li>
<li>windowsPhone 7    7.5   8   10</li>
</ul>
<h4 id="React与vue-js的对比"><a href="#React与vue-js的对比" class="headerlink" title="React与vue.js的对比"></a>React与vue.js的对比</h4><h5 id="组件化方面"><a href="#组件化方面" class="headerlink" title="组件化方面"></a>组件化方面</h5><ol>
<li><p>什么是模块化：从 <strong>代码</strong> 的角度，去分析问题，把我们编程时候的业务逻辑，分割到不同的模块中来进行开发，这样能够<strong>方便代码的重用</strong>；</p>
</li>
<li><p>什么是组件化：从 <strong>UI</strong> 的角度，去分析问题，把一个页面，拆分为一些互不相干的小组件，随着我们项目的开发，我们手里的组件会越来越多，最后，我们如果要实现一个页面，可能直接把现有的组件拿过来进行拼接，就能快速得到一个完整的页面， 这样方<strong>便了UI元素的重用</strong>；<strong>组件是元素的集合体</strong>；</p>
</li>
<li><p>组件化的好处：</p>
</li>
<li><p>Vue是如何实现组件化的：.vue 组件模板文件，浏览器不识别这样的.vue文件，所以，在运行前，会把 .vue 预先编译成真正的组件；</p>
<ul>
<li>template： UI结构</li>
<li>script： 业务逻辑和数据</li>
<li>style： UI的样式</li>
</ul>
</li>
<li><p>React如何实现组件化：在React中实现组件化的时候，根本没有 像 .vue 这样的模板文件，而是，直接使用JS代码的形式，去创建任何你想要的组件；</p>
<ul>
<li>React中的组件，都是直接在 js 文件中定义的；</li>
<li>React的组件，并没有把一个组件 拆分为 三部分（结构、样式、业务逻辑），而是全部使用JS来实现一个组件的；（也就是说：结构、样式、业务逻辑是混合在JS里面一起编写出来的）</li>
</ul>
</li>
</ol>
<h5 id="开发团队方面"><a href="#开发团队方面" class="headerlink" title="开发团队方面"></a>开发团队方面</h5><ul>
<li>React是由FaceBook前端官方团队进行维护和更新的；因此，React的维护开发团队，技术实力比较雄厚；</li>
<li>Vue：第一版，主要是有作者 尤雨溪 专门进行维护的，当 Vue更新到 2.x 版本后，也有了一个小团队进行相关的维护和开发；</li>
</ul>
<h5 id="社区方面"><a href="#社区方面" class="headerlink" title="社区方面"></a>社区方面</h5><ul>
<li>在社区方面，React由于诞生的较早，所以社区比较强大，一些常见的问题、坑、最优解决方案，文档、博客在社区中都是可以很方便就能找到的；</li>
<li>Vue是近两年才诞生开源出来的，所以，它的社区相对于React来说，要小巧一些，所以，可能有的一些坑，没人踩过；</li>
</ul>
<h5 id="移动APP开发体验方面"><a href="#移动APP开发体验方面" class="headerlink" title="移动APP开发体验方面"></a>移动APP开发体验方面</h5><ul>
<li>Vue，结合 Weex 这门技术，提供了 迁移到 移动端App开发的体验（Weex，目前只是一个 小的玩具， 并没有很成功的 大案例；）</li>
<li>React，结合 ReactNative，也提供了无缝迁移到 移动App的开发体验（RN用的最多，也是最火最流行的）；</li>
</ul>
<h4 id="为什么要学习React"><a href="#为什么要学习React" class="headerlink" title="为什么要学习React"></a>为什么要学习React</h4><ol>
<li>设计很优秀，是基于组件化的，方便我们UI代码的重用；</li>
<li>开发团队实力强悍，不必担心短更的情况；</li>
<li>社区强大，很多问题都能找到对应的解决方案；</li>
<li>提供了无缝转到 ReactNative 上的开发体验，让我们技术能力得到了拓展；增强了我们的核心竞争力</li>
</ol>
<h4 id="React中几个核心的概念"><a href="#React中几个核心的概念" class="headerlink" title="React中几个核心的概念"></a>React中几个核心的概念</h4><h5 id="虚拟DOM（Virtual-Document-Object-Model）"><a href="#虚拟DOM（Virtual-Document-Object-Model）" class="headerlink" title="虚拟DOM（Virtual Document Object Model）"></a>虚拟DOM（Virtual Document Object Model）</h5><ul>
<li>DOM的本质是什么：就是用JS表示的UI元素</li>
<li>DOM和虚拟DOM的区别：<ul>
<li>DOM是由浏览器中的JS提供功能，所以我们只能人为的使用 浏览器提供的固定的API来操作DOM对象；</li>
<li>虚拟DOM：并不是由浏览器提供的，而是我们程序员手动模拟实现的，类似于浏览器中的DOM，但是有着本质的区别；</li>
</ul>
</li>
</ul>
<ul>
<li>为什么要实现虚拟DOM：</li>
<li>什么是React中的虚拟DOM：</li>
<li>虚拟DOM的目的：<img src="/2020/03/24/React-3/%E8%99%9A%E6%8B%9FDOM%E5%BC%95%E5%85%A5%E5%9B%BE%E7%89%87.png" class>

</li>
</ul>
<h5 id="Diff算法"><a href="#Diff算法" class="headerlink" title="Diff算法"></a>Diff算法</h5><ul>
<li>tree diff:新旧DOM树，逐层对比的方式，就叫做 tree diff,每当我们从前到后，把所有层的节点对比完后，必然能够找到那些 需要被更新的元素；</li>
<li>component diff：在对比每一层的时候，组件之间的对比，叫做 component diff;当对比组件的时候，如果两个组件的类型相同，则暂时认为这个组件不需要被更新，如果组件的类型不同，则立即将旧组件移除，新建一个组件，替换到被移除的位置；</li>
<li>element diff:在组件中，每个元素之间也要进行对比，那么，元素级别的对比，叫做 element diff；</li>
<li>key：key这个属性，可以把 页面上的 DOM节点 和 虚拟DOM中的对象，做一层关联关系；<img src="/2020/03/24/React-3/Diff.png" class>

</li>
</ul>
<h4 id="React项目的创建"><a href="#React项目的创建" class="headerlink" title="React项目的创建"></a>React项目的创建</h4><ol>
<li><p>运行 <code>cnpm i react react-dom -S</code> 安装包</p>
<p>1.1 react 这个包，是专门用来创建React组件、创建虛擬DOM、组件生命周期等这些东西的；<br>1.2 react-dom 里面主要封装了和 DOM 操作相关的包，进行DOM操作，最主要的应用场景是 ReactDOM， render()</p>
</li>
<li><p>在项目中导入两个相关的包：</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>使用JS的创建虚拟DOM节点：</p>
<p>在 react 中，如要要创建 DOM 元素了，只能使用 React 提供的 JS API 来创建，不能【直接】像 Vue 中那样，手写 HTML 元素</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// React.createElement() 方法，用于创建 虚拟DOM 对象，它接收 3个及以上的参数</span></span><br><span class="line">   <span class="comment">// 参数1： 是个字符串类型的参数，表示要创建的元素类型</span></span><br><span class="line">   <span class="comment">// 参数2： 是一个属性对象，表示 创建的这个元素上，有哪些属性</span></span><br><span class="line">   <span class="comment">// 参数3： 从第三个参数的位置开始，后面可以放好多的虚拟DOM对象，这写参数，表示当前元素的子节点</span></span><br><span class="line">   <span class="comment">// &lt;div title="this is a div" id="mydiv"&gt;这是一个div&lt;/div&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> myH1 = React.createElement(<span class="string">'h1'</span>, <span class="literal">null</span>, <span class="string">'这是一个大大的H1'</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> myDiv = React.createElement(<span class="string">'div'</span>, &#123; <span class="attr">title</span>: <span class="string">'this is a div'</span>, <span class="attr">id</span>: <span class="string">'mydiv'</span> &#125;, <span class="string">'这是一个div'</span>, myH1)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>使用 ReactDOM 把元素渲染到页面指定的容器中：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ReactDOM.render('要渲染的虚拟DOM元素', '要渲染到页面上的哪个位置中')</span></span><br><span class="line"><span class="comment">// 注意： ReactDOM.render() 方法的第二个参数，和vue不一样，不接受 "#app" 这样的字符串，而是需要传递一个 原生的 DOM 对象</span></span><br><span class="line">ReactDOM.render(myDiv, <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>))</span><br></pre></td></tr></table></figure>

<h4 id="JSX语法-配合官方jsx文档"><a href="#JSX语法-配合官方jsx文档" class="headerlink" title="JSX语法 (配合官方jsx文档)"></a>JSX语法 (配合官方jsx文档)</h4><p>​    <em>Babel 是一个 JavaScript 编译器。（把浏览器不认识的语法，编译成浏览器认识的语法。）</em></p>
<p>​    <em>webpack 是一个现代 JavaScript 应用程序的静态模块打包器。（项目打包）</em></p>
<ol>
<li><p>如要要使用 JSX 语法，必须先运行 <code>cnpm i babel-preset-react -D</code>，然后再 <code>.babelrc</code> 中添加 语法配置；</p>
<p>运行 <code>cnpm i babel-core babel-loader babel-plugin-transform-runtime -D</code></p>
<p>运行 <code>cnpm i babel-present-env babel-preset-stage -D</code></p>
</li>
<li><p>JSX语法的本质：还是以 React.createElement 的形式来实现的，并没有直接把 用户写的 HTML代码，渲染到页面上；</p>
</li>
<li><p>如果要在 JSX 语法内部，书写 JS 代码了，那么，所有的JS代码，必须写到 {} 内部；</p>
<ul>
<li><p>渲染数字</p>
</li>
<li><p>渲染字符串</p>
</li>
<li><p>渲染布尔值</p>
</li>
<li><p>为属性绑定值</p>
</li>
<li><p>渲染jsx元素</p>
</li>
<li><p>渲染jsx元素数组</p>
</li>
<li><p>将普通字符串数组 转为jsx数组并渲染到页面上</p>
<p>eg：<code>let a = 10</code></p>
</li>
</ul>
<p>​        <code>&lt;div&gt; {a} &lt;/div&gt;</code></p>
<p>​        <code>&lt;div&gt; {a+2} &lt;/div&gt;</code>  也可以进行基本的运算</p>
<img src="/2020/03/24/React-3/r1.png" class>
</li>
<li><p>当 编译引擎，在编译JSX代码的时候，如果遇到了<code>&lt;</code>那么就把它当作 HTML代码去编译，如果遇到了 <code>{}</code> 就把 花括号内部的代码当作 普通JS代码去编译；</p>
</li>
<li><p>在{}内部，可以写任何符合JS规范的代码；</p>
</li>
<li><p>在JSX中，如果要为元素添加<code>class</code>属性了，那么，必须写成<code>className</code>，因为 <code>class</code>在ES6中是一个关键字；和<code>class</code>类似，label标签的 <code>for</code> 属性需要替换为 <code>htmlFor</code>.</p>
</li>
<li><p>在JSX创建DOM的时候，所有的节点，必须有唯一的根元素进行包裹；</p>
</li>
<li><p>如果要写注释了，注释必须放到 <code>{/* */}</code> 内部</p>
</li>
</ol>
<h4 id="React中：第一种创建组件的方式"><a href="#React中：第一种创建组件的方式" class="headerlink" title="React中：第一种创建组件的方式"></a>React中：第一种创建组件的方式</h4><blockquote>
<p>使用构造构造函数来创造组件，如果要接收外界传递的数据，需要再 构造函数的参数列表中使用<code>props</code>来接收；必须要向外return一个合法的JSX创建的虚拟DOM</p>
</blockquote>
<ul>
<li><p>创建组件：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意：组件首字母必须是大写</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">// return null</span></span><br><span class="line">	<span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello 组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为组件传递数据：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用组件，并为组件传递props 数据</span></span><br><span class="line">&lt;Hello name=&#123;dog.name&#125; age=&#123;dog.age&#125; gender=&#123;dog.gender&#125;&gt;&lt;<span class="regexp">/Hello&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 在构造函数中，使用props 形参，接收外界传递过来的数据</span></span><br><span class="line"><span class="regexp">function Hello(props)&#123;</span></span><br><span class="line"><span class="regexp">	/</span><span class="regexp">/ props.name = 'zs'</span></span><br><span class="line"><span class="regexp">	console.log(props)</span></span><br><span class="line"><span class="regexp">	/</span><span class="regexp">/ 结论：不论是 Vue 还是 React，组建中的props 永远都是只读的；不被重新赋值；</span></span><br><span class="line"><span class="regexp">	return &lt;div&gt;Hello 组件----&#123;props.name&#125;----&#123;props.age&#125;----&#123;props.gender&#125;&lt;/</span>div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h5 id="父组件向子组件传递数据"><a href="#父组件向子组件传递数据" class="headerlink" title="父组件向子组件传递数据"></a>父组件向子组件传递数据</h5><h5 id="使用-…obj-属性扩散传递数据"><a href="#使用-…obj-属性扩散传递数据" class="headerlink" title="使用(…obj)属性扩散传递数据"></a>使用(…obj)属性扩散传递数据</h5><h5 id="将组件封装到单独的文件中"><a href="#将组件封装到单独的文件中" class="headerlink" title="将组件封装到单独的文件中"></a>将组件封装到单独的文件中</h5><h4 id="React中：第二种创建组件的方式"><a href="#React中：第二种创建组件的方式" class="headerlink" title="React中：第二种创建组件的方式"></a>React中：第二种创建组件的方式</h4><h5 id="了解ES6中class关键字的使用"><a href="#了解ES6中class关键字的使用" class="headerlink" title="了解ES6中class关键字的使用"></a>了解ES6中class关键字的使用</h5><h5 id="基于class关键字创建组件"><a href="#基于class关键字创建组件" class="headerlink" title="基于class关键字创建组件"></a>基于class关键字创建组件</h5><ul>
<li><p>使用 class 关键字来创建组件</p>
<p>render 函数的作用： 是渲染 当前组件所对应的 虚拟DOM元素</p>
<p>类中的 this 指向这个类的实例对象</p>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">       </span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">super</span>()</span><br><span class="line">        <span class="comment">// 这个this.state = &#123;&#125; 相当于vue中的data()&#123;return&#123;&#125;&#125;</span></span><br><span class="line">        <span class="comment">// 这个是可读可写的</span></span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            msg : <span class="string">'大家好！'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  	</span><br><span class="line">    <span class="comment">// 在class创建的组件中，必须定义一个render函数</span></span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="comment">// 在render函数中，必须返回一个null或者符合规范的虚拟DOM元素</span></span><br><span class="line">        <span class="comment">// 在 class关键字创建的组件中，如果想使用 外界传递过来的 props 参数，不需要接收，直接通过 this.props.***</span></span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是用 class 关键字创建的组件！--- &#123; this.props.name &#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">        	<span class="tag">&lt;<span class="name">p</span>&gt;</span> &#123; this.state.msg &#125; <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 Person 标签,就是 上面Person 类的一个实例对象</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">    name=<span class="string">'zs'</span></span><br><span class="line">    age=<span class="number">22</span></span><br><span class="line">    gender:<span class="string">'男'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//&lt;Person name=&#123;user.name&#125; age=&#123;user.age&#125;&gt;&lt;/Person&gt;</span></span><br><span class="line">&lt;Person &#123;...user&#125;&gt;&lt;<span class="regexp">/Person&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="两种创建组件方式的对比"><a href="#两种创建组件方式的对比" class="headerlink" title="两种创建组件方式的对比"></a>两种创建组件方式的对比</h4><blockquote>
<p>注意：使用class关键字创建的组件，有自己的私有数据和生命周期函数</p>
<p>​            使用function创建的组件，只有props，没有自己的私有数据和生命周期函数</p>
</blockquote>
<ol>
<li>用构造函数创建出来的组件：专业的名字叫做“无状态组件”</li>
<li>用class关键字创建出来的组件：专业的名字叫做“有状态组件”</li>
</ol>
<blockquote>
<p>用构造函数创建出来的组件，和用class创建出来的组件，这两种不同的组件之间的<strong>本质区别就是</strong>：有无state属性<br>有状态组件和无状态组件之间的本质区别就是：有无state属性 和 生命周期函数</p>
</blockquote>
<p>组件中的 <code>props</code> 和 <code>state/data</code> 之间的区别</p>
<ul>
<li>props 中的数据都是外界传递过来的</li>
<li>state/data 中的数据， 都是组件私有的（通过Ajax 获取回来的数据，一般都是私有数据）</li>
<li>props 中的数据 都是只读的，不能重新赋值</li>
<li>state/data 中的数据，都是可读可写的</li>
</ul>
<h4 id="一个小案例，巩固有状态组件和无状态组件的使用"><a href="#一个小案例，巩固有状态组件和无状态组件的使用" class="headerlink" title="一个小案例，巩固有状态组件和无状态组件的使用"></a>一个小案例，巩固有状态组件和无状态组件的使用</h4><h5 id="通过for循环生成多个组件"><a href="#通过for循环生成多个组件" class="headerlink" title="通过for循环生成多个组件"></a>通过for循环生成多个组件</h5><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CmtItem</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>评论人： &#123;props.user&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">    	<span class="tag">&lt;<span class="name">h1</span>&gt;</span>评论内容： &#123;props.content&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CmtList</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">super</span>()</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;          </span><br><span class="line">            CommentList = [</span><br><span class="line">                &#123; <span class="attr">user</span>: <span class="string">'张三'</span>, <span class="attr">content</span>: <span class="string">'哈哈，沙发'</span> &#125;,</span><br><span class="line">                &#123; <span class="attr">user</span>: <span class="string">'张三2'</span>, <span class="attr">content</span>: <span class="string">'哈哈，板凳'</span> &#125;,</span><br><span class="line">                &#123; <span class="attr">user</span>: <span class="string">'张三3'</span>, <span class="attr">content</span>: <span class="string">'哈哈，凉席'</span> &#125;,</span><br><span class="line">                &#123; <span class="attr">user</span>: <span class="string">'张三4'</span>, <span class="attr">content</span>: <span class="string">'哈哈，砖头'</span> &#125;,</span><br><span class="line">                &#123; <span class="attr">user</span>: <span class="string">'张三5'</span>, <span class="attr">content</span>: <span class="string">'哈哈，楼下山炮'</span> &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	render()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span> 这是评论列表组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">            &#123;this.state.CommentList.map(item =&gt; <span class="tag">&lt;<span class="name">CmtItem</span> &#123;<span class="attr">...item</span>&#125; <span class="attr">key</span>=<span class="string">&#123;item.id&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">CmtItem</span>&gt;</span>)&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用render 函数渲染</span></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">CmtList</span>&gt;</span><span class="tag">&lt;/<span class="name">CmtList</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>))</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：在webpack.config.js中配置 @ 代表绝对路径./src。</p>
<p>后面就不用    ./    这种相对路径了</p>
</blockquote>
<p>将父组件CmtList、子组件CmtItem抽离为.jsx文件</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">CmtItem</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>评论人： &#123;props.user&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">    	<span class="tag">&lt;<span class="name">h1</span>&gt;</span>评论内容： &#123;props.content&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 導入 评论项子组件</span></span><br><span class="line"><span class="keyword">import</span> CmtItem <span class="keyword">from</span> <span class="string">'@/components/CmtItem'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">CmtList</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">super</span>()</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;          </span><br><span class="line">            CommentList = [</span><br><span class="line">                &#123; <span class="attr">user</span>: <span class="string">'张三'</span>, <span class="attr">content</span>: <span class="string">'哈哈，沙发'</span> &#125;,</span><br><span class="line">                &#123; <span class="attr">user</span>: <span class="string">'张三2'</span>, <span class="attr">content</span>: <span class="string">'哈哈，板凳'</span> &#125;,</span><br><span class="line">                &#123; <span class="attr">user</span>: <span class="string">'张三3'</span>, <span class="attr">content</span>: <span class="string">'哈哈，凉席'</span> &#125;,</span><br><span class="line">                &#123; <span class="attr">user</span>: <span class="string">'张三4'</span>, <span class="attr">content</span>: <span class="string">'哈哈，砖头'</span> &#125;,</span><br><span class="line">                &#123; <span class="attr">user</span>: <span class="string">'张三5'</span>, <span class="attr">content</span>: <span class="string">'哈哈，楼下山炮'</span> &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	render()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span> 这是评论列表组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">            &#123;this.state.CommentList.map(item =&gt; <span class="tag">&lt;<span class="name">CmtItem</span> &#123;<span class="attr">...item</span>&#125; <span class="attr">key</span>=<span class="string">&#123;item.id&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">CmtItem</span>&gt;</span>)&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> CmtList <span class="keyword">from</span> <span class="string">'@/components/CmtList'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用render 函数渲染</span></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">CmtList</span>&gt;</span><span class="tag">&lt;/<span class="name">CmtList</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>))</span><br></pre></td></tr></table></figure>



<h5 id="style样式"><a href="#style样式" class="headerlink" title="style样式"></a>style样式</h5><h4 id="使用CSS模块化"><a href="#使用CSS模块化" class="headerlink" title="使用CSS模块化"></a>使用CSS模块化</h4><ol>
<li><p>可以在webpack.config.js中为css-loader启用模块化：</p>
<img src="/2020/03/24/React-3/r2.png" class>
</li>
<li><p>另外两种方法：</p>
<img src="/2020/03/24/React-3/r3.png" class>

</li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>理解React中虚拟DOM的概念<br>理解React中三种Diff算法的概念<br>使用JS中createElement的方式创建虚拟DOM<br>使用ReactDOM.render方法<br>使用JSX语法并理解其本质<br>掌握创建组件的两种方式<br>理解有状态组件和无状态组件的本质区别<br>理解props和state的区别</p>
<h4 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h4><ul>
<li><a href="http://www.cnblogs.com/tim100/p/6050514.html">React数据流和组件间的沟通总结</a></li>
<li><a href="https://segmentfault.com/q/1010000005876655/a-1020000005876751">单向数据流和双向绑定各有什么优缺点？</a></li>
<li><a href="https://www.zhihu.com/question/29504639?sort=created">怎么更好的理解虚拟DOM?</a></li>
<li><a href="http://www.css88.com/react/index.html">React中文文档 - 版本较低</a></li>
<li><a href="http://blog.csdn.net/yczz/article/details/49886061">React 源码剖析系列 － 不可思议的 react diff</a></li>
<li><a href="http://www.infoq.com/cn/articles/react-dom-diff?from=timeline&isappinstalled=0">深入浅出React（四）：虚拟DOM Diff算法解析</a></li>
<li><a href="http://www.cocoachina.com/webapp/20150721/12692.html">一看就懂的ReactJs入门教程（精华版）</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2016/06/css_modules.html">CSS Modules 用法教程</a></li>
<li><a href="http://blog.csdn.net/itzhongzi/article/details/66045880">将MarkDown转换为HTML页面</a></li>
<li><a href="https://jingyan.baidu.com/article/0320e2c1c9cf0e1b87507b26.html">win7命令行 端口占用 查询进程号 杀进程</a></li>
</ul>
]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>React 4</title>
    <url>/2020/03/26/React-4/</url>
    <content><![CDATA[<h4 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h4><a id="more"></a>

<ul>
<li><p>概念：在组件创建、到加载到页面上运行、以及组件被销毁的过程中，总是伴随着各种各样的事件，这些在组件特定时期，触发的事件，统称为 组件的生命周期；</p>
</li>
<li><p>组件生命周期分为三部分：</p>
<ul>
<li><strong>组件创建阶段</strong>：组件创建阶段的生命周期函数，有一个显著的特点：创建阶段的生命周期函数，在组件的一辈子中，只执行一次；</li>
</ul>
<blockquote>
<p>componentWillMount: 组件将要被挂载，此时还没有开始渲染虚拟DOM<br>render：第一次开始渲染真正的虚拟DOM，当render执行完，内存中就有了完整的虚拟DOM了<br>componentDidMount: 组件完成了挂载，此时，组件已经显示到了页面上，当这个方法执行完，组件就进入都了 运行中 的状态</p>
</blockquote>
<ul>
<li><strong>组件运行阶段</strong>：也有一个显著的特点，根据组件的state和props的改变，有选择性的触发0次或多次；</li>
</ul>
<blockquote>
<p>componentWillReceiveProps: 组件将要接收新属性，此时，只要这个方法被触发，就证明父组件为当前子组件传递了新的属性值；<br>shouldComponentUpdate: 组件是否需要被更新，此时，组件尚未被更新，但是，state 和 props 肯定是最新的<br>componentWillUpdate: 组件将要被更新，此时，尚未开始更新，内存中的虚拟DOM树还是旧的<br>render: 此时，又要重新根据最新的 state 和 props 重新渲染一棵内存中的 虚拟DOM树，当 render 调用完毕，内存中的旧DOM树，已经被新DOM树替换了！此时页面还是旧的<br>componentDidUpdate: 此时，页面又被重新渲染了，state 和 虚拟DOM 和 页面已经完全保持同步</p>
</blockquote>
<ul>
<li><strong>组件销毁阶段</strong>：也有一个显著的特点，一辈子只执行一次；</li>
</ul>
<blockquote>
<p>componentWillUnmount: 组件将要被卸载，此时组件还可以正常使用；</p>
</blockquote>
</li>
</ul>
<p><a href="https://cn.vuejs.org/v2/guide/instance.html#生命周期图示">vue中的生命周期图</a><br><a href="http://www.race604.com/react-native-component-lifecycle/">React Native 中组件的生命周期</a></p>
<img src="/2020/03/26/React-4/React%E4%B8%AD%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" class>

<h5 id="defaultProps"><a href="#defaultProps" class="headerlink" title="defaultProps"></a>defaultProps</h5><blockquote>
<p>在组件创建之前，会先初始化默认的props属性，这是全局调用一次，严格地来说，这不是组件的生命周期的一部分。在组件被创建并加载候，首先调用 constructor 构造器中的 this.state = {}，来初始化组件的状态。</p>
</blockquote>
<p>React生命周期的回调函数总结成表格如下：</p>
<img src="/2020/03/26/React-4/React%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%A1%A8%E6%A0%BC.png" class>

<ul>
<li><p>Mounting：</p>
<ul>
<li>constructor()</li>
<li>componentWillMount()</li>
<li>render()</li>
<li>componentDidMount()</li>
</ul>
</li>
<li><p>Updating：</p>
<ul>
<li>componentWillReceiveProps(nextProps)</li>
<li>shouldComponentUpdate(nextProps, nextState)</li>
<li>componentWillUpdate(nextProps, nextState)</li>
<li>render()</li>
<li>componentDidUpdate(prevProps, prevState)</li>
</ul>
</li>
<li><p>Unmounting：</p>
<ul>
<li>componentWillUnmount()</li>
</ul>
</li>
</ul>
<h4 id="通过Counter计数器的小案例-了解生命周期函数"><a href="#通过Counter计数器的小案例-了解生命周期函数" class="headerlink" title="通过Counter计数器的小案例 - 了解生命周期函数"></a>通过Counter计数器的小案例 - 了解生命周期函数</h4><ol>
<li>给组件设置默认属性：</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 设置 默认属性值 */</span></span><br><span class="line">   <span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">       initcount:<span class="number">0</span> <span class="comment">// 如果外界没有传initcount值，那就初始化为0</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>给属性进行类型校验，需要先运行<code>cnpm i prop-types --save</code></li>
</ol>
<h4 id="组件初始化时生命周期事件总结"><a href="#组件初始化时生命周期事件总结" class="headerlink" title="组件初始化时生命周期事件总结"></a>组件初始化时生命周期事件总结</h4><ol>
<li>componentWillMount：</li>
<li>render：</li>
<li>componentDidMount：</li>
<li>注意：在render函数中，不能调用<code>setState()</code>方法</li>
</ol>
<h4 id="通过原生的方式获取元素并绑定事件"><a href="#通过原生的方式获取元素并绑定事件" class="headerlink" title="通过原生的方式获取元素并绑定事件"></a>通过原生的方式获取元素并绑定事件</h4><h4 id="React中使用ref属性获取DOM元素引用"><a href="#React中使用ref属性获取DOM元素引用" class="headerlink" title="React中使用ref属性获取DOM元素引用"></a>React中使用ref属性获取DOM元素引用</h4><h4 id="使用React中的事件，绑定count自增"><a href="#使用React中的事件，绑定count自增" class="headerlink" title="使用React中的事件，绑定count自增"></a>使用React中的事件，绑定count自增</h4><h4 id="组件运行中事件的对比"><a href="#组件运行中事件的对比" class="headerlink" title="组件运行中事件的对比"></a>组件运行中事件的对比</h4><ol>
<li>shouldComponentUpdate：</li>
<li>componentWillUpdate：</li>
<li>render：</li>
<li>componentDidUpdate：</li>
</ol>
<h4 id="绑定this并传参的三种方式"><a href="#绑定this并传参的三种方式" class="headerlink" title="绑定this并传参的三种方式"></a>绑定this并传参的三种方式</h4><ol>
<li><p>在事件中绑定this并传参：</p>
<blockquote>
<p>bind 作用： 为前面的函数(handleMsg1)，修改函数内部的this指向，让函数内部的this，指向bind参数列表中的第一个参数</p>
<p>bind 和 call/apply 之间的区别：</p>
<p>call/aplly 修改完this指向后，会立即调用前面的函数，但是bind只会修改this 指向， 并不会调用</p>
<p>注意：bind 中的第一个参数，是用来修改this指向的，第一个参数后面的所有参数，都会当作将来调用 前面函数时候的参数传递进去</p>
</blockquote>
</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">"button"</span> value=<span class="string">"在事件中绑定this并传参"</span> onClick=&#123;<span class="keyword">this</span>.handleMsg1.bind(<span class="keyword">this</span>, <span class="string">'🍕'</span>, <span class="string">'🍟'</span>)&#125; /&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在事件中绑定this并传参</span></span><br><span class="line">handleMsg1(arg1, arg2) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 此时this是个null</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        msg: <span class="string">'在事件中绑定this并传参：'</span> + arg1 + arg2</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>在构造函数中绑定this并传参:</p>
<blockquote>
<p>全局只bind一次，上面那种每次调用这个方法(this.handleMsg2),都要bind一次</p>
</blockquote>
</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// 修改构造函数中的代码：</span></span><br><span class="line"><span class="comment">// 注意：调用bind改变this指向后，bind函数调用的结果，有一个返回值。这个值，就是被改变this指向后的函数的应用</span></span><br><span class="line"><span class="comment">// 注意：bind不会修改原函数的this指向</span></span><br><span class="line">   <span class="keyword">this</span>.handleMsg2 = <span class="keyword">this</span>.handleMsg2.bind(<span class="keyword">this</span>, <span class="string">'🚗'</span>, <span class="string">'🚚'</span>);</span><br><span class="line"></span><br><span class="line">   &lt;input type=<span class="string">"button"</span> value=<span class="string">"在构造函数中绑定this并传参"</span> onClick=&#123;<span class="keyword">this</span>.handleMsg2&#125; /&gt;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 在构造函数中绑定this并传参</span></span><br><span class="line">   handleMsg2(arg1, arg2) &#123;</span><br><span class="line">       <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">           msg: <span class="string">'在构造函数中绑定this并传参：'</span> + arg1 + arg2</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>用箭头函数绑定this并传参：</p>
<p>箭头函数 本身就是一个 匿名的 function函数</p>
<p>function默认的this，谁调用这个function，this就指向谁</p>
<p>但箭头函数 this指向 外层 上下文</p>
</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">    &lt;input type=<span class="string">"button"</span> value=<span class="string">"用箭头函数绑定this并传参"</span> onClick=&#123;() =&gt; &#123; <span class="keyword">this</span>.handleMsg3(<span class="string">'👩'</span>, <span class="string">'👰'</span>) &#125;&#125; /&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用箭头函数绑定this并传参</span></span><br><span class="line">        handleMsg3(arg1, arg2) &#123;</span><br><span class="line">            <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">                msg: <span class="string">'用箭头函数绑定this并传参：'</span> + arg1 + arg2</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// ----------------------------------------------------------------- //</span></span><br><span class="line">		</span><br><span class="line">		handleMsg3 = <span class="function">(<span class="params">arg1, arg2</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">                msg: <span class="string">'用箭头函数绑定this并传参：'</span> + arg1 + arg2</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h4 id="绑定文本框与state中的值"><a href="#绑定文本框与state中的值" class="headerlink" title="绑定文本框与state中的值"></a>绑定文本框与state中的值</h4><ol>
<li>在Vue.js中，默认可以通过<code>v-model</code>指令，将表单控件和我们的<code>data</code>上面的属性进行双向数据绑定，数据变化和页面之间的变化是同步的！</li>
<li>在React.js中，默认没有提供双向数据绑定这一功能，默认的，只能把<code>state</code>之上的数据同步到界面的控件上，但是不能默认实现把界面上数据的改变，同步到<code>state</code>之上，需要程序员手动调用相关的事件，来进行逆向的数据传输！</li>
<li>绑定文本框和state的值：</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&#123;<span class="comment">/*只要将value属性，和state上的状态进行绑定，那么，这个表单元素就变成了受控表单元素，这时候，如果没有调用相关的事件，是无法手动修改表单元素中的值的*/</span>&#125;</span><br><span class="line">&lt;input style=&#123;&#123; <span class="attr">width</span>: <span class="string">'100%'</span> &#125;&#125; ref=<span class="string">"txt"</span> type=<span class="string">"text"</span> value=&#123;<span class="keyword">this</span>.state.msg&#125; onChange=&#123;<span class="keyword">this</span>.handleTextChange&#125; /&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是文本框内容改变时候的处理函数</span></span><br><span class="line">handleTextChange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        msg: <span class="keyword">this</span>.refs.txt.value</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<img src="/2020/03/26/React-4/%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A.png" class>

<ol start="4">
<li><p>注意 <code>setState</code>的一个问题：</p>
<p>在 <code>setState</code>， 只会把 对应的 state 状态更新，而不会 覆盖其他的state状态</p>
<p><code>this.setState</code>  方法的执行 是异步的</p>
</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保存最新的state状态值，在保存的时候，是异步地进行保存的，所以，如果想要获取最新的，刚刚保存的那个状态，需要通过回掉函数的形式去获取最新state</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    msg: <span class="keyword">this</span>.refs.txt.value</span><br><span class="line">    <span class="comment">// msg: e.target.value</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取最新的state状态值</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.msg);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<h4 id="发表评论案例"><a href="#发表评论案例" class="headerlink" title="发表评论案例"></a>发表评论案例</h4><h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><h5 id="context特性"><a href="#context特性" class="headerlink" title="context特性"></a>context特性</h5><p>记住一串单词组合<code>getChildContextTypes</code><br>前3个、后3个、后两个<br>一个方法、两个静态属性</p>
<h4 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h4><p><a href="https://facebook.github.io/react/docs/typechecking-with-proptypes.html">类型校验</a><br><a href="https://reactjs.org/docs/animation.html#high-level-api-reactcsstransitiongroup">Animation Add-Ons</a></p>
]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>The farewell</title>
    <url>/2021/03/09/The-farewell/</url>
    <content><![CDATA[<p>纽约一声大喝，惊扰长春飞鸟</p>
<a id="more"></a>

<p>YOU THINK ONE’S LIFE BELONGS TO ONESELF.</p>
<img src="/2021/03/09/The-farewell/t1.jpg" class>]]></content>
      <categories>
        <category>电影</category>
      </categories>
      <tags>
        <tag>电影</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript01</title>
    <url>/2020/03/17/TypeScript01/</url>
    <content><![CDATA[<h4 id="TypeScript-基础"><a href="#TypeScript-基础" class="headerlink" title="TypeScript 基础"></a>TypeScript 基础</h4><a id="more"></a>

<p>Typescript 是微软推出的一门语言，是JavaScript的超集，包含ES567</p>
<p>新增了类型系统和完整的面向对象</p>
<h4 id="第一章-TypeScript-基础"><a href="#第一章-TypeScript-基础" class="headerlink" title="第一章 TypeScript 基础"></a>第一章 TypeScript 基础</h4><h4 id="01-TypeScript-环境安装"><a href="#01-TypeScript-环境安装" class="headerlink" title="01.TypeScript 环境安装"></a>01.TypeScript 环境安装</h4><ol>
<li><p>需要一个工具，将ts代码转换为浏览器或者nodejs识别的js代码，就需要ts环境（npm，nodejs的包管理器，用npm下载ts环境；网上下载安装nodejs，cmd node -v 查看）-&gt;cmd中 tsc -v 查看</p>
<ul>
<li>全局安装： <em>npm i -g typescript</em></li>
<li>校验typescript： <em>tsc -v</em></li>
<li>tsc的作用：<em>负责将ts代码转为浏览器、nodejs识别的js代码</em></li>
</ul>
</li>
<li><p>第一个ts程序</p>
<ul>
<li><p>在后缀名为.ts文件中写typescript代码</p>
</li>
<li><p>使用tsc工具将typescript代码编译为浏览器、nodejs识别的js代码</p>
</li>
<li><p>在浏览器或者nodejs中执行js代码</p>
<p><em>ts -&gt; js -&gt; html scprit标签引入</em></p>
</li>
</ul>
</li>
<li><p>在nodejs中执行typescript代码</p>
<ul>
<li>执行tsc转换过后的js代码   <em>node xxx.js</em></li>
</ul>
</li>
<li><p>ts-node ： 自动将ts代码转换为js代码，并将其在nodejs中执行</p>
<ul>
<li>安装 <em>npm i -g ts-node</em></li>
<li>使用 <em>ts-node xxx.ts</em>文件名</li>
</ul>
</li>
<li><p>vscode配置自动编译（功能同4）</p>
<ul>
<li>tsc –init 生成tsconfig.json 改”outDir”:’./js’</li>
<li>终端-运行任务-监视tsconfig.json</li>
</ul>
</li>
</ol>
<h4 id="02-TypeScript-数据类型-变量"><a href="#02-TypeScript-数据类型-变量" class="headerlink" title="02. TypeScript 数据类型 | 变量"></a>02. TypeScript 数据类型 | 变量</h4><ol>
<li><p>在JavaScript中，变量中可以存储任意类型的数据</p>
<p><em>var a = 10； a = “jack” ； a=true；</em></p>
</li>
<li><p>但是在TS语法规定：在声明变量的时候，必须制定变量的类型</p>
</li>
<li><p>声明变量的语法： </p>
<p><u>let 变量名：变量类型</u></p>
<p><em>let age： number</em></p>
<p><em>let myName： String</em></p>
</li>
<li><p>变量的类型一旦指定后，这个变量只能存储这个类型的数据</p>
<p><em>age = 18</em>； 这样可以的</p>
<p><em>age = “jack”</em> 错误 -&gt; 因为上面age指定了类型为number</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> flag: boolean = <span class="literal">true</span></span><br><span class="line">flag = <span class="literal">false</span></span><br><span class="line"><span class="built_in">console</span>.log(flag)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str: string = <span class="string">''</span></span><br><span class="line">str = <span class="string">'12300'</span></span><br><span class="line"><span class="built_in">console</span>.log(str)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr:number[]=[<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr2:<span class="built_in">Array</span>&lt;number&gt;=[<span class="number">33</span>,<span class="number">22</span>,<span class="number">11</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr3:string[]=[<span class="string">'1'</span>,<span class="string">'2str'</span>,<span class="string">'3str'</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr3)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr4:object[]=[&#123;<span class="attr">name</span>:<span class="string">'hall'</span>,<span class="attr">age</span>:<span class="string">'18'</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">'xun'</span>,<span class="attr">age</span>:<span class="string">'19'</span>&#125;]</span><br><span class="line"><span class="built_in">console</span>.log(arr4)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元组类型</span></span><br><span class="line"><span class="keyword">var</span> arr5:[number,string]=[<span class="number">123</span>,<span class="string">'this is str'</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr5)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚舉类型，使用单词就能够知道单纯的数字表示什么意思。易读</span></span><br><span class="line">enum Flag &#123;success=<span class="number">1</span>,error=<span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">let</span> s:Flag=Flag.success</span><br><span class="line"><span class="built_in">console</span>.log(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任意类型</span></span><br><span class="line"><span class="keyword">var</span> num:any=<span class="number">123</span></span><br><span class="line">num=<span class="string">'str'</span></span><br><span class="line">num=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined null 类型</span></span><br><span class="line"><span class="keyword">var</span> a:<span class="literal">undefined</span></span><br><span class="line">a=<span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b:<span class="literal">null</span></span><br><span class="line">b=<span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c:never</span><br><span class="line"><span class="comment">// c='122' 报错 c是never类型，从不使用类型</span></span><br><span class="line"><span class="comment">// 抛出异常，不常用</span></span><br><span class="line">c=<span class="function">(<span class="params">(</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'错误'</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>


</li>
</ol>
]]></content>
      <categories>
        <category>Typescript</category>
      </categories>
      <tags>
        <tag>TS</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript03</title>
    <url>/2020/03/18/TypeScript03/</url>
    <content><![CDATA[<h4 id="TypeScript中的类（上）"><a href="#TypeScript中的类（上）" class="headerlink" title="TypeScript中的类（上）"></a>TypeScript中的类（上）</h4><a id="more"></a>

<p>es5里面的类</p>
<ol>
<li><h5 id="最简单的类"><a href="#最简单的类" class="headerlink" title="最简单的类"></a>最简单的类</h5></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'xiaoyi'</span></span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(p)</span><br><span class="line"><span class="built_in">console</span>.log(p.name)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><h5 id="构造函数和原型链里面增加方法"><a href="#构造函数和原型链里面增加方法" class="headerlink" title="构造函数和原型链里面增加方法"></a>构造函数和原型链里面增加方法</h5></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'xiaoyi'</span>     <span class="comment">/*属性*/</span></span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">20</span></span><br><span class="line">  <span class="keyword">this</span>.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;   <span class="comment">/*实例方法*/</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'在运动'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.sex = <span class="string">'男'</span> <span class="comment">//在原型链上添加一个方法,原型链上面的属性会被多个实例共享</span></span><br><span class="line">Person.prototype.work = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'在工作'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(p.name)</span><br><span class="line"><span class="built_in">console</span>.log(p.sex)</span><br><span class="line">p.run()</span><br><span class="line">p.work()</span><br></pre></td></tr></table></figure>



<ol start="3">
<li><h5 id="类里面的静态方法"><a href="#类里面的静态方法" class="headerlink" title="类里面的静态方法"></a>类里面的静态方法</h5></li>
<li><h5 id="es5里面的继承，对象冒充实现继承-原型鏈加对象冒充的组合继承模式"><a href="#es5里面的继承，对象冒充实现继承-原型鏈加对象冒充的组合继承模式" class="headerlink" title="es5里面的继承，对象冒充实现继承, 原型鏈加对象冒充的组合继承模式"></a>es5里面的继承，对象冒充实现继承, 原型鏈加对象冒充的组合继承模式</h5></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.name = <span class="string">'xiaoyi'</span> <span class="comment">/*属性*/</span></span><br><span class="line">   <span class="keyword">this</span>.age = <span class="number">20</span></span><br><span class="line">   <span class="keyword">this</span>.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">/*实例方法*/</span></span><br><span class="line">     <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'在运动'</span>)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> Person.prototype.sex = <span class="string">'男'</span> <span class="comment">//在原型链上添加一个方法,原型链上面的属性会被多个实例共享</span></span><br><span class="line"> Person.prototype.work = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'在工作'</span>)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> p = <span class="keyword">new</span> Person()</span><br><span class="line">   <span class="comment">// p.work()</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">// web类继承Person类  原型链加对象冒充的组合继承模式</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">Web</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   Person.call(<span class="keyword">this</span>) <span class="comment">/*改变this指向，对象冒充可以继承构造函数里面的属性和方法*/</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> w = <span class="keyword">new</span> Web()</span><br><span class="line"> w.run() <span class="comment">/*对象冒充可以继承构造函数里面的属性和方法*/</span></span><br><span class="line"> w.work() <span class="comment">/*但不能继承原型链上的属性和方法*/</span></span><br></pre></td></tr></table></figure>



<ol start="5">
<li><h5 id="es5里面的继承，原型链实现继承"><a href="#es5里面的继承，原型链实现继承" class="headerlink" title="es5里面的继承，原型链实现继承"></a>es5里面的继承，原型链实现继承</h5></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'xiaoyi'</span> <span class="comment">/*属性*/</span></span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">20</span></span><br><span class="line">  <span class="keyword">this</span>.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">/*实例方法*/</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'在运动'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sex = <span class="string">'男'</span></span><br><span class="line">Person.prototype.work = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'在工作'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Web</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Web.prototype = <span class="keyword">new</span> Person() <span class="comment">/*原型链实现继承*/</span></span><br><span class="line"><span class="keyword">var</span> w = <span class="keyword">new</span> Web()</span><br><span class="line">w.run()</span><br><span class="line">w.work()</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><h5 id="原型链实现继承的-问题"><a href="#原型链实现继承的-问题" class="headerlink" title="原型链实现继承的 问题"></a>原型链实现继承的 问题</h5></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="keyword">this</span>.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">/*实例方法*/</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'在运动'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.sex = <span class="string">'男'</span></span><br><span class="line">Person.prototype.work = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'在工作'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">'xiaxa'</span>, <span class="number">25</span>)</span><br><span class="line">p.run()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Web</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Web.prototype = <span class="keyword">new</span> Person() <span class="comment">/*原型链实现继承*/</span></span><br><span class="line"><span class="keyword">var</span> w = <span class="keyword">new</span> Web(<span class="string">'xaxaxaxaxa'</span>, <span class="number">26</span>) <span class="comment">/*实例化子类的时候，没法给父类传参*/</span></span><br><span class="line">w.run()</span><br><span class="line">w.work()</span><br></pre></td></tr></table></figure>



<ol start="7">
<li><h5 id="原型链加构造函数的组合继承模式"><a href="#原型链加构造函数的组合继承模式" class="headerlink" title="原型链加构造函数的组合继承模式"></a>原型链加构造函数的组合继承模式</h5></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">​    <span class="keyword">this</span>.name = name</span><br><span class="line">​    <span class="keyword">this</span>.age = age</span><br><span class="line">​    <span class="keyword">this</span>.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">/*实例方法*/</span></span><br><span class="line">​      <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'在运动'</span>)</span><br><span class="line">​    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Person.prototype.sex = <span class="string">'男'</span></span><br><span class="line">  Person.prototype.work = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">​    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'在工作'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">'xiaxa'</span>, <span class="number">25</span>)</span><br><span class="line">  p.run()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// web类继承Person类  原型链加对象冒充的组合继承模式</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Web</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">​    Person.call(<span class="keyword">this</span>, name, age) <span class="comment">/*对象冒充继承，实例化子类可以给父类传参*/</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Web.prototype = <span class="keyword">new</span> Person() <span class="comment">/*原型链实现继承*/</span></span><br><span class="line"><span class="comment">//Web.prototype = Person.prototypr /*也可以*/</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> w = <span class="keyword">new</span> Web(<span class="string">'lily'</span>, <span class="number">26</span>) <span class="comment">/*实例化子类的时候，没法给父类传参*/</span></span><br><span class="line">  w.run()</span><br><span class="line">  w.work()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Typescript</category>
      </categories>
      <tags>
        <tag>TS</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript02</title>
    <url>/2020/03/18/TypeScript02/</url>
    <content><![CDATA[<h4 id="TypeScript中的函数"><a href="#TypeScript中的函数" class="headerlink" title="TypeScript中的函数"></a>TypeScript中的函数</h4><a id="more"></a>

<h4 id="1-函数的定义"><a href="#1-函数的定义" class="headerlink" title="1. 函数的定义"></a>1. 函数的定义</h4><p>1.1. es5定义函数的方法</p>
<pre><code><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'run'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 匿名函数 -&gt; 没有函数名，直接返回为变量run2</span></span><br><span class="line"><span class="keyword">var</span> run2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'run2'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>1.2. TS中定义函数的方法</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>):<span class="title">string</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'123'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名函数</span></span><br><span class="line"><span class="keyword">var</span> fun2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>):<span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">123321</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fun2())</span><br></pre></td></tr></table></figure>
<h4 id="2-函数的传参"><a href="#2-函数的传参" class="headerlink" title="2. 函数的传参"></a>2. 函数的传参</h4><p>2.1.  ts中定义方法传参 —&gt; ``模板字符拼接 es6</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params">name:<span class="built_in">string</span>,age:<span class="built_in">number</span></span>):<span class="title">string</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;name&#125;</span>---<span class="subst">$&#123;age&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getInfo(<span class="string">'xiaoyi'</span>,<span class="number">18</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getInfo2 = <span class="function"><span class="keyword">function</span>(<span class="params">name:<span class="built_in">string</span>,age:<span class="built_in">number</span></span>):<span class="title">string</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;name&#125;</span>---<span class="subst">$&#123;age&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getInfo2(<span class="string">'xiaoyi'</span>,<span class="number">22</span>))</span><br></pre></td></tr></table></figure>
<p>2.2. 没有返回值的方法</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runddd</span>(<span class="params"></span>): <span class="title">void</span></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'runddd'</span>)</span><br><span class="line">&#125;</span><br><span class="line">runddd()</span><br></pre></td></tr></table></figure>
<p>3.1. es5中，方法的实参和形参可以不一样，但是ts中必须一样，如果不一样，就需要配置可选参数</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params">name:<span class="built_in">string</span>,age?:<span class="built_in">number</span></span>):<span class="title">string</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(age)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;name&#125;</span>---<span class="subst">$&#123;age&#125;</span>`</span></span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;name&#125;</span>---年龄保密`</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">alert(getInfo(<span class="string">'xiaoyi'</span>,<span class="number">20</span>))</span><br><span class="line"><span class="comment">// 后面加个？就是可选参数</span></span><br><span class="line"><span class="comment">// 注意：可选参数必须配置到参数的最后面 -&gt;即如果age是可以选参数，那么age必须在name后面，即最后面</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>默认参数</p>
<p>es5里面没法设置默认参数，es6和ts中都可以设置默认参数</p>
<p>直接在<em>name:string=’xiaoyi’</em> 在声明参数的时候后面等于一下默认值就可以</p>
</li>
<li><p>剩余函数</p>
</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a:<span class="built_in">number</span>,b:<span class="built_in">number</span>,c:<span class="built_in">number</span>,d:<span class="built_in">number</span></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> a+b+c+d</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三点运算符es6 接收形参传过来的值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum2</span>(<span class="params">...result:<span class="built_in">number</span>[]</span>):<span class="title">number</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">result.forEach(<span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">sum = sum+element</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum2(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><p>函数重载</p>
<p>Java中方法的重载：重载指的是两个或两个以上同名函数，但它们的参数不一样，这时候会出现重载的情况</p>
<p>typescript中的重载：通过为同一个函数提供多个函数类型定义来试下多种功能的目的</p>
<p>es5中出现同名方法,下面的会替换上面的方法</p>
<p>TS中：</p>
 <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params">name:<span class="built_in">string</span></span>):<span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params">age:<span class="built_in">number</span></span>):<span class="title">string</span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params">str:<span class="built_in">any</span></span>):<span class="title">any</span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"> <span class="title">if</span>(<span class="params"><span class="keyword">typeof</span> str === '<span class="built_in">string</span>'</span>)</span>&#123;</span></span></span><br><span class="line"><span class="function"><span class="function">        <span class="title">return</span> '我叫'+<span class="title">str</span></span></span></span><br><span class="line"><span class="function"><span class="function">    &#125;<span class="title">else</span></span>&#123;</span></span><br><span class="line"><span class="function">        <span class="title">return</span> '我的年龄是'+<span class="title">str</span></span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function"><span class="title">getInfo</span>(<span class="params">'小易'</span>) √</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>箭头函数 es6 :this指向问题  箭头函数里面的this指向上下文</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Typescript</category>
      </categories>
      <tags>
        <tag>TS</tag>
      </tags>
  </entry>
  <entry>
    <title>django搭建</title>
    <url>/2020/04/03/django%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>搭建django的一些坑</p>
<a id="more"></a>

<h5 id="1-下载安装python"><a href="#1-下载安装python" class="headerlink" title="1. 下载安装python"></a>1. 下载安装python</h5><p>3.4以上新版python下载后自带pip，pip根据提示自我更新</p>
<h5 id="2-用python-的pip管理器去下载django"><a href="#2-用python-的pip管理器去下载django" class="headerlink" title="2. 用python 的pip管理器去下载django"></a>2. 用python 的pip管理器去下载django</h5><p>注意pip 和 django  和python 的版本</p>
<p>注意 pip 自我更新 和下载django的时候，报错重来，多下几次。</p>
<h5 id="3-配置django环境变量"><a href="#3-配置django环境变量" class="headerlink" title="3. 配置django环境变量"></a>3. 配置django环境变量</h5><p>在path中加入两个 一个是到script 一个是到bin</p>
<h5 id="4-下载安装pycharm社区版（官网）"><a href="#4-下载安装pycharm社区版（官网）" class="headerlink" title="4. 下载安装pycharm社区版（官网）"></a>4. 下载安装pycharm社区版（官网）</h5><p>目前双击打不开，用cmd可以输入pycharm打开，命令不能关</p>
<h5 id="5-pycharm-设置背景颜色-字体大小"><a href="#5-pycharm-设置背景颜色-字体大小" class="headerlink" title="5. pycharm 设置背景颜色 字体大小"></a>5. pycharm 设置背景颜色 字体大小</h5><p>settings里面的</p>
<h5 id="6-project-interpreter"><a href="#6-project-interpreter" class="headerlink" title="6. project interpreter"></a>6. project interpreter</h5><p>在settings -&gt; Project 中添加 python</p>
<h5 id="7-django项目要添加python-exe"><a href="#7-django项目要添加python-exe" class="headerlink" title="7. django项目要添加python.exe"></a>7. django项目要添加python.exe</h5><h5 id="8-在下面-的-Terminal终端中执行"><a href="#8-在下面-的-Terminal终端中执行" class="headerlink" title="8. 在下面 的 Terminal终端中执行"></a>8. 在下面 的 Terminal终端中执行</h5><p>python manage.py runserver 开启服务器，django自带一个小型服务器，自动开启8000端口号。可在settings文件中更改</p>
<h5 id="9-python-3-x和2-x"><a href="#9-python-3-x和2-x" class="headerlink" title="9. python 3.x和2.x"></a>9. python 3.x和2.x</h5><p>两个版本是由差距的，会影响django还有一些依赖插件比如pymysql是3.x用的</p>
<h5 id="10-接口测试时Forbidden-CSRF-cookie-not-set"><a href="#10-接口测试时Forbidden-CSRF-cookie-not-set" class="headerlink" title="10. 接口测试时Forbidden (CSRF cookie not set.)"></a>10. 接口测试时Forbidden (CSRF cookie not set.)</h5><p>可以去settings里面 MIDDLEWARE = [ 那个csrf. ]  注释掉</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Create your views here.</span></span><br><span class="line"><span class="keyword">from</span> django.views.decorators.csrf <span class="keyword">import</span> csrf_exempt</span><br><span class="line"> </span><br><span class="line"><span class="meta">@csrf_exempt </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_api</span><span class="params">(request)</span>:</span></span><br><span class="line">    dic = &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'GET'</span>:</span><br><span class="line">        dic[<span class="string">'message'</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(json.dumps(dic))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        dic[<span class="string">'message'</span>] = <span class="string">'方法错误'</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(json.dumps(dic, ensure_ascii=<span class="literal">False</span>))</span><br><span class="line">    </span><br><span class="line"> <span class="comment"># 这里是views里面的一个如何返回类似json文件的例子</span></span><br><span class="line"> <span class="comment"># 这样 就可以 简单的实现写views 不用管渲染的部分</span></span><br></pre></td></tr></table></figure>

<h5 id="11-ajax-简单传值"><a href="#11-ajax-简单传值" class="headerlink" title="11. ajax 简单传值"></a>11. ajax 简单传值</h5><img src="/2020/04/03/django%E6%90%AD%E5%BB%BA/d1.png" class>

<h5 id="12-Django-中-request方法"><a href="#12-Django-中-request方法" class="headerlink" title="12. Django 中 request方法"></a>12. Django 中 request方法</h5><p>request.session</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">请求的路径，这里的路径是指相对路径，也就是说一个登陆后台页面的请求：http:&#96;&#96;&#x2F;&#96;&#96;&#x2F;&#96;&#96;127.0&#96;&#96;.&#96;&#96;0.1&#96;&#96;:&#96;&#96;8000&#96;&#96;&#x2F;&#96;&#96;admin 的路径是 &#96;&#96;&#x2F;&#96;&#96;admin</span><br><span class="line">获取完整路径（包括参数）：HttpRequest.get_full_path()</span><br><span class="line">获取绝对url： HttpRequest.bulid_absolute_uri(location) 此参数默认为完整路径</span><br></pre></td></tr></table></figure>

<p>request.encoding</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">请求提交的数据的编码方式</span><br></pre></td></tr></table></figure>

<p> request.session</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">request.session 获取的是一个类似于字典的对象，可以进行读取写入操作，常用来保存一些数据来实现会话跟踪技术。 因为 HTTP 是一个无状态，不连续的协议。如果想让服务器记住当前的访问对象，就需要记录请求者的一些信息来达到这个目的。</span><br><span class="line"># 设置session&#96;&#96;request.session[&#96;&#96;&quot;name&quot;&#96;&#96;] &#96;&#96;&#x3D;&#96; &#96;&quot;root&quot;&#96;&#96;# 获取session&#96;&#96;name &#96;&#96;&#x3D;&#96; &#96;request.sessin[&#96;&#96;&quot;name&quot;&#96;&#96;]</span><br></pre></td></tr></table></figure>

<p>django会默认为session使用json序列化。json序列化只能序列化一些基本数据类型，如数字，字符串，列表等。所以session不能直接存储对象.可以简单的在settings中添加 SESSION_SERIALIZER = “django.contrib.sessions.serializers.PickleSerializer”</p>
<p>request.method   请求方式POST/GET</p>
<h5 id="13-request获取数据"><a href="#13-request获取数据" class="headerlink" title="13. request获取数据"></a>13. request获取数据</h5><p>request.body</p>
<p>请求的主体，返回一个字符串</p>
<p>request.data</p>
<p>请求数据部分，返回一个字典对象，其他和request.body很想</p>
<p><strong>request.POST</strong></p>
<p>获取post方式表单中提交的数据</p>
<p>request.POST[“username”]</p>
<p>request.POST.get（“username”）</p>
<p>request.GET</p>
<p>获取get方式表单中或url提交的数据</p>
<p>request.GET[“username”]</p>
<p>request.GET.get（“username”）</p>
<h5 id="14-postman请求"><a href="#14-postman请求" class="headerlink" title="14. postman请求"></a>14. postman请求</h5><p>请求post时，在body里面写参数！！</p>
<p>请求get时，在params里面写参数！！</p>
]]></content>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/06/24/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<h2 id="自定义样式"><a href="#自定义样式" class="headerlink" title="自定义样式"></a>自定义样式</h2><p>Hexo -&gt; source -&gt; _data -&gt; styles.styl</p>
<p>开发者模式调试样式，然后复制样式名，粘贴到这里来，就可以覆盖原来的样式</p>
]]></content>
  </entry>
  <entry>
    <title>Typora常用快捷键</title>
    <url>/2020/02/16/Typora%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<h4 id="Typora编写markdown快捷键"><a href="#Typora编写markdown快捷键" class="headerlink" title="Typora编写markdown快捷键"></a>Typora编写markdown快捷键</h4><a id="more"></a>

<ul>
<li><p>无序列表：输入-之后输入空格</p>
</li>
<li><p>有序列表：输入数字+“.”之后输入空格</p>
</li>
<li><p>任务列表：-[空格]空格 文字</p>
</li>
<li><p>标题：ctrl+数字</p>
<h3 id="ctrl-数字"><a href="#ctrl-数字" class="headerlink" title="ctrl+数字"></a>ctrl+数字</h3></li>
<li><p>表格：ctrl+t</p>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><p>生成目录：[TOC]按回车</p>
</li>
<li><p>选中一整行：ctrl+l</p>
</li>
<li><p>选中单词：ctrl+d</p>
</li>
<li><p>选中相同格式的文字：ctrl+e</p>
</li>
<li><p>跳转到文章开头：ctrl+home</p>
</li>
<li><p>跳转到文章结尾：ctrl+end</p>
</li>
<li><p>搜索：ctrl+f</p>
</li>
<li><p>替换：ctrl+h</p>
</li>
<li><p>引用：输入&gt;之后输入空格</p>
</li>
</ul>
<blockquote>
<p>引用格式</p>
</blockquote>
<ul>
<li>代码块：ctrl+alt+k</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'hello'</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>加粗：<strong>ctrl+b</strong></p>
</li>
<li><p>倾斜：<em>ctrl+i</em></p>
</li>
<li><p>下划线：<u>ctrl+u</u></p>
</li>
<li><p>删除线：<del>alt+shift+5</del></p>
</li>
<li><p>插入图片：直接拖动到指定位置即可或者ctrl+shift+i  也可以右击插入图片</p>
</li>
<li><p>插入链接：<a href>ctrl+k</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Typora技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>mongodb</title>
    <url>/2020/02/18/mongodb%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h4 id="Mongodb"><a href="#Mongodb" class="headerlink" title="Mongodb"></a>Mongodb</h4><a id="more"></a>

<p>MongoDB是一个基于分布式文件存储的数据库，由<a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=51909&ss_c=ssc.citiao.link">C++语言</a>编写。旨在为WEB应用提供可扩展的高性能数据<a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=63516207&ss_c=ssc.citiao.link">存储解决方案</a>。</p>
<ul>
<li><p>在node.js中开启mongodb       mongod –dbpath 存放data\db的路径  （F:/mongodb/data/db）</p>
</li>
<li><p>node.js中连接数据库，用mongoose</p>
</li>
<li><p>model里面的</p>
<p>var mongoose = require(‘mongoose’)</p>
<p>// 连接数据库,只需连接一次<br>mongoose.connect(‘mongodb://localhost/blog’)</p>
<p>var Schema = mongoose.Schema</p>
<p>var userSchema = new Schema({<br>  email: {</p>
<pre><code>type: String,
required: true</code></pre><p>  },……数据集合</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery</title>
    <url>/2020/03/27/jQuery/</url>
    <content><![CDATA[<p>jquery基础整合</p>
<a id="more"></a>

<blockquote>
<p>学习文档转自黑马教程</p>
</blockquote>
<p>使用javascript开发过程中，有许多的缺点：</p>
<ol>
<li>查找元素的方法单一，麻烦。</li>
<li>遍历数组很麻烦，通常要嵌套一大堆的for循环。</li>
<li>有兼容性问题。</li>
<li>想要实现简单的动画效果，也很麻烦</li>
<li>代码冗余。</li>
</ol>
<h2 id="体验jquery的使用"><a href="#体验jquery的使用" class="headerlink" title="体验jquery的使用"></a>体验jquery的使用</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 1. 查找元素的方法多种多样，非常灵活</span></span><br><span class="line"><span class="comment">* 2. 拥有隐式迭代特性，因此不再需要手写for循环了。</span></span><br><span class="line"><span class="comment">* 3. 完全没有兼容性问题。</span></span><br><span class="line"><span class="comment">* 4. 实现动画非常简单，而且功能更加的强大。</span></span><br><span class="line"><span class="comment">* 5. 代码简单、粗暴。</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">"#btn1"</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        $(<span class="string">"div"</span>).show(<span class="number">200</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    $(<span class="string">"#btn2"</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        $(<span class="string">"div"</span>).text(<span class="string">"我是内容"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="jquery到底是什么"><a href="#jquery到底是什么" class="headerlink" title="jquery到底是什么"></a>jquery到底是什么</h2><blockquote>
<p>jQuery的官网 <a href="http://jquery.com/">http://jquery.com/</a><br>jQuery就是一个js库，使用jQuery的话，会比使用JavaScript更简单。</p>
</blockquote>
<p><strong>What is jQuery?</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jQuery is a fast, small, and feature-rich JavaScript library. </span><br><span class="line">It makes things like HTML document traversal and manipulation, </span><br><span class="line">event handling, animation, and Ajax </span><br><span class="line">much simpler with an easy-to-use API that works across a multitude of browsers. </span><br><span class="line">With a combination of versatility and extensibility, </span><br><span class="line">jQuery has changed the way that millions of people write JavaScript.</span><br></pre></td></tr></table></figure>

<p>js库：把一些常用到的方法写到一个单独的js文件，使用的时候直接去引用这js文件就可以了。<br>（animate.js、common.js）</p>
<p>我们知道了，jQuery其实就是一个js文件，里面封装了一大堆的方法方便我们的开发，<br>其实就是一个加强版的common.js，因此我们学习jQuery，其实就是学习jQuery这个js文件中封装的一大堆方法。</p>
<h2 id="jquery的版本问题"><a href="#jquery的版本问题" class="headerlink" title="jquery的版本问题"></a>jquery的版本问题</h2><blockquote>
<p>官网下载地址：<a href="http://jquery.com/download/">http://jquery.com/download/</a><br>jQuery版本有很多，分为1.x 2.x 3.x<br>1.x和2.x版本jquery都不再更新版本了，现在只更新3.x版本。</p>
</blockquote>
<p>大版本分类：</p>
<ul>
<li>1.x版本：能够兼容IE678浏览器</li>
<li>2.x版本：不能兼容IE678浏览器</li>
<li>3.x版本：不能兼容IE678浏览器，更加的精简（在国内不流行，因为国内使用jQuery的主要目的就是兼容IE678）</li>
</ul>
<p>关于压缩版和未压缩版：  </p>
<ul>
<li>jquery-1.12.4.min.js:压缩版本，适用于生产环境，因为文件比较小，去除了注释、换行、空格等东西，但是基本没有颗阅读性。</li>
<li>jquery-1.12.4.js:未压缩版本，适用于学习与开发环境，源码清晰，易阅读。</li>
</ul>
<h2 id="jquery的入口函数"><a href="#jquery的入口函数" class="headerlink" title="jquery的入口函数"></a>jquery的入口函数</h2><p>使用jQuery的三个步骤：</p>
<ol>
<li>引入jQuery文件</li>
<li>入口函数</li>
<li>功能实现</li>
</ol>
<p>关于jQuery的入口函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一种写法</span></span><br><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//第二种写法</span></span><br><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>jQuery入口函数与js入口函数的对比：</p>
<ol>
<li>JavaScript的入口函数要等到页面中所有资源（包括图片、文件）加载完成才开始执行。</li>
<li>jQuery的入口函数只会等待文档树加载完成就开始执行，并不会等待图片、文件的加载。</li>
</ol>
<h2 id="jq对象和dom对象-重要"><a href="#jq对象和dom对象-重要" class="headerlink" title="jq对象和dom对象(重要)"></a>jq对象和dom对象(重要)</h2><ol>
<li>DOM对象：使用JavaScript中的方法获取页面中的元素返回的对象就是dom对象。</li>
<li>jQuery对象：jquery对象就是使用jquery的方法获取页面中的元素返回的对象就是jQuery对象。</li>
<li>jQuery对象其实就是DOM对象的包装集<strong>包装了DOM对象的集合（伪数组）</strong></li>
<li>DOM对象与jQuery对象的方法不能混用。</li>
</ol>
<p>DOM对象转换成jQuery对象：【联想记忆：花钱】</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> $obj = $(domObj);</span><br><span class="line"><span class="comment">// $(document).ready(function()&#123;&#125;);就是典型的DOM对象转jQuery对象</span></span><br></pre></td></tr></table></figure>

<p>jQuery对象转换成DOM对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> $li = $(<span class="string">"li"</span>);</span><br><span class="line"><span class="comment">//第一种方法（推荐使用）</span></span><br><span class="line">$li[<span class="number">0</span>]</span><br><span class="line"><span class="comment">//第二种方法</span></span><br><span class="line">$li.get(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>


<h2 id="jquery选择器"><a href="#jquery选择器" class="headerlink" title="jquery选择器"></a>jquery选择器</h2><h3 id="什么是jQuery选择器"><a href="#什么是jQuery选择器" class="headerlink" title="什么是jQuery选择器"></a>什么是jQuery选择器</h3><ul>
<li>jQuery选择器是jQuery为我们提供的一组方法，让我们更加方便的获取到页面中的元素。<br>注意：jQuery选择器返回的是jQuery对象。</li>
<li>jQuery选择器有很多，基本兼容了CSS1到CSS3所有的选择器，并且jQuery还添加了很多扩展性的选择器。<br>【查看jQuery文档】</li>
<li>jQuery选择器虽然很多，但是选择器之间可以相互替代，就是说获取一个元素，你会有很多种方法获取到。<br>所以我们平时真正能用到的只是少数的最常用的选择器。</li>
</ul>
<h3 id="基本选择器"><a href="#基本选择器" class="headerlink" title="基本选择器"></a>基本选择器</h3><table>
<thead>
<tr>
<th>名称</th>
<th>用法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td>ID选择器</td>
<td>$(“#id”);</td>
<td align="left">获取指定ID的元素</td>
</tr>
<tr>
<td>类选择器</td>
<td>$(“.class”);</td>
<td align="left">获取同一类class的元素</td>
</tr>
<tr>
<td>标签选择器</td>
<td>$(“div”);</td>
<td align="left">获取同一类标签的所有元素</td>
</tr>
<tr>
<td>并集选择器</td>
<td>$(“div,p,li”);</td>
<td align="left">使用逗号分隔，只要符合条件之一就可。</td>
</tr>
<tr>
<td>交集选择器</td>
<td>$(“div.redClass”);</td>
<td align="left">获取class为redClass的div元素</td>
</tr>
</tbody></table>
<blockquote>
<p>总结：跟css的选择器用法一模一样。</p>
</blockquote>
<h3 id="层级选择器"><a href="#层级选择器" class="headerlink" title="层级选择器"></a>层级选择器</h3><table>
<thead>
<tr>
<th>名称</th>
<th>用法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td>子代选择器</td>
<td>$(“ul&gt;li”);</td>
<td align="left">使用&gt;号，获取儿子层级的元素，注意，并不会获取孙子层级的元素</td>
</tr>
<tr>
<td>后代选择器</td>
<td>$(“ul li”);</td>
<td align="left">使用空格，代表后代选择器，获取ul下的所有li元素，包括孙子等</td>
</tr>
</tbody></table>
<blockquote>
<p>总结：跟css的选择器用法一模一样。</p>
</blockquote>
<h3 id="过滤选择器"><a href="#过滤选择器" class="headerlink" title="过滤选择器"></a>过滤选择器</h3><table>
<thead>
<tr>
<th>名称</th>
<th>用法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td>:eq（index）</td>
<td>$(“li:eq(2)”).css(“color”, ”red”);</td>
<td align="left">获取到的li元素中，选择索引号为2的元素，索引号index从0开始。</td>
</tr>
<tr>
<td>:odd</td>
<td>$(“li:odd”).css(“color”, ”red”);</td>
<td align="left">获取到的li元素中，选择索引号为奇数的元素</td>
</tr>
<tr>
<td>:even</td>
<td>$(“li:even”).css(“color”, ”red”);</td>
<td align="left">获取到的li元素中，选择索引号为偶数的元素</td>
</tr>
</tbody></table>
<blockquote>
<p>总结：这类选择器都带冒号</p>
</blockquote>
<h3 id="筛选选择器-方法"><a href="#筛选选择器-方法" class="headerlink" title="筛选选择器(方法)"></a>筛选选择器(方法)</h3><table>
<thead>
<tr>
<th>名称</th>
<th>用法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>children(selector)</td>
<td>$(“ul”).children(“li”)</td>
<td>相当于$(“ul&gt;li”)，子类选择器</td>
</tr>
<tr>
<td>find(selector)</td>
<td>$(“ul”).find(“li”);</td>
<td>相当于$(“ul li”),后代选择器</td>
</tr>
<tr>
<td>siblings(selector)</td>
<td>$(“#first”).siblings(“li”);</td>
<td>查找兄弟节点，不包括自己本身。</td>
</tr>
<tr>
<td>parent()</td>
<td>$(“#first”).parent();</td>
<td>查找父亲</td>
</tr>
<tr>
<td>eq(index)</td>
<td>$(“li”).eq(2);</td>
<td>相当于$(“li:eq(2)”),index从0开始</td>
</tr>
<tr>
<td>next()</td>
<td>$(“li”).next()</td>
<td>找下一个兄弟</td>
</tr>
<tr>
<td>prev()</td>
<td>$(“li”).prev()</td>
<td>找上一次兄弟</td>
</tr>
</tbody></table>
<blockquote>
<p>总结：筛选选择器的功能与过滤选择器有点类似，但是用法不一样，筛选选择器主要是方法。</p>
</blockquote>
<p>【案例：下拉菜单】<br>【案例：突出展示】<br>【案例：手风琴】<br>【案例：淘宝精品】</p>
<h2 id="元素设置"><a href="#元素设置" class="headerlink" title="元素设置"></a>元素设置</h2><h3 id="样式设置"><a href="#样式设置" class="headerlink" title="样式设置"></a>样式设置</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*1.设置一个样式*/</span></span><br><span class="line"><span class="comment">//两个参数  设置的样式属性,具体样式</span></span><br><span class="line">$(<span class="string">'li'</span>).css(<span class="string">'color'</span>,<span class="string">'red'</span>);</span><br><span class="line"><span class="comment">//传入对象（设置的样式属性:具体样式）</span></span><br><span class="line">$(<span class="string">'li'</span>).css(&#123;<span class="string">'color'</span>:<span class="string">'red'</span>&#125;);</span><br><span class="line"><span class="comment">/*2.设置多个样式*/</span></span><br><span class="line">$(<span class="string">'li'</span>).css(&#123;</span><br><span class="line">    <span class="string">'color'</span>:<span class="string">'green'</span>,</span><br><span class="line">    <span class="string">'font-size'</span>:<span class="string">'20px'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="类名设置"><a href="#类名设置" class="headerlink" title="类名设置"></a>类名设置</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*1.添加一个类*/</span></span><br><span class="line">$(<span class="string">'li'</span>).addClass(<span class="string">'now'</span>);</span><br><span class="line"><span class="comment">/*2.删除一个类*/</span></span><br><span class="line">$(<span class="string">'li'</span>).removeClass(<span class="string">'now'</span>);</span><br><span class="line"><span class="comment">/*3.切换一个类  有就删除没有就添加*/</span></span><br><span class="line">$(<span class="string">'li'</span>).toggleClass(<span class="string">'now'</span>);</span><br><span class="line"><span class="comment">/*4.匹配一个类  判断是否包含某个类  如果包含返回true否知返回false*/</span></span><br><span class="line">$(<span class="string">'li'</span>).hasClass(<span class="string">'now'</span>);</span><br></pre></td></tr></table></figure>

<p>对应案例：<code>案例-《tab切换》</code></p>
<h3 id="属性设置"><a href="#属性设置" class="headerlink" title="属性设置"></a>属性设置</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*1.获取属性*/</span></span><br><span class="line">$(<span class="string">'li'</span>).attr(<span class="string">'name'</span>);</span><br><span class="line"><span class="comment">/*2.设置属性*/</span></span><br><span class="line">$(<span class="string">'li'</span>).attr(<span class="string">'name'</span>,<span class="string">'tom'</span>);</span><br><span class="line"><span class="comment">/*3.设置多个属性*/</span></span><br><span class="line">$(<span class="string">'li'</span>).attr(&#123;</span><br><span class="line">    <span class="string">'name'</span>:<span class="string">'tom'</span>,</span><br><span class="line">    <span class="string">'age'</span>:<span class="string">'18'</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/*4.删除属性*/</span></span><br><span class="line">$(<span class="string">'li'</span>).removeAttr(<span class="string">'name'</span>);</span><br></pre></td></tr></table></figure>

<p>对应案例：<code>案例-《美女相册》</code></p>
<h3 id="prop方法"><a href="#prop方法" class="headerlink" title="prop方法"></a>prop方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*对于布尔类型的属性，不要attr方法，应该用prop方法 prop用法跟attr方法一样。*/</span></span><br><span class="line">$(<span class="string">"#checkbox"</span>).prop(<span class="string">"checked"</span>);</span><br><span class="line">$(<span class="string">"#checkbox"</span>).prop(<span class="string">"checked"</span>, <span class="literal">true</span>);</span><br><span class="line">$(<span class="string">"#checkbox"</span>).prop(<span class="string">"checked"</span>, <span class="literal">false</span>);</span><br><span class="line">$(<span class="string">"#checkbox"</span>).removeProp(<span class="string">"checked"</span>);</span><br></pre></td></tr></table></figure>

<p>对应案例：<code>案例-《表格全选》</code></p>
<h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><h3 id="基本动画"><a href="#基本动画" class="headerlink" title="基本动画"></a>基本动画</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*注意：动画的本质是改变容器的大小和透明度*/</span></span><br><span class="line"><span class="comment">/*注意：如果不传参数是看不到动画*/</span></span><br><span class="line"><span class="comment">/*注意：可传入特殊的字符  fast normal slow*/</span></span><br><span class="line"><span class="comment">/*注意：可传入数字 单位毫秒*/</span></span><br><span class="line"><span class="comment">/*1.展示动画*/</span></span><br><span class="line">$(<span class="string">'li'</span>).show();</span><br><span class="line"><span class="comment">/*2.隐藏动画*/</span></span><br><span class="line">$(<span class="string">'li'</span>).hide();</span><br><span class="line"><span class="comment">/*3.切换展示和隐藏*/</span></span><br><span class="line">$(<span class="string">'li'</span>).toggle();</span><br></pre></td></tr></table></figure>

<h3 id="滑入滑出"><a href="#滑入滑出" class="headerlink" title="滑入滑出"></a>滑入滑出</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*注意：动画的本质是改变容器的高度*/</span></span><br><span class="line"><span class="comment">/*1.滑入动画*/</span></span><br><span class="line">$(<span class="string">'li'</span>).slideDown();</span><br><span class="line"><span class="comment">/*2.滑出动画*/</span></span><br><span class="line">$(<span class="string">'li'</span>).slideUp();</span><br><span class="line"><span class="comment">/*3.切换滑入滑出*/</span></span><br><span class="line">$(<span class="string">'li'</span>).slideToggle();</span><br></pre></td></tr></table></figure>

<p>对应案例：<code>案例-《下拉菜单》</code></p>
<h3 id="淡入淡出"><a href="#淡入淡出" class="headerlink" title="淡入淡出"></a>淡入淡出</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*注意：动画的本质是改变容器的透明度*/</span></span><br><span class="line"><span class="comment">/*1.淡入动画*/</span></span><br><span class="line">$(<span class="string">'li'</span>).fadeIn();</span><br><span class="line"><span class="comment">/*2.淡出动画*/</span></span><br><span class="line">$(<span class="string">'li'</span>).fadeOut();</span><br><span class="line"><span class="comment">/*3.切换淡入淡出*/</span></span><br><span class="line">$(<span class="string">'li'</span>).fadeToggle();</span><br><span class="line">$(<span class="string">'li'</span>).fadeTo(<span class="string">'speed'</span>,<span class="string">'opacity'</span>);</span><br></pre></td></tr></table></figure>

<p>对应案例：<code>案例-《轮播图》</code></p>
<h3 id="自定义动画"><a href="#自定义动画" class="headerlink" title="自定义动画"></a>自定义动画</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 自定义动画</span></span><br><span class="line"><span class="comment">* 参数1：需要做动画的属性</span></span><br><span class="line"><span class="comment">* 参数2：需要执行动画的总时长</span></span><br><span class="line"><span class="comment">* 参数3：执行动画的时候的速度</span></span><br><span class="line"><span class="comment">* 参数4：执行动画完成之后的回调函数</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">$(<span class="string">'#box1'</span>).animate(&#123;<span class="attr">left</span>:<span class="number">800</span>&#125;,<span class="number">5000</span>);</span><br><span class="line">$(<span class="string">'#box2'</span>).animate(&#123;<span class="attr">left</span>:<span class="number">800</span>&#125;,<span class="number">5000</span>,<span class="string">'linear'</span>);</span><br><span class="line">$(<span class="string">'#box3'</span>).animate(&#123;<span class="attr">left</span>:<span class="number">800</span>&#125;,<span class="number">5000</span>,<span class="string">'swing'</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'动画执行完成'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>对应案例：<code>案例-《手风琴菜单》</code></p>
<h3 id="动画队列"><a href="#动画队列" class="headerlink" title="动画队列"></a>动画队列</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">jQuery中有个动画队列的机制。</span></span><br><span class="line"><span class="comment">当我们对一个对象添加多次动画效果时后添加的动作就会被放入这个动画队列中，  </span></span><br><span class="line"><span class="comment">等前面的动画完成后再开始执行。</span></span><br><span class="line"><span class="comment">可是用户的操作往往都比动画快，  </span></span><br><span class="line"><span class="comment">如果用户对一个对象频繁操作时不处理动画队列就会造成队列堆积，</span></span><br><span class="line"><span class="comment">影响到效果。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="stop使用"><a href="#stop使用" class="headerlink" title="stop使用"></a>stop使用</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*1.停止当前动画  如果动画队列当中还有动画立即执行*/</span></span><br><span class="line"><span class="comment">//$('div').stop();</span></span><br><span class="line"><span class="comment">/*2.和stop()效果一致  说明这是默认设置*/</span></span><br><span class="line"><span class="comment">//$('div').stop(false,false);</span></span><br><span class="line"><span class="comment">/*3.停止当前动画  清除动画队列*/</span></span><br><span class="line"><span class="comment">//$('div').stop(true,false);</span></span><br><span class="line"><span class="comment">/*4.停止当前动画并且到结束位置  清除了动画队列*/</span></span><br><span class="line"><span class="comment">//$('div').stop(true,true);</span></span><br><span class="line"><span class="comment">/*5.停止当前动画并且到结束位置  如果动画队列当中还有动画立即执行*/</span></span><br><span class="line">$(<span class="string">'div'</span>).stop(<span class="literal">false</span>,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>对应案例：<code>案例-《音乐导航》</code><br>对应案例：<code>案例-《工具栏》</code></p>
<h2 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h2><h3 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*创建节点*/</span></span><br><span class="line"><span class="keyword">var</span> $a = $(<span class="string">'&lt;a href="http://www.baidu.com" target="_blank"&gt;百度1&lt;/a&gt;'</span>);</span><br></pre></td></tr></table></figure>

<h3 id="克隆节点"><a href="#克隆节点" class="headerlink" title="克隆节点"></a>克隆节点</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*如果想克隆事件  false  true克隆事件*/</span></span><br><span class="line"><span class="keyword">var</span> $cloneP = $(<span class="string">'p'</span>).clone(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<h3 id="添加-amp-移动节点"><a href="#添加-amp-移动节点" class="headerlink" title="添加&amp;移动节点"></a>添加&amp;移动节点</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*追加自身的最后面  传对象和html格式代码*/</span></span><br><span class="line">$(<span class="string">'#box'</span>).append(<span class="string">'&lt;a href="http://www.baidu.com" target="_blank"&gt;&lt;b&gt;百度3&lt;/b&gt;&lt;/a&gt;'</span>);</span><br><span class="line">$(<span class="string">'#box'</span>).append($(<span class="string">'a'</span>));</span><br><span class="line"><span class="comment">/*追加到目标元素最后面  传目标元素的选择器或者对象*/</span></span><br><span class="line">$(<span class="string">'&lt;a href="http://www.baidu.com" target="_blank"&gt;&lt;b&gt;百度3&lt;/b&gt;&lt;/a&gt;'</span>).appendTo($(<span class="string">'#box'</span>));</span><br><span class="line">$(<span class="string">'a'</span>).appendTo(<span class="string">'#box'</span>);</span><br><span class="line"></span><br><span class="line">prepend();</span><br><span class="line">prependTo();</span><br><span class="line">after();</span><br><span class="line">before();</span><br></pre></td></tr></table></figure>

<h3 id="删除节点-amp-清空节点"><a href="#删除节点-amp-清空节点" class="headerlink" title="删除节点&amp;清空节点"></a>删除节点&amp;清空节点</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*1.清空box里面的元素*/</span></span><br><span class="line"><span class="comment">/* 清理门户 */</span></span><br><span class="line">$(<span class="string">'#box'</span>).empty();</span><br><span class="line"><span class="comment">/*2.删除某个元素*/</span></span><br><span class="line"><span class="comment">/* 自杀 */</span></span><br><span class="line">$(<span class="string">'#box'</span>).remove();</span><br></pre></td></tr></table></figure>

<p>【案例-《弹幕》】</p>
<h2 id="jQuery特殊属性操作"><a href="#jQuery特殊属性操作" class="headerlink" title="jQuery特殊属性操作"></a>jQuery特殊属性操作</h2><h3 id="val方法"><a href="#val方法" class="headerlink" title="val方法"></a>val方法</h3><blockquote>
<p>val方法用于设置和获取表单元素的值，例如input、textarea的值</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置值</span></span><br><span class="line">$(<span class="string">"#name"</span>).val(<span class="string">'张三'</span>);</span><br><span class="line"><span class="comment">//获取值</span></span><br><span class="line">$(<span class="string">"#name"</span>).val();</span><br></pre></td></tr></table></figure>


<h3 id="html方法与text方法"><a href="#html方法与text方法" class="headerlink" title="html方法与text方法"></a>html方法与text方法</h3><blockquote>
<p>html方法相当于innerHTML  text方法相当于innerText</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置内容</span></span><br><span class="line">$(<span class="string">'div'</span>).html(<span class="string">'&lt;span&gt;这是一段内容&lt;/span&gt;'</span>);</span><br><span class="line"><span class="comment">//获取内容</span></span><br><span class="line">$(<span class="string">'div'</span>).html()</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置内容</span></span><br><span class="line">$(<span class="string">'div'</span>).text(<span class="string">'&lt;span&gt;这是一段内容&lt;/span&gt;'</span>);</span><br><span class="line"><span class="comment">//获取内容</span></span><br><span class="line">$(<span class="string">'div'</span>).text()</span><br></pre></td></tr></table></figure>

<p>区别：html方法会识别html标签，text方法会那内容直接当成字符串，并不会识别html标签。</p>
<h3 id="width方法与height方法"><a href="#width方法与height方法" class="headerlink" title="width方法与height方法"></a>width方法与height方法</h3><blockquote>
<p>设置或者获取高度</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//带参数表示设置高度</span></span><br><span class="line">$(<span class="string">'img'</span>).height(<span class="number">200</span>);</span><br><span class="line"><span class="comment">//不带参数获取高度</span></span><br><span class="line">$(<span class="string">'img'</span>).height();</span><br></pre></td></tr></table></figure>

<p>获取网页的可视区宽高</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取可视区宽度</span></span><br><span class="line">$(<span class="built_in">window</span>).width();</span><br><span class="line"><span class="comment">//获取可视区高度</span></span><br><span class="line">$(<span class="built_in">window</span>).height();</span><br></pre></td></tr></table></figure>

<h3 id="scrollTop与scrollLeft"><a href="#scrollTop与scrollLeft" class="headerlink" title="scrollTop与scrollLeft"></a>scrollTop与scrollLeft</h3><blockquote>
<p>设置或者获取垂直滚动条的位置</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取页面被卷曲的高度</span></span><br><span class="line">$(<span class="built_in">window</span>).scrollTop();</span><br><span class="line"><span class="comment">//获取页面被卷曲的宽度</span></span><br><span class="line">$(<span class="built_in">window</span>).scrollLeft();</span><br></pre></td></tr></table></figure>


<h3 id="offset方法与position方法"><a href="#offset方法与position方法" class="headerlink" title="offset方法与position方法"></a>offset方法与position方法</h3><blockquote>
<p>offset方法获取元素距离document的位置，position方法获取的是元素距离有定位的父元素的位置。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取元素距离document的位置,返回值为对象：&#123;left:100, top:100&#125;</span></span><br><span class="line">$(selector).offset();</span><br><span class="line"><span class="comment">//获取相对于其最近的有定位的父元素的位置。</span></span><br><span class="line">$(selector).position();</span><br></pre></td></tr></table></figure>

<h2 id="jQuery事件机制"><a href="#jQuery事件机制" class="headerlink" title="jQuery事件机制"></a>jQuery事件机制</h2><blockquote>
<p>JavaScript中已经学习过了事件，但是jQuery对JavaScript事件进行了封装，增加并扩展了事件处理机制。jQuery不仅提供了更加优雅的事件处理语法，而且极大的增强了事件的处理能力。</p>
</blockquote>
<h3 id="jQuery事件发展历程-了解"><a href="#jQuery事件发展历程-了解" class="headerlink" title="jQuery事件发展历程(了解)"></a>jQuery事件发展历程(了解)</h3><p>简单事件绑定&gt;&gt;bind事件绑定&gt;&gt;delegate事件绑定&gt;&gt;on事件绑定(推荐)</p>
<blockquote>
<p>简单事件注册</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">click(handler)			<span class="comment">//单击事件</span></span><br><span class="line">mouseenter(handler)		<span class="comment">//鼠标进入事件</span></span><br><span class="line">mouseleave(handler)		<span class="comment">//鼠标离开事件</span></span><br></pre></td></tr></table></figure>

<p>缺点：不能同时注册多个事件</p>
<blockquote>
<p>bind方式注册事件</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一个参数：事件类型</span></span><br><span class="line"><span class="comment">//第二个参数：事件处理程序</span></span><br><span class="line">$(<span class="string">"p"</span>).bind(<span class="string">"click mouseenter"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//事件响应方法</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>缺点：不支持动态事件绑定</p>
<blockquote>
<p>delegate注册委托事件</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一个参数：selector，要绑定事件的元素</span></span><br><span class="line"><span class="comment">// 第二个参数：事件类型</span></span><br><span class="line"><span class="comment">// 第三个参数：事件处理函数</span></span><br><span class="line">$(<span class="string">".parentBox"</span>).delegate(<span class="string">"p"</span>, <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//为 .parentBox下面的所有的p标签绑定事件</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>缺点：只能注册委托事件，因此注册时间需要记得方法太多了</p>
<blockquote>
<p>on注册事件</p>
</blockquote>
<h3 id="on注册事件-重点"><a href="#on注册事件-重点" class="headerlink" title="on注册事件(重点)"></a>on注册事件(重点)</h3><blockquote>
<p>jQuery1.7之后，jQuery用on统一了所有事件的处理方法。</p>
<p>最现代的方式，兼容zepto(移动端类似jQuery的一个库)，强烈建议使用。</p>
</blockquote>
<p>on注册简单事件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表示给$(selector)绑定事件，并且由自己触发，不支持动态绑定。</span></span><br><span class="line">$(selector).on( <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;);</span><br></pre></td></tr></table></figure>

<p>on注册委托事件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表示给$(selector)绑定代理事件，当必须是它的内部元素span才能触发这个事件，支持动态绑定</span></span><br><span class="line">$(selector).on( <span class="string">"click"</span>,<span class="string">'span'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;);</span><br></pre></td></tr></table></figure>

<p>on注册事件的语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一个参数：events，绑定事件的名称可以是由空格分隔的多个事件（标准事件或者自定义事件）</span></span><br><span class="line"><span class="comment">// 第二个参数：selector, 执行事件的后代元素（可选），如果没有后代元素，那么事件将有自己执行。</span></span><br><span class="line"><span class="comment">// 第三个参数：data，传递给处理函数的数据，事件触发的时候通过event.data来使用（不常使用）</span></span><br><span class="line"><span class="comment">// 第四个参数：handler，事件处理函数</span></span><br><span class="line">$(selector).on(events,[selector],[data],handler);</span><br></pre></td></tr></table></figure>

<h3 id="事件解绑"><a href="#事件解绑" class="headerlink" title="事件解绑"></a>事件解绑</h3><blockquote>
<p>unbind方式（不用）</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(selector).unbind(); <span class="comment">//解绑所有的事件</span></span><br><span class="line">$(selector).unbind(<span class="string">"click"</span>); <span class="comment">//解绑指定的事件</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>undelegate方式（不用）</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$( selector ).undelegate(); <span class="comment">//解绑所有的delegate事件</span></span><br><span class="line">$( selector).undelegate( <span class="string">'click'</span> ); <span class="comment">//解绑所有的click事件</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>off方式（推荐）</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解绑匹配元素的所有事件</span></span><br><span class="line">$(selector).off();</span><br><span class="line"><span class="comment">// 解绑匹配元素的所有click事件</span></span><br><span class="line">$(selector).off(<span class="string">"click"</span>);</span><br></pre></td></tr></table></figure>

<h3 id="触发事件"><a href="#触发事件" class="headerlink" title="触发事件"></a>触发事件</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(selector).click(); <span class="comment">//触发 click事件</span></span><br><span class="line">$(selector).trigger(<span class="string">"click"</span>);</span><br></pre></td></tr></table></figure>

<h3 id="jQuery事件对象"><a href="#jQuery事件对象" class="headerlink" title="jQuery事件对象"></a>jQuery事件对象</h3><p>jQuery事件对象其实就是js事件对象的一个封装，处理了兼容性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//screenX和screenY	对应屏幕最左上角的值</span></span><br><span class="line"><span class="comment">//clientX和clientY	距离页面左上角的位置（忽视滚动条）</span></span><br><span class="line"><span class="comment">//pageX和pageY	距离页面最顶部的左上角的位置（会计算滚动条的距离）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//event.keyCode	按下的键盘代码</span></span><br><span class="line"><span class="comment">//event.data	存储绑定事件时传递的附加数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//event.stopPropagation()	阻止事件冒泡行为</span></span><br><span class="line"><span class="comment">//event.preventDefault()	阻止浏览器默认行为</span></span><br><span class="line"><span class="comment">//return false:既能阻止事件冒泡，又能阻止浏览器默认行为。</span></span><br></pre></td></tr></table></figure>


<h2 id="jQuery补充知识点"><a href="#jQuery补充知识点" class="headerlink" title="jQuery补充知识点"></a>jQuery补充知识点</h2><h3 id="链式编程"><a href="#链式编程" class="headerlink" title="链式编程"></a>链式编程</h3><blockquote>
<p>通常情况下，只有设置操作才能把链式编程延续下去。因为获取操作的时候，会返回获取到的相应的值，无法返回 jQuery对象。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">end(); <span class="comment">// 筛选选择器会改变jQuery对象的DOM对象，想要回复到上一次的状态，并且返回匹配元素之前的状态。</span></span><br></pre></td></tr></table></figure>

<p>【案例：五角星评分案例.html】</p>
<h3 id="each方法"><a href="#each方法" class="headerlink" title="each方法"></a>each方法</h3><blockquote>
<p>jQuery的隐式迭代会对所有的DOM对象设置相同的值，但是如果我们需要给每一个对象设置不同的值的时候，就需要自己进行迭代了。</p>
</blockquote>
<p>作用：遍历jQuery对象集合，为每个匹配的元素执行一个函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数一表示当前元素在所有匹配元素中的索引号</span></span><br><span class="line"><span class="comment">// 参数二表示当前元素（DOM对象）</span></span><br><span class="line">$(selector).each(<span class="function"><span class="keyword">function</span>(<span class="params">index,element</span>)</span>&#123;&#125;);</span><br></pre></td></tr></table></figure>

<p>【案例：不同的透明度.html】</p>
<h3 id="多库共存"><a href="#多库共存" class="headerlink" title="多库共存"></a>多库共存</h3><blockquote>
<p>jQuery使用$作为标示符，但是如果与其他框架中的$冲突时，jQuery可以释放$符的控制权.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c = $.noConflict();<span class="comment">//释放$的控制权,并且把$的能力给了c</span></span><br></pre></td></tr></table></figure>

<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h3><blockquote>
<p>插件：jquery不可能包含所有的功能，我们可以通过插件扩展jquery的功能。</p>
<p>jQuery有着丰富的插件，使用这些插件能给jQuery提供一些额外的功能。</p>
</blockquote>
<ol>
<li>jquery.color.js</li>
</ol>
<blockquote>
<p>animate不支持颜色的渐变，但是使用了jquery.color.js后，就可以支持颜色的渐变了。</p>
</blockquote>
<p>使用插件的步骤</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 引入jQuery文件</span></span><br><span class="line"><span class="comment">//2. 引入插件（如果有用到css的话，需要引入css）</span></span><br><span class="line"><span class="comment">//3. 使用插件</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>jquery.lazyload.js</li>
</ol>
<p>懒加载插件</p>
<h3 id="jquery-ui-js插件"><a href="#jquery-ui-js插件" class="headerlink" title="jquery.ui.js插件"></a>jquery.ui.js插件</h3><p>jQueryUI专指由jQuery官方维护的UI方向的插件。</p>
<p>官方API：<a href="http://api.jqueryui.com/category/all/">http://api.jqueryui.com/category/all/</a></p>
<p>其他教程：<a href="http://www.runoob.com/jqueryui/jqueryui-tutorial.html">jQueryUI教程</a></p>
<p>基本使用:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.	引入jQueryUI的样式文件</span></span><br><span class="line"><span class="comment">//2.	引入jQuery</span></span><br><span class="line"><span class="comment">//3.	引入jQueryUI的js文件</span></span><br><span class="line"><span class="comment">//4.	使用jQueryUI功能</span></span><br></pre></td></tr></table></figure>

<p>使用jquery.ui.js手风琴菜单</p>
<h2 id="制作jquery插件"><a href="#制作jquery插件" class="headerlink" title="制作jquery插件"></a>制作jquery插件</h2><blockquote>
<p>原理：jquery插件其实说白了就是给jquery对象增加一个新的方法，让jquery对象拥有某一个功能。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过给$.fn添加方法就能够扩展jquery对象</span></span><br><span class="line">$.fn. pluginName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure>



















]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title>npm相关</title>
    <url>/2020/02/18/npm%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h2 id="npm的常用操作"><a href="#npm的常用操作" class="headerlink" title="npm的常用操作"></a>npm的常用操作</h2><table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>npm init -y</td>
<td>初始化项目 会生成package.json和package-lock.json</td>
</tr>
<tr>
<td>npm install</td>
<td>安装  ，简写：npm  i</td>
</tr>
<tr>
<td>npm  i  express  mongoose</td>
<td>一次性安装多个模块</td>
</tr>
<tr>
<td>npm i -S</td>
<td>保存依赖</td>
</tr>
<tr>
<td>npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org">https://registry.npm.taobao.org</a></td>
<td>安装全局cnpm，使用淘宝镜像</td>
</tr>
<tr>
<td>npm -v</td>
<td>查看npm的版本</td>
</tr>
<tr>
<td>npm install npm -g</td>
<td>用npm来安装最新的npm</td>
</tr>
<tr>
<td>npm root</td>
<td><em>查看项目中模块所在的目录</em></td>
</tr>
<tr>
<td>npm root -g</td>
<td>查看全局安装的模块所在目录</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>vue搭建appweb</title>
    <url>/2020/03/13/vue%E6%90%AD%E5%BB%BAappweb/</url>
    <content><![CDATA[<h4 id="webapp-外卖系统（移动端）"><a href="#webapp-外卖系统（移动端）" class="headerlink" title="webapp 外卖系统（移动端）"></a>webapp 外卖系统（移动端）</h4><a id="more"></a>

<p>！（前言：学习Vue项目搭建流程，记录心得（<strong>部分筆記為課件</strong>）。<strong>学习视频</strong> -&gt; <a href="https://www.bilibili.com/video/av49099807">https://www.bilibili.com/video/av49099807</a></p>
<h4 id="1-使用-vue-cli-脚手架-搭建项目"><a href="#1-使用-vue-cli-脚手架-搭建项目" class="headerlink" title="1. 使用 vue-cli(脚手架)搭建项目"></a>1. 使用 vue-cli(脚手架)搭建项目</h4><ol>
<li>Vue-cli 是 vue 官方提供的用于搭建基于 vue+webpack+es6 项目的脚手架工具 </li>
<li>在线文档:<a href="https://github.com/vuejs/vue-cli">https://github.com/vuejs/vue-cli</a> </li>
<li>操作: npm install -g vue-cli vue init webpack gshop cd gshop npm install npm run dev 访问: localhost:8080</li>
</ol>
<h4 id="2-项目结构分析"><a href="#2-项目结构分析" class="headerlink" title="2. 项目结构分析"></a>2. 项目结构分析</h4><p>gshop </p>
<ul>
<li>|– build : webpack 相关的配置文件夹(基本不需要修改) </li>
<li>|– config: webpack 相关的配置文件夹(基本不需要修改) </li>
<li>|– index.js: 指定的后台服务的端口号和静态资源文件夹 </li>
<li>|– node_modules </li>
<li>|– src : 源码文件夹 </li>
<li>|– main.js: 应用入口 js </li>
<li>|– static: 静态资源文件夹 </li>
<li>|– .babelrc: babel 的配置文件 </li>
<li>|– .editorconfig: 通过编辑器的编码/格式进行一定的配置 </li>
<li>|– .eslintignore: eslint 检查忽略的配置 </li>
<li>|– .eslintrc.js: eslint 检查的配置 </li>
<li>|– .gitignore: git 版本管制忽略的配置 </li>
<li>|– index.html: 主页面文件 </li>
<li>|– package.json: 应用包配置文件 </li>
<li>|– README.md: 应用描述说明的 readme 文件</li>
</ul>
<h4 id="3-编码测试与打包发布项目"><a href="#3-编码测试与打包发布项目" class="headerlink" title="3. 编码测试与打包发布项目"></a>3. 编码测试与打包发布项目</h4><ol>
<li>编码测试 npm run dev 访问:<a href="http://localhost:8080">http://localhost:8080</a> 编码, 自动编译打包(HMR), 查看效果 </li>
<li>打包发布 npm run build npm install -g serve serve dist 访问:<a href="http://localhost:5000">http://localhost:5000</a></li>
</ol>
<h4 id="4-項目源碼目錄設計"><a href="#4-項目源碼目錄設計" class="headerlink" title="4. 項目源碼目錄設計"></a>4. 項目源碼目錄設計</h4><ul>
<li><p>src</p>
<ul>
<li><p>api    与后台交互模块文件夹</p>
</li>
<li><p>common（asstes） 通用资源文件夹，如fonts/img/stylus</p>
<p>(stylus: css预编译器，Sass/Less</p>
<p><em>npminstallstylusstylus-loader–save-dev</em>）</p>
</li>
<li><p>components    非路由组件文件夹</p>
</li>
<li><p>filters    自定义过滤器模块文件夹</p>
</li>
<li><p>mock     模拟数据接口文件夹</p>
</li>
<li><p>pages    路由组件文件夹</p>
</li>
<li><p>router    路由器文件夹-&gt;index.js/router.js 暴露router给入口文件main.js</p>
</li>
<li><p>store    vuex相关模块文件夹</p>
</li>
<li><p>App.vue    应用组件</p>
</li>
<li><p>main.js    入口JS</p>
</li>
</ul>
</li>
</ul>
<h3 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h3><h4 id="props的详解："><a href="#props的详解：" class="headerlink" title="props的详解："></a><strong>props</strong>的详解：</h4><p>组件示例的作用域是孤立的，意味着不能（也不应该）在子组件的模板内直接引用父组件的数据。父组件的数据要通过prop才能下发到子组件中。</p>
<p>props是子组件访问父组件数据的唯一接口</p>
<ul>
<li>一个组件可以直接在模板里面渲染data里面的数据（双大括号）。</li>
</ul>
<ul>
<li>子组件不能直接在模板里面渲染父元素的数据。</li>
</ul>
<ul>
<li>如果子组件想要引用父元素的数据，那么就在prop里面声明一个变量（比如a），这个变量就可以引用父元素的数据。然后在模板里渲染这个变量（前面的a），这时候渲染出来的就是父元素里面的数据。 </li>
</ul>
<h4 id="slot的详解："><a href="#slot的详解：" class="headerlink" title="slot的详解："></a><strong>slot</strong>的详解：</h4><p>给<slot>元素指定一个name后可以分发多个内容</slot></p>
<p>一个简单的小例子：</p>
<ul>
<li>1.父组件传递了todos数组给子组件</li>
<li>2.子组件通过props接受了数组数据，这里应该没有任何问题</li>
<li>3.子组件拿到数组后v-for渲染列表，并且通过 <slot :todo="todo">的方式，把数组内的每一个todo对象，传递给父组件</slot></li>
<li>4.父组件通过slot-scope=”slotProps”的方式，接受todo对象，之后就可以通过slotProps.todo.xxx的方式来使用了</li>
</ul>
<p>所以数据的流动经历了</p>
<ul>
<li>父组件传递todos数组给子组件</li>
<li>子组件遍历todos数组，把里面的todo对象传递给父组件</li>
</ul>
<h4 id="Swiper"><a href="#Swiper" class="headerlink" title="Swiper"></a><strong>Swiper</strong></h4><p>左右滑动插件 npm i swiper -D 先下载 ——<em>可以去官网查看html结构，这样写会有好的css样式</em></p>
<p>import Swiper from ‘swiper’</p>
<h4 id="阿里巴巴iconfont"><a href="#阿里巴巴iconfont" class="headerlink" title="阿里巴巴iconfont"></a><strong>阿里巴巴iconfont</strong></h4><p>inconfont矢量标记图标。登录账号，选择图标添加购物车，生成网上链接，可以直接使用。<em>使用方式</em> 去官网看。</p>
<h4 id="Svg图片"><a href="#Svg图片" class="headerlink" title="Svg图片"></a>Svg图片</h4><p>可以做验证码</p>
<h4 id="router-back"><a href="#router-back" class="headerlink" title="$router.back()"></a>$router.back()</h4><p>&lt;a href=”javascript:” class=”go_back” @click=”$router.back()”&gt;</p>
<p>返回到之前的路由</p>
<p>$route 代表当前路由</p>
<h4 id="postman"><a href="#postman" class="headerlink" title="postman"></a>postman</h4><p>创建集合，以便归类请求</p>
<h4 id="封装ajax请求"><a href="#封装ajax请求" class="headerlink" title="封装ajax请求"></a>封装ajax请求</h4><h4 id="跨域问题的解决"><a href="#跨域问题的解决" class="headerlink" title="跨域问题的解决"></a>跨域问题的解决</h4><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><h4 id="01"><a href="#01" class="headerlink" title="01"></a>01</h4><ol>
<li><p>项目开发准备</p>
<ul>
<li>项目描述</li>
<li>技术选型</li>
<li>API接口（接口文档 -&gt; postman 测接口）</li>
<li>从此项目学到什么</li>
</ul>
</li>
<li><p>开启项目开发</p>
<ul>
<li>使用脚手架创建项目</li>
<li>安装依赖</li>
<li>开发环境运行</li>
<li>生产环境打包与发布</li>
</ul>
</li>
<li><p>搭建项目整体界面结构</p>
<ul>
<li><p>stylus的理解和使用（结构化，变量，函数/minxin（混合</p>
</li>
<li><p>vue-router的理解和使用</p>
<ul>
<li>router-view/router-link/keep-alive</li>
<li>$router: 路由对象，包含一些操作路由的功能函数，来实现编程式导航（跳转路由）</li>
<li>$route: 当前路由对象，一些当前路由信息数据的容器，path/meta/query/params</li>
</ul>
</li>
<li><p><strong>项目路由拆分</strong></p>
<p>一般组件和导航路由组件</p>
</li>
<li><p>抽取组件</p>
</li>
<li><p>登录路由组件</p>
</li>
<li><p>后台项目</p>
</li>
<li><p>前后台交互</p>
<p>ajax请求库：axios</p>
<p>ajax请求函数封装：axios + promise</p>
<p>接口请求函数封装，每个后台接口</p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>人工智能简介</title>
    <url>/2021/10/13/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h4 id="人工智能发展必备三要素"><a href="#人工智能发展必备三要素" class="headerlink" title="人工智能发展必备三要素"></a>人工智能发展必备三要素</h4><a id="more"></a>

<ul>
<li>数据</li>
<li>算法</li>
<li>计算力<ul>
<li>CPU、GPU对比：<ul>
<li>CPU主要适合I\O密集型的任务</li>
<li>GPU主要适合计算密集型任务</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="人工智能和机器学习，深度学习的关系："><a href="#人工智能和机器学习，深度学习的关系：" class="headerlink" title="人工智能和机器学习，深度学习的关系："></a>人工智能和机器学习，深度学习的关系：</h4><ul>
<li>机器学习是人工智能的一个实现途径/分支</li>
<li>深度学习是机器学习的一个方法发展而来</li>
</ul>
<h4 id="人工智能主要分支："><a href="#人工智能主要分支：" class="headerlink" title="人工智能主要分支："></a>人工智能主要分支：</h4><ul>
<li>计算机视觉（CV）是指机器感知环境的能力；物体检测和人脸识别是比较成功的研究领域</li>
<li>语音识别；说出来的语言并将其转换成对应文本。语音识别领域任然面临着<strong>声纹识别</strong>和【<strong>鸡尾酒效应</strong>】</li>
<li>文本挖掘/分类；用于理解、组织、分类结构化或非结构化文本文档。</li>
<li>机器翻译</li>
<li>机器人</li>
</ul>
<h4 id="机器学习工作流程："><a href="#机器学习工作流程：" class="headerlink" title="机器学习工作流程："></a>机器学习工作流程：</h4><ol>
<li>获取数据</li>
<li>数据基本处理</li>
<li>特征工程</li>
<li>机器学习（模型训练）</li>
<li>模型评估<ul>
<li>结果达到要求，上线服务</li>
<li>没有达标，重新执行上面步骤</li>
</ul>
</li>
</ol>
<h4 id="数据简介："><a href="#数据简介：" class="headerlink" title="数据简介："></a>数据简介：</h4><p>在数据集D中一般：</p>
<ul>
<li>一行数据称为一个样本</li>
<li>一列数据称为一个特征（属性）</li>
<li>有些数据有目标值（标签值），有些数据没有目标值</li>
</ul>
<h4 id="特征工程："><a href="#特征工程：" class="headerlink" title="特征工程："></a>特征工程：</h4><ul>
<li><p>特征提取</p>
<p>将任意数据（文本或图像）转换为可用于机器学习的数学特征</p>
</li>
<li><p>特征预处理</p>
<p>通过一些转换函数将数据 转换成更加适合算法模型 对的特征数据 过程</p>
</li>
<li><p>特征降维</p>
</li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack相关</title>
    <url>/2020/03/12/webpack%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h4 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h4><a id="more"></a>

<p>本质上，<em>webpack</em> 是一个现代 JavaScript 应用程序的<em>静态模块打包器(module bundler)</em>。当 webpack 处理应用程序时，它会递归地构建一个<em>依赖关系图(dependency graph)</em>，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 <em>bundle</em>。</p>
<p>1.项目构建工具，基于node.js开发出来的前端工具</p>
<p>2.webpack能够处理JS文件的相互依赖关系</p>
<p>3.webpack能处理JS的兼容问题，把高级的、浏览器不识别的语法转换为能识别的</p>
<p>*<em>4. *</em>webpack 默认只能打包处理 <code>.js</code> 后缀名类型的文件。像.png .vue无法处理，所以需要配置第三方的loader；</p>
<p>(<strong>vue-cli 会自动配置webpack</strong>）</p>
<h4 id="在项目中安装和配置webpack"><a href="#在项目中安装和配置webpack" class="headerlink" title="在项目中安装和配置webpack"></a>在项目中安装和配置webpack</h4><p>​    1.1. 运行 <code>npm install webpack webpack-cli -D</code> 命令，安装webpack相关的包</p>
<p>​    1.2. 在项目根目录中，创建名为<em>webpack.config.js</em>的webpack配置文件</p>
<p>​    1.3. 在webpack的配置文件中，初始化如下基本配置：</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode: <span class="string">'development'</span> <span class="comment">// mode 用来指定构建模式 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>​    1.4.在package.json配置文件中scripts节点下，新增dev脚本如下：</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line"><span class="string">"dev"</span>: <span class="string">"webpack"</span> <span class="comment">// script 节点下的脚本，可以通过npm run 来执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>​    1.5. 在终端运行 <code>npm run dev</code> 命令，启动webpack进行项目打包 （将index.js 打包为 main.js）</p>
<p>​    1.6. 在index.html中可以引用输出文件main.js</p>
<h4 id="配置打包的入口与出口"><a href="#配置打包的入口与出口" class="headerlink" title="配置打包的入口与出口"></a>配置打包的入口与出口</h4><p><strong>webpack</strong>的<strong>4.x</strong>版本中默认约定：</p>
<ul>
<li>打包的入口文件为 <em>src -&gt; index.js</em>    <em>在这里import js、css资源</em></li>
<li>打包的输出文件为 <em>dist -&gt; main.js</em></li>
</ul>
<p>如果要修改，就在webpack.config.js配置文件中添加一些节点</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(path)</span><br><span class="line"></span><br><span class="line">entry: path.join(__dirname, <span class="string">'./src/index.js'</span>),</span><br><span class="line">output: &#123;</span><br><span class="line">    path: path.join(__dirname, <span class="string">'./dist'</span>),<span class="comment">//输出文件路径</span></span><br><span class="line">    filename: <span class="string">'bundle.js'</span> <span class="comment">// 输出文件的名称</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="配置webpack的自动打包功能"><a href="#配置webpack的自动打包功能" class="headerlink" title="配置webpack的自动打包功能"></a>配置webpack的自动打包功能</h4><ol>
<li><p>运行 <code>npm install webpack-dev-server -D</code> 命令，安装支持项目<strong>自动打包</strong>的工具</p>
</li>
<li><p>修改<em>package.json -&gt; scripts</em>中的 dev 命令如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">	<span class="string">"dev"</span>: <span class="string">"webpack-dev-server"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将<em>src -&gt; index.html</em> 中，script脚本引用路径，改为“/bundle.js”</p>
</li>
<li><p>运行 <code>npm run dev</code> 命令，重新进行打包</p>
<p>（这里会自动在根目录中生成一个bundle.js，在内存中生成的，物理目录中看不到）</p>
</li>
<li><p>在浏览器中访问 8080,地址，查看自动打包效果</p>
</li>
</ol>
<p>注意：</p>
<ul>
<li>webpack-dev-server 会启动一个实时打包的http服务器</li>
<li>webpack-dev-server 打包生成的输出文件，默认放到了项目根目录中，而且是虚拟的、看不见的</li>
</ul>
<h4 id="html-webpack-plugin生成的预览页面"><a href="#html-webpack-plugin生成的预览页面" class="headerlink" title="html-webpack-plugin生成的预览页面"></a>html-webpack-plugin生成的预览页面</h4><p>（写在前面，</p>
<ol>
<li><p>运行 <code>npm install html-webpack-plugin -D</code> 命令，安装生成预览页面的插件</p>
</li>
<li><p>修改 webpack.config.js文件头部区域，添加如下配置信息：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入生成预览页面的插件，得到一个构造函数</span></span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"><span class="comment">// 创建插件的实例对象 new出来</span></span><br><span class="line"><span class="keyword">const</span> htmlPlugin = <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">    template: <span class="string">'./src/index.html'</span>,</span><br><span class="line">    filename: <span class="string">'index.html'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改webpack.config.js文件中向外暴露的配置对象，新增如下配置节点：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">plugins:[ htmlPlugin ] <span class="comment">// plugins數組是webpack打包期间会用到的一些插件列表</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="配置自动打包相关的参数"><a href="#配置自动打包相关的参数" class="headerlink" title="配置自动打包相关的参数"></a>配置自动打包相关的参数</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package.json中配置</span></span><br><span class="line"><span class="comment">// --open 打包完成后自动打开浏览器页面</span></span><br><span class="line"><span class="comment">// --host 配置IP地址</span></span><br><span class="line"><span class="comment">// --port 配置端口</span></span><br><span class="line"><span class="string">"scripts"</span> : [</span><br><span class="line">	<span class="string">"dev"</span>: <span class="string">"webpack-dev-server --open --host 127.0.0.1 --port 8888"</span></span><br><span class="line">],</span><br></pre></td></tr></table></figure>

<h4 id="loader打包非js模块"><a href="#loader打包非js模块" class="headerlink" title="loader打包非js模块"></a>loader打包非js模块</h4><p>​    <em>loader</em> 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效<a href="https://www.webpackjs.com/concepts/modules">模块</a>，然后你就可以利用 webpack 的打包能力，对它们进行处理。</p>
<p>本质上，webpack loader 将所有类型的文件，转换为应用程序的依赖图（和最终的 bundle）可以直接引用的模块。</p>
<p><em>注意，loader 能够</em> <code>import</code> <em>导入任何类型的模块（例如</em> <code>.css</code> <em>文件），这是 webpack 特有的功能，其他打包程序或任务执行器的可能并不支持。我们认为这种语言扩展是有很必要的，因为这可以使开发人员创建出更准确的依赖关系图。</em></p>
<ul>
<li><p>less-loader</p>
</li>
<li><p>sass-loader</p>
</li>
<li><p>url-loader</p>
<p><img src="/2020/03/12/webpack%E7%9B%B8%E5%85%B3/F:%5Cproject%5CHexo%5Csource_posts%5Cwebpack%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%5C22d.jpg" alt></p>
</li>
</ul>
<h4 id="打包处理css文件"><a href="#打包处理css文件" class="headerlink" title="打包处理css文件"></a>打包处理css文件</h4><ol>
<li><p>运行 <code>npm i style-loader css-loader -D</code> 命令，安装处理css文件的loader</p>
</li>
<li><p>在webpack.config.js的module -&gt; rules 数组中，添加loader：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 所有第三方文件模块的匹配规则</span></span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">	rules: [</span><br><span class="line">		&#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">use</span>: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>]&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，test 表示匹配的文件类型，use表示对应要调用的loader</p>
<p>注意：</p>
<ul>
<li>use 数组中指定的loader 顺序是固定的</li>
<li>多个loader的调用顺序是：从后往前调用</li>
</ul>
</li>
</ol>
<h4 id="打包处理less文件"><a href="#打包处理less文件" class="headerlink" title="打包处理less文件"></a>打包处理less文件</h4><ol>
<li><p>运行 <code>npm i less-loader less -D</code> 命令</p>
</li>
<li><p>在webpack.config.js 的module -&gt; rules 数组中，添加loader:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 所有第三方文件模块的匹配规则</span></span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">	rules: [</span><br><span class="line">		&#123; <span class="attr">test</span>: <span class="regexp">/\.less$/</span>, <span class="attr">use</span>: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'less-loader'</span>]&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="打包处理sass文件"><a href="#打包处理sass文件" class="headerlink" title="打包处理sass文件"></a>打包处理sass文件</h4><ol>
<li><p>运行 <code>npm i sass-loader node-sass -D</code> 命令</p>
</li>
<li><p>在webpack.config.js 的module -&gt; rules 数组中，添加loader:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 所有第三方文件模块的匹配规则</span></span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">	rules: [</span><br><span class="line">		&#123; <span class="attr">test</span>: <span class="regexp">/\.scss$/</span>, <span class="attr">use</span>: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'sass-loader'</span>]&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="配置postCSS-自动添加css的兼容前缀"><a href="#配置postCSS-自动添加css的兼容前缀" class="headerlink" title="配置postCSS 自动添加css的兼容前缀"></a>配置postCSS 自动添加css的兼容前缀</h4><ol>
<li><p>运行 <code>npm i postcss-loader autoprofixer -D</code> 命令</p>
</li>
<li><p>在项目根目录中创建 postcss 的配置文件 postcss.config.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> autoprofixer = <span class="built_in">require</span>(<span class="string">'autoprofixer'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins:[autoprofixer]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在webpack.config.js的module -&gt; rules 数组中，修改css的loader：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">	rules: [</span><br><span class="line">		&#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">use</span>: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'postcss-loader'</span>]&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="打包样式表中的图片和文字文件"><a href="#打包样式表中的图片和文字文件" class="headerlink" title="打包样式表中的图片和文字文件"></a>打包样式表中的图片和文字文件</h4><ol>
<li><p>运行 <code>npm i url-loader file-loader -D</code> 命令</p>
</li>
<li><p>在webpack.config.js 的module -&gt; rules数组中，添加loader：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">	rules: [</span><br><span class="line">		&#123; <span class="attr">test</span>: <span class="regexp">/\.jpg|png|gif|bmp|ttf|svg|woff|woff2$/</span>, <span class="attr">use</span>:<span class="string">'url-loader?limit=16940'</span>&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中？之后的是loader的<strong>参数项</strong></p>
<p>limit 用来指定图片的大小，单位是字节（byte），只有小于limit大小的图片，才会被转为 base64 图片</p>
</li>
</ol>
<h4 id="打包处理js文件中的高级语法"><a href="#打包处理js文件中的高级语法" class="headerlink" title="打包处理js文件中的高级语法"></a>打包处理js文件中的高级语法</h4><ol>
<li><p>安装babel转换器相关的包：<code>npm i babel-loader @babel/core  @babel/runtime -D</code></p>
</li>
<li><p>安装babel语法插件相关的包： <code>npm i @babel/preset-env @babel/plugin-transform-runtime @babel/plugin-proposal-class-properties -D</code></p>
</li>
<li><p>在项目根目录中，创建babel配置文件，babel.config.js，并初始化基本配置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    presets: [<span class="string">'@babel/preset-env'</span>]</span><br><span class="line">    plugins: [<span class="string">'@babel/preset-env'</span>, <span class="string">'@babel/plugin-transform-runtime'</span>, <span class="string">'@babel/plugin-proposal-class-properties'</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li><p>在webpack.config.js的module -&gt; rules数组中，已添加loader规则：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">test</span>: <span class="regexp">/\.js$/</span>, <span class="attr">use</span>:<span class="string">'babel-loader'</span>, <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>&#125;</span><br></pre></td></tr></table></figure>

<p>其中，exclude为排除项，表示babel-loader不需要处理node_modules中的js文件</p>
</li>
</ol>
<h4 id="打包vue组件"><a href="#打包vue组件" class="headerlink" title="打包vue组件"></a>打包vue组件</h4><p>.vue文件，需要安装相关的loader </p>
<p><code>npm i vue-loader vue-temlate-compiler -D</code></p>
<p>在webpack.config.js配置文件中，新增loader配置项</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">test</span>: <span class="regexp">/\.vue$/</span>, <span class="attr">use</span>: <span class="string">'vue-loader'</span> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结梳理"><a href="#总结梳理" class="headerlink" title="总结梳理"></a>总结梳理</h4><p>webpack中如何使用vue</p>
<p>1.安装vue的包：<code>npm i vue -S</code></p>
<p>2.由于在webpack中，推荐使用.vue这个组件模板文件定义组件，所以，需要安装 能解析这种文件的loader  <code>cnpm i vue-template-complier -D</code></p>
<p>3.在输出文件main.js中，导入vue模块 <code>import Vue from ‘vue’</code></p>
<p>4.定义一个.vue结尾的组件，其中，组件有三部分组成：template script style </p>
<p>5.使用import导入这个组件</p>
<p>6.创建vm的实例     <code>var vm = new Vue（ {el: &#39;#app&#39;, render: c=&gt; c(login) })</code></p>
<p>7.在页面中创建一个id为app的div元素，作为我们vm实例要控制的区域</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>yfd实习记录 1</title>
    <url>/2021/05/24/yfd%E5%AE%9E%E4%B9%A0%E8%AE%B0%E5%BD%95-1/</url>
    <content><![CDATA[<p>ok！这部分算是记录的序章，入职前的一些事情记录</p>
<a id="more"></a>

<h3 id="pt1-投简历–面试"><a href="#pt1-投简历–面试" class="headerlink" title="pt1 投简历–面试"></a>pt1 投简历–面试</h3><p>5月11中午吃饭的时候，看到猿辅导的招聘暑期兼职，工资可观，回去准备准备了简历就投了。当天下午那边发回了邮件通知周四面试。收到面试通知，加了hr微信，这才去百度搜了搜猿辅导公司的位置，去b站搜了搜猿辅导面试辅导老师的一些情况，也大致了解了猿辅导面试环节中所问的问题还是比较格式化的。“自我介绍”，“对辅导老师的看法”，“面对一些问题时你会怎么做”，hr小姐姐说明了加班的必要性，关于续保的占比。我对加班没有异议，公司说13-21点，其实应该是12-22点，这个时间我也能接受。（据说续报期是9-24点）</p>
<h3 id="pt2-收到offer–租房"><a href="#pt2-收到offer–租房" class="headerlink" title="pt2 收到offer–租房"></a>pt2 收到offer–租房</h3><p>周五的时候就收到暑期兼职offer，入职时间是6月3号，入职的时候签订实习的劳务合同（要扣20%的税，到手4200左右），没有岗前培训，有岗后9天的培训。重庆猿辅导公司在朝天门来福士办公区A座，我在大学城这边，因为要租房子，16号的时候就和朋友一起去那边逛了逛（办公区没有权限是进不去的-..-）。19号的时候，和其他同事合租到了房子，租的3个月短租，押一付一。房子就在轻轨站出口，离来福士也10分钟左右的步行，已经很近了。</p>
<h3 id="pt3-packaging-stuff"><a href="#pt3-packaging-stuff" class="headerlink" title="pt3 packaging stuff"></a>pt3 packaging stuff</h3><p>这边毕业设计和论文的事情算是基本结束了。我打包了一些冬季的衣服回家，又在网上买了一些办公所需的小物品和生活小物品。过几天要去那边线下签一个东西，顺便拿到房子钥匙，还有桌子板凳配齐了没有，顺便带一些衣服过去放着，学校宿舍这边就等17号回来再陆陆续续搬走。</p>
<h3 id="pt4-上知乎了解辅导老师性质"><a href="#pt4-上知乎了解辅导老师性质" class="headerlink" title="pt4 上知乎了解辅导老师性质"></a>pt4 上知乎了解辅导老师性质</h3><p>说回之前面试猿辅导辅导老师的事情，我当时投简历的时候，其实已经有大概的感觉自己能过，只要自己认真准备面试问题，勇敢的去回答就好了。但真正收到offer，我才想到去真正了解辅导老师的性质，hr说70%的续报，其实很明显就是职业定位是销售性质占很大一部分。知乎上对于各大机构的辅导老师的吐槽我都大致看了看，优势就是薪资高，劣势就是工作时间长，压力很大，我暗自觉得我还是能撑住3个月的时间的。</p>
<h3 id="pt5-抽卡"><a href="#pt5-抽卡" class="headerlink" title="pt5 抽卡"></a>pt5 抽卡</h3><p>去b站的塔罗占卜 事件结果那个抽过两次塔罗牌。关于前期能否进入状态：海神的女儿；关于三个月工作的感受：雪中的独角兽。两张牌都是好牌。</p>
]]></content>
      <categories>
        <category>实习</category>
      </categories>
      <tags>
        <tag>实习</tag>
      </tags>
  </entry>
  <entry>
    <title>前端UI框架小总结</title>
    <url>/2020/04/01/%E5%89%8D%E7%AB%AFUI%E6%A1%86%E6%9E%B6%E5%B0%8F%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>收集前端UI框架 包括移动端 PC端的官网</p>
<a id="more"></a>

<hr>
<blockquote>
<h4 id="移动端UI框架"><a href="#移动端UI框架" class="headerlink" title="移动端UI框架"></a>移动端UI框架</h4></blockquote>
<h5 id="Mint-UI（饿了么团队）"><a href="#Mint-UI（饿了么团队）" class="headerlink" title="Mint UI（饿了么团队）"></a><strong>Mint UI（饿了么团队）</strong></h5><p>中文官网：<a href="http://mint-ui.github.io/#!/zh-cn">http://mint-ui.github.io/#!/zh-cn</a></p>
<p>描述：基于vue的移动端UI框架<br>基于vue</p>
<p>GitHub地址：<a href="https://github.com/ElemeFE/mint-ui/">https://github.com/ElemeFE/mint-ui/</a></p>
<h5 id="Weui（微信官方设计团队）"><a href="#Weui（微信官方设计团队）" class="headerlink" title="Weui（微信官方设计团队）"></a>Weui（微信官方设计团队）</h5><p>描述：WeUI 为微信 Web 服务量身设计,是一套同微信原生视觉体验一致的基础样式库，由微信官方设计团队为微信 Web 开发量身设计，可以令用户的使用感知更加统一。</p>
<p>GitHub地址：<a href="https://github.com/weui/weui">https://github.com/weui/weui</a></p>
<h5 id="Pure"><a href="#Pure" class="headerlink" title="Pure"></a>Pure</h5><p>中文官网：<a href="https://www.purecss.cn/">https://www.purecss.cn/</a><br>描述：纯CSS<br>美国雅虎公司出品的一组轻量级、响应式纯css模块，适用于任何Web项目。<br>GitHub：<a href="https://github.com/yahoo/pure/">https://github.com/yahoo/pure/</a></p>
<blockquote>
<h4 id="PC-端-UI框架"><a href="#PC-端-UI框架" class="headerlink" title="PC 端 UI框架"></a><strong>PC 端 UI框架</strong></h4></blockquote>
<h5 id="Element-UI（饿了么团队）"><a href="#Element-UI（饿了么团队）" class="headerlink" title="Element UI（饿了么团队）"></a>Element UI（饿了么团队）</h5><p>官方地址：<a href="http://element-cn.eleme.io/#/zh-CN">http://element-cn.eleme.io/#/zh-CN</a><br>描述：基于 Vue 2.0 的桌面端组件库<br>GitHub：<a href="https://github.com/ElemeFE/element">https://github.com/ElemeFE/element</a></p>
<h5 id="iView"><a href="#iView" class="headerlink" title="iView"></a>iView</h5><p>官网地址：<a href="https://www.iviewui.com/">https://www.iviewui.com/</a><br>描述：一套基于 Vue.js 的高质量 UI 组件库。iView 是一套基于 Vue.js 的开源 UI 组件库，主要服务于 PC 界面的中后台产品。<br>GitHub地址：<a href="https://github.com/iview/iview">https://github.com/iview/iview</a></p>
<h5 id="layui"><a href="#layui" class="headerlink" title="layui"></a>layui</h5><p>官方地址：<a href="http://www.layui.com/">http://www.layui.com/</a></p>
<p>描述：更多是为服务端程序员量身定做，你无需涉足各种前端工具的复杂配置，只需面对浏览器本身，让一切你所需要的元素与交互，从这里信手拈来。</p>
<p>layui 兼容人类正在使用的全部浏览器（IE6/7除外），可作为 PC 端后台系统与前台界面的速成开发方案。</p>
<p>GitHub：<a href="https://github.com/sentsin/layui/">https://github.com/sentsin/layui/</a></p>
<h5 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h5><p>中文官网：<a href="http://www.bootcss.com/">http://www.bootcss.com/</a><br>描述：简洁、直观、强悍的前端开发框架，让web开发更迅速、简单。</p>
<p>GitHub地址：<a href="https://github.com/twbs/bootstrap">https://github.com/twbs/bootstrap</a></p>
<h5 id="jQuery-UI"><a href="#jQuery-UI" class="headerlink" title="jQuery UI"></a>jQuery UI</h5><p>官方网址：<a href="http://jqueryui.com/">http://jqueryui.com/</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习算法分类</title>
    <url>/2021/10/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<h3 id="机器学习算法分类"><a href="#机器学习算法分类" class="headerlink" title="机器学习算法分类"></a>机器学习算法分类</h3><a id="more"></a>

<p>根据 <strong>数据集</strong> 组成不同，可以把机器学习算法分为：</p>
<ul>
<li>监督学习（分类、回归）</li>
<li>无监督学习（聚类）</li>
<li>半监督学习</li>
<li>强化学习</li>
</ul>
<h4 id="1-监督学习"><a href="#1-监督学习" class="headerlink" title="1 监督学习"></a>1 监督学习</h4><p>定义：输入数据是由输入<strong>特征值</strong>feature 和 <strong>目标值</strong>所组成</p>
<ul>
<li><p>函数的输出(目标值)可以是一个连续的值（称为回归）</p>
</li>
<li><p>函数的输出(目标值)是有限个离散值（称为分类）</p>
</li>
</ul>
<h4 id="2-无监督学习"><a href="#2-无监督学习" class="headerlink" title="2 无监督学习"></a>2 无监督学习</h4><p>定义：输入数据是由输入特征值组成，<strong>没有目标值</strong></p>
<ul>
<li>输入数据没有被标记，也没有确定的结果。样本数据类别未知；</li>
<li>需要根据样本间的相似性对样本集进行类别划分</li>
</ul>
<h4 id="3-半监督学习"><a href="#3-半监督学习" class="headerlink" title="3 半监督学习"></a>3 半监督学习</h4><h4 id="4-强化学习"><a href="#4-强化学习" class="headerlink" title="4 强化学习"></a>4 强化学习</h4><p>定义：实质是make decisions 问题，即自动进行决策，并且可以做连续决策。</p>
<p>主要包含五个元素：agent, action, reward, environment, observation；</p>
<p>强化学习的目标就是<strong>获得最多的累计奖励</strong>。</p>
<table>
<thead>
<tr>
<th></th>
<th>监督学习</th>
<th><strong>强化学习</strong></th>
</tr>
</thead>
<tbody><tr>
<td>反馈映射</td>
<td>输出的是之间的关系，可以告诉算法什么样的输入对应着什么样的输出。</td>
<td>输出的是给机器的反馈 reward function，即用来判断这个行为是好是坏。</td>
</tr>
<tr>
<td>反馈时间</td>
<td>做了比较坏的选择会<strong>立刻反馈给算法</strong>。</td>
<td>结果<strong>反馈有延时</strong>，有时候可能需要走了很多步以后才知道以前的某一步的选择是好还是坏。</td>
</tr>
<tr>
<td>输入特征</td>
<td>输入是<strong>独立同分布</strong>的。（掷骰子）</td>
<td>面对的输入总是在变化，每当算法做出一个行为，它影响下一次决策的输入。</td>
</tr>
</tbody></table>
<h4 id="5-小结"><a href="#5-小结" class="headerlink" title="5 小结"></a>5 小结</h4><table>
<thead>
<tr>
<th align="left"></th>
<th align="center"><strong>In</strong></th>
<th align="center"><strong>Out</strong></th>
<th align="center"><strong>目的</strong></th>
<th align="center"><strong>案例</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>监督学习</strong> <strong>(supervised learning)</strong></td>
<td align="center">有标签</td>
<td align="center">有反馈</td>
<td align="center">预测结果</td>
<td align="center">猫狗分类 房价预测</td>
</tr>
<tr>
<td align="left"><strong>无监督学习</strong> <strong>(unsupervised learning)</strong></td>
<td align="center">无标签</td>
<td align="center">无反馈</td>
<td align="center">发现潜在结构</td>
<td align="center">“物以类聚，人以群分”</td>
</tr>
<tr>
<td align="left"><strong>半监督学习</strong> <strong>(Semi-Supervised Learning)</strong></td>
<td align="center">部分有标签，部分无标签</td>
<td align="center">有反馈</td>
<td align="center">降低数据标记的难度</td>
<td align="center"></td>
</tr>
<tr>
<td align="left"><strong>强化学习</strong> <strong>(reinforcement learning)</strong></td>
<td align="center">决策流程及激励系统</td>
<td align="center">一系列行动</td>
<td align="center">长期利益最大化</td>
<td align="center">学下棋</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>前端需要注意的SEO</title>
    <url>/2020/03/29/%E5%89%8D%E7%AB%AF%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84SEO/</url>
    <content><![CDATA[<p>SEO (搜索引擎优化)</p>
<a id="more"></a>

<ul>
<li>合理的<code>title</code>、<code>description</code>、<code>keywords</code>：搜索对着三项的权重逐个减小，<code>title</code>值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面<code>title</code>要有所不同；<code>description</code>把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面<code>description</code>有所不同；<code>keywords</code>列举出重要关键词即可</li>
<li>语义化的<code>HTML</code>代码，符合W3C规范：语义化代码让搜索引擎容易理解网页</li>
<li>重要内容<code>HTML</code>代码放在最前：搜索引擎抓取<code>HTML</code>顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取</li>
<li>重要内容不要用<code>js</code>输出：爬虫不会执行js获取内容</li>
<li>少用<code>iframe</code>：搜索引擎不会抓取<code>iframe</code>中的内容</li>
<li>非装饰性图片必须加<code>alt</code></li>
<li>提高网站速度：网站速度是搜索引擎排序的一个重要指标</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>SEO</tag>
      </tags>
  </entry>
  <entry>
    <title>移动Web开发--flex布局</title>
    <url>/2020/03/23/%E7%A7%BB%E5%8A%A8WEB%E5%BC%80%E5%8F%91%E4%B9%8Bflex%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h4 id="flex弹性布局"><a href="#flex弹性布局" class="headerlink" title="flex弹性布局"></a>flex弹性布局</h4><a id="more"></a>

<p>操作改变，布局简单，<strong>移动端</strong>应用很广泛</p>
<p>:fallen_leaf: :balance_scale::ear_of_rice::honey_pot::horse_racing:</p>
<p>display: flex </p>
<p>justify-content: center|space-around</p>
<p>flex: 1</p>
<p>自适应 平均分配  在移动端比float浮动好用很多</p>
<ol>
<li><p>flex是flexible Box的缩写，意为弹性布局，用来为盒装模型提供最大的灵活性，任何一个容器都可以指定为flex布局</p>
<ul>
<li>当我们为父盒子设为flex 布局后，子元素的float、clear和vertical-align属性将失效</li>
<li>伸缩布局 = 弹性布局 = 伸缩盒布局 = flex布局</li>
</ul>
</li>
<li><p>采用flex布局的元素，成为flex容器，它的所有子元素自动成为容器成员，成为flex项目。</p>
<p>（通过给父盒子添加flex属性，来控制盒子的位置和排列方式）</p>
</li>
<li><p>常见父项属性</p>
<p>以下由6个属性是对父元素设置的</p>
<ul>
<li><p>flex-direction：设置<u>主轴</u>的方向</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>row</td>
<td>（默认）从左到右</td>
</tr>
<tr>
<td>row-reverse</td>
<td>从右到左</td>
</tr>
<tr>
<td>column</td>
<td>从上到下</td>
</tr>
<tr>
<td>column-reverse</td>
<td>从下到上</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>justify-content：设置<u>主轴</u>上的子元素排列方式</p>
<p>注意：使用这个属性之前，一定要确定好主轴是哪个</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>flex-start</td>
<td>（默认）从头部开始</td>
</tr>
<tr>
<td>flex-end</td>
<td>从尾部开始排列，顺序是不变的</td>
</tr>
<tr>
<td>center</td>
<td>在主轴居中对齐（如果主轴是x轴则居中）<em>最常用</em></td>
</tr>
<tr>
<td>space-around</td>
<td>平均剩余空间</td>
</tr>
<tr>
<td>space-between</td>
<td>先两边贴边 再平分剩余空间（重要）</td>
</tr>
</tbody></table>
</li>
</ul>
<ul>
<li><p>flex-wrap：设置子元素是否换行</p>
<p>注意：默认情况下，项目都排在一条线（轴）上，flex-wrap属性定义flex布局中默认是不换行的</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>nowrap</td>
<td>默认值，不换行</td>
</tr>
<tr>
<td>wrap</td>
<td>换行</td>
</tr>
</tbody></table>
</li>
</ul>
<ul>
<li><p>align-items：设置<u>侧轴</u>上的子元素排列方式（单行）</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>flex-start</td>
<td>（默认）从上到下</td>
</tr>
<tr>
<td>flex-end</td>
<td>从下到上</td>
</tr>
<tr>
<td>center</td>
<td>挤在一起居中（垂直居中）<em>最常用</em></td>
</tr>
<tr>
<td>stretch</td>
<td>拉伸</td>
</tr>
</tbody></table>
</li>
</ul>
<ul>
<li><p>align-content：设置<u>侧轴</u>上的子元素的排列方式（多行）</p>
<p>设置子项在侧轴上的排列方式并且只能用于子项出现<strong>换行</strong>的情况（多行），在单行下是没有效果的</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>flex-start</td>
<td>默认值在侧轴的头部开始排列</td>
</tr>
<tr>
<td>flex-end</td>
<td>在侧轴的尾部开始排列</td>
</tr>
<tr>
<td>center</td>
<td>在侧轴中间显示</td>
</tr>
<tr>
<td>space-around</td>
<td>子项在侧轴平分剩余空间</td>
</tr>
<tr>
<td>space-between</td>
<td>子项在侧轴 先分布在两头，再平分剩余空间</td>
</tr>
<tr>
<td>stretch</td>
<td>设置子项元素高度平分父元素高度</td>
</tr>
</tbody></table>
</li>
</ul>
<ul>
<li><p>flex-flow ：复合属性，相当于同时设置了flex-direction和flex-wrap</p>
<p><em>flex-flow ：row wrap；</em></p>
</li>
</ul>
<ol start="4">
<li><p>flex布局子项常见属性</p>
<ul>
<li><p>flex子项目占的份数</p>
<p><em>flex ：1 ；</em>  <em>flex ： 2  ；</em></p>
</li>
<li><p>align-self控制子项自己在侧轴的排列方式</p>
</li>
<li><p>order属性定义子项的排列顺序（前后顺序）</p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Css</category>
      </categories>
      <tags>
        <tag>网页布局</tag>
      </tags>
  </entry>
  <entry>
    <title>移动Web开发--rem适配布局</title>
    <url>/2020/03/23/%E7%A7%BB%E5%8A%A8WEB%E5%BC%80%E5%8F%91%E4%B9%8Brem%E9%80%82%E9%85%8D%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<p>rem 移动开发中重要的一种布局</p>
<a id="more"></a>

<h4 id="rem-基础"><a href="#rem-基础" class="headerlink" title="rem 基础"></a>rem 基础</h4><h5 id="rem-单位"><a href="#rem-单位" class="headerlink" title="rem 单位"></a>rem 单位</h5><p>rem（root em）是一个相对单位，类似于em，em是父元素字体大小。em，比如，父元素的字体大小<code>font-size = 12px</code>，子元素中就可以以1em = 12px 用em 来表示单位去设置 宽高大小 等。</p>
<p>不同的是 rem 的基准是相对于 html 元素的字体大小</p>
<p>比如，根元素（html）设置font-size = 12px；非根元素width：2rem，则换成px表示就是24px</p>
<p>rem 优点：可以通过修改html里面的文字大小，来改变页面中元素的大小，可以整体控制</p>
<h5 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h5><ol>
<li><p>媒体查询（Media Query）是CSS3新语法</p>
<ul>
<li>使用@media 查询，可以针对不同的媒体类型定义不同的样式</li>
<li>@media 可以针对不同的屏幕尺寸设置不同的样式</li>
<li>当你重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面</li>
<li>目前针对很多苹果手机，Android手机，平板等设备都用得到多媒体查询</li>
</ul>
</li>
<li><p>语法规范</p>
<p>@media mediatype and|not|only （media feature）{CSS-Code；}</p>
<ul>
<li><p>用@media开头，注意@符号</p>
</li>
<li><p>mediatype 媒体类型</p>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>all</td>
<td>用于所有设备</td>
</tr>
<tr>
<td>print</td>
<td>用于打印机和打印预览</td>
</tr>
<tr>
<td>screen（常用）</td>
<td>用于电脑屏幕、平板电脑、智能手机</td>
</tr>
</tbody></table>
</li>
<li><p>关键字 and not only</p>
<p> and（常用）：可以将多个媒体特性链接到一起，相当于“且”</p>
<p> not：排除某个媒体类型，相当于“非”</p>
<p> only：指定某个特性的媒体类型</p>
</li>
<li><p>media feature 媒体特性 必须要有小括号包含</p>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>width</td>
<td>定义输出设备中页面课件区域的宽度</td>
</tr>
<tr>
<td>min-width</td>
<td>定于输出设备中页面最小可见区域宽度</td>
</tr>
<tr>
<td>max-width</td>
<td>定于输出设备中页面最大可见区域宽度</td>
</tr>
</tbody></table>
<p>eg：当宽度小于800px时，body背景色为粉色，当宽度小于400px时，背景色为黄色</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width:</span><span class="number">800px</span>)&#123;</span></span><br><span class="line">       body&#123;</span><br><span class="line">          background-color: pink;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width:</span><span class="number">400px</span>)&#123;</span></span><br><span class="line">       body&#123;</span><br><span class="line">          background-color: yellow;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>媒体查询+rem实现元素动态大小变化</p>
<p> rem单位是跟着html 根元素字体大小来变化的</p>
<p> 媒体查询可以根据不同设备宽度来修改样式</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span><span class="number">320px</span>)&#123;</span></span><br><span class="line">        html&#123;</span><br><span class="line"><span class="css">           <span class="selector-tag">font-size</span><span class="selector-pseudo">:50px</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span><span class="number">640px</span>)&#123;</span></span><br><span class="line">        html&#123;</span><br><span class="line"><span class="css">           <span class="selector-tag">font-size</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.top</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">height</span><span class="selector-pseudo">:1rem</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">width</span><span class="selector-pseudo">:.5rem</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">background-color</span><span class="selector-pseudo">:green</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">color</span>:<span class="selector-id">#fff</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">text-align</span><span class="selector-pseudo">:center</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">line-height</span><span class="selector-pseudo">:1rem</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"top"</span>&gt;</span></span><br><span class="line">        購物車</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>引入资源（理解）</p>
</li>
</ol>
<h4 id="rem-适配方案"><a href="#rem-适配方案" class="headerlink" title="rem 适配方案"></a>rem 适配方案</h4><ol>
<li>让一些不能等比自适应的元素，达到当设备尺寸发生改变的时候，等比例适配当前设备</li>
<li>使用媒体查询根据不同设备按比例设置html 的字体大小，然后页面元素使用rem 做尺寸单位，当html 字体大小变化，元素尺寸也会发生变化， 从而达到等比缩放的适配</li>
</ol>
<h5 id="rem-实际开发适配方案"><a href="#rem-实际开发适配方案" class="headerlink" title="rem 实际开发适配方案"></a>rem 实际开发适配方案</h5><p>① 按照设计稿与设备宽度的比例，动态计算并设置html 根标签的 font-size大小；（媒体查询）</p>
<p>② CSS中，设计稿元素的宽、高、相对位置等取值，按照同比例换算为rem为单位的值</p>
<h5 id="rem-适配方案技术使用"><a href="#rem-适配方案技术使用" class="headerlink" title="rem 适配方案技术使用"></a>rem 适配方案技术使用</h5><p>技术方案1：</p>
<ul>
<li><p>less</p>
</li>
<li><p>媒体查询</p>
</li>
<li><p>rem</p>
<p>设计稿中，常见宽度 750px or 720px；将宽度750px划分为15份，每一份为50px</p>
<p>通过媒体查询设置，当最小宽度为750px时，将html 的font-size 设置为50px；min-width：320px，font-size：21.33px。这样就能在不同屏幕下，进行等比例缩放</p>
</li>
</ul>
<p>技术方案2(推荐)：</p>
<ul>
<li>flexible.js</li>
<li>rem</li>
</ul>
<p>总结：</p>
<p>两种方案现在都存在</p>
<p>方案2 更简单，因为flexible.js解决了很大一部分</p>
]]></content>
      <categories>
        <category>Css</category>
      </categories>
      <tags>
        <tag>网页布局</tag>
      </tags>
  </entry>
  <entry>
    <title>计网1</title>
    <url>/2020/05/06/%E8%AE%A1%E7%BD%911/</url>
    <content><![CDATA[<p><strong>概述</strong> 第一节 计算机网络体系结构的概述</p>
<a id="more"></a>

<h4 id="计算机网络的定义（考纲）"><a href="#计算机网络的定义（考纲）" class="headerlink" title="计算机网络的定义（考纲）"></a>计算机网络的定义（考纲）</h4><p>计算机网络就是一些 <strong>互联的</strong>、<strong>自治的</strong>计算机系统的集合。计算机网络是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现<strong>资源共享</strong>、<strong>信息传递</strong>的系统。</p>
<h4 id="计算机网络组成"><a href="#计算机网络组成" class="headerlink" title="计算机网络组成"></a>计算机网络组成</h4><img src="/2020/05/06/%E8%AE%A1%E7%BD%911/%E8%AE%A1%E7%BD%91%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86.svg" class>

<h4 id="计算机网络功能（考纲）"><a href="#计算机网络功能（考纲）" class="headerlink" title="计算机网络功能（考纲）"></a>计算机网络功能（考纲）</h4><p>主要有以下五大功能：</p>
<ol>
<li><strong>数据通信</strong>：最基本最重要的功能，实现联网计算机之间的各种信息的传输，并将分散在不同地理位置的计算机联系起来，统一分配、控制、管理。</li>
<li><strong>资源共享</strong>：资源共享可以是软件共享、数据共享、硬件共享。</li>
<li>分布式处理</li>
<li>提高可靠性</li>
<li>负载均衡：将工作任务均衡地分配给计算机网络中的各台计算机。</li>
</ol>
<h4 id="计算机网络分类"><a href="#计算机网络分类" class="headerlink" title="计算机网络分类"></a>计算机网络分类</h4><h5 id="按分布范围分类"><a href="#按分布范围分类" class="headerlink" title="按分布范围分类"></a>按分布范围分类</h5><p>后面会有详细讲解</p>
<ol>
<li>广域网（WAN）：远程，因特网核心</li>
<li>城域网（MAN）：大多采用以太网技术</li>
<li>局域网（LAN）：传统上，局域网使用广播技术、而广域网使用交换技术；校园网</li>
<li>个人区域网（PAN）：平板、手机</li>
</ol>
<h5 id="按传输技术分类"><a href="#按传输技术分类" class="headerlink" title="按传输技术分类"></a>按传输技术分类</h5><ol>
<li>广播式网络：所有互联计算机共享一个公共通信信道。局域网基本采用广播式通信技术，广域网中无线、卫星通信网络也采用广播式网络。</li>
<li>点对点网络：每条物理线路连接一对计算机。</li>
</ol>
<h5 id="拓扑结构分类（考纲）"><a href="#拓扑结构分类（考纲）" class="headerlink" title="拓扑结构分类（考纲）"></a>拓扑结构分类（考纲）</h5><p>网络拓扑结构是指由网中<strong>结点</strong>（<u>路由器</u>、<u>主机</u>等）与通信设备（网线）之间的几何关系表示的网络结构，主要指通信子网的拓扑结构。</p>
<p>（理解每一个拓扑结构的基本概念）：总线型、星型、环形、网状型网络；其中总线型、星型、环形多用于局域网、网状形多用于广域网。</p>
<h5 id="按使用者分类"><a href="#按使用者分类" class="headerlink" title="按使用者分类"></a>按使用者分类</h5><p>公用网、专用网</p>
<h5 id="按交换技术分类"><a href="#按交换技术分类" class="headerlink" title="按交换技术分类"></a>按交换技术分类</h5><p>电路交换、报文交换、分组交换</p>
<h5 id="按传输介质分类"><a href="#按传输介质分类" class="headerlink" title="按传输介质分类"></a>按传输介质分类</h5><p>有线无线</p>
<h4 id="计算机网络性能指标（考纲）"><a href="#计算机网络性能指标（考纲）" class="headerlink" title="计算机网络性能指标（考纲）"></a>计算机网络性能指标（考纲）</h4><table>
<thead>
<tr>
<th>性能指标</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>带宽</td>
<td>“最高数据率” 单位比特/秒（b/s）</td>
</tr>
<tr>
<td>时延</td>
<td>①.发送时延（传输时延）：<em>发送时延 = 分组长度 / 信道宽度</em>；<br>②.传播时延：电磁波在信道中传播一定的距离需要花费的时间：<em>传播时延 = 信道长度 / 电磁波在信道上的传播速率</em>；<br>③.处理时延 ④.排队时延。<br>总时延：为四个时延相加。</td>
</tr>
<tr>
<td>时延带宽积</td>
<td><em>时延带宽积 = 传播时延*信道带宽</em></td>
</tr>
<tr>
<td>往返时延</td>
<td>Round-Trip Time ，RTT，发送端发送数据开始，到发送端收到接收端的确认，总共经历的时延。</td>
</tr>
<tr>
<td>吞吐量</td>
<td>Throughput，单位时间内通过某个网络（或信道、接口）的数据率，吞吐量受网络额定速率的限制。</td>
</tr>
<tr>
<td>速率</td>
<td>数据率、比特率；单位为b/s 比特/秒；kb/s、Mb/s、Gb/s 。</td>
</tr>
<tr>
<td>信道利用率</td>
<td>信道利用率 = 有数据通过时间 / （有+无）数据通过时间</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>考研笔记</category>
      </categories>
      <tags>
        <tag>考研803</tag>
      </tags>
  </entry>
  <entry>
    <title>网络安全之攻守道</title>
    <url>/2020/03/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B9%8B%E6%94%BB%E5%AE%88%E9%81%93/</url>
    <content><![CDATA[<p>网络安全，就是攻守之间的对抗</p>
<a id="more"></a>

<blockquote>
<p>学习地址指路 <a href="https://www.bilibili.com/video/BV1yW411q7GF">https://www.bilibili.com/video/BV1yW411q7GF</a></p>
</blockquote>
<h5 id="Http-传输数据存在的问题"><a href="#Http-传输数据存在的问题" class="headerlink" title="Http 传输数据存在的问题"></a>Http 传输数据存在的问题</h5><p>http协议传输，超文本传输协议HTTP协议被用于在Web浏览器和网络服务器之间传递信息。HTTP协议以明文方式发送内容，不提供任何方式的数据加密。所以如果黑客截取了Web浏览器和网站服务器之间的传输报文，就可以直接读取重要信息（密码 账号 卡号等）。</p>
<h5 id="Https-简介"><a href="#Https-简介" class="headerlink" title="Https 简介"></a>Https 简介</h5><p>https协议，安全套接字层超文本传输协议HTTPS。是在HTTP的基础上加了SSL（Secure，Sockets，Layer，安全套接字层）。SSL依靠证书来验证服务器的身份，为浏览器和服务器之间的通信加密。</p>
<img src="/2020/03/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B9%8B%E6%94%BB%E5%AE%88%E9%81%93/w1.png" class>



<h5 id="Https-和Http-的区别"><a href="#Https-和Http-的区别" class="headerlink" title="Https 和Http 的区别"></a>Https 和Http 的区别</h5><ol>
<li>https协议需要到 ca 申请证书，一般都要收费</li>
<li>http是超文本传输协议，信息是明文传输，连接很简单，https协议是由SSL+HTTP协议构建的 可进行 加密传输、身份认证的网络协议。安全性更高</li>
<li>http 和 https 使用的是完全 不同 的连接方式，用的端口不一样。前者是 80 端口，后者是 443</li>
</ol>
<h5 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a><a href="https://baike.sogou.com/v214573.htm?fromTitle=ssl">SSL</a></h5><ol>
<li><p>定义</p>
<p>SSL(Secure Sockets Layer<a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=7628534&ss_c=ssc.citia">安全套接层</a>,及其继任者<a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=25967&ss_c=ssc.citiao.link">传输层安全</a>（<a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=101608365&ss_c=ssc.citiao.link">Transport</a> Layer Security，TLS）是为网络通信提供安全及<a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=340077&ss_c=ssc.citiao.link">数据完整性</a>的一种安全协议。TLS与SSL在传输层与<a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=16954&ss_c=ssc.citiao.link">应用层</a>之间对网络连接进行加密。</p>
</li>
<li><p>作用</p>
<p>认证用户和服务器，确保数据发送到正确的 客户机 和 服务器；</p>
<p>加密数据以防止数据中途被窃取；</p>
<p>维护数据的完整性，确保数据在传输过程中不被改变。</p>
</li>
<li><p>服务器类型</p>
<ol>
<li><p>Tomcat 5.x</p>
</li>
<li><p>Nginx</p>
</li>
<li><p>IIS</p>
</li>
<li><p>Apache 2.x</p>
</li>
<li><p>IBM HTTP SERVER 6.0</p>
</li>
</ol>
</li>
</ol>
<h5 id="SSL-安全加密方式"><a href="#SSL-安全加密方式" class="headerlink" title="SSL 安全加密方式"></a>SSL 安全加密方式</h5><p>了解加密方式，分为对称加密和非对称加密</p>
<ol>
<li>对称加密(Symmetric Cryptography)<ul>
<li>原理：加密算法是公开的，靠的是密钥来加密数据；使用一个密钥加密，使用相同的密钥解密</li>
<li>常用对称加密算法：DES,  3DES， AES(破解难度大)</li>
<li>注意：在传输加密数据之前，需要传递密钥</li>
<li><img src="/2020/03/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B9%8B%E6%94%BB%E5%AE%88%E9%81%93/w4.png" class></li>
<li><img src="/2020/03/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B9%8B%E6%94%BB%E5%AE%88%E9%81%93/w2.png" class></li>
</ul>
</li>
<li>对称加密优缺点<ul>
<li>优点：计算量较小，加密和解密的速度比较快，适合加密比较大的数据</li>
<li>缺点：密钥的传输容易泄露；一个用户需要对应一个密钥，服务器管理密钥比较麻烦</li>
</ul>
</li>
<li>非对称加密<ul>
<li>原理：算法公开，一个公钥(public key)和一个私钥(private key)。 公钥加密只能私钥解密；私钥加密只能公钥解密，加密和解密的钥匙不同，即非对称加密</li>
<li>常用非对称加密算法：RSA</li>
<li>注意：公钥私钥需要加密算法生成</li>
<li><img src="/2020/03/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B9%8B%E6%94%BB%E5%AE%88%E9%81%93/w3.png" class></li>
</ul>
</li>
<li>非对称加密优缺点<ul>
<li>优点：加密和解密使用不同钥匙，可以传输公钥，数据传输是安全的</li>
<li>缺点：计算量大，加密解密速度较慢</li>
</ul>
</li>
</ol>
<h5 id="Https-传输"><a href="#Https-传输" class="headerlink" title="Https 传输"></a>Https 传输</h5><p>Https加密、解密及验证过程，两种加密方式结合使用</p>
<p>先使用非对称加密，服务器传输公钥 SSL数字证书；浏览器生成随机码，通过公钥传输给服务器。服务器通过私钥解开随机码。</p>
<p>将随机码作为密钥，使用对称加密(速度快)，将用户的重要信息通过随机码也就是密钥加密传过去。服务器之前已经用私钥解开了随机码（密钥），所以服务器用随机码（密钥）解开重要信息。</p>
<img src="/2020/03/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B9%8B%E6%94%BB%E5%AE%88%E9%81%93/w5.png" class>

<h5 id="服务器实现Https-协议"><a href="#服务器实现Https-协议" class="headerlink" title="服务器实现Https 协议"></a>服务器实现Https 协议</h5><ol>
<li><p>配置</p>
<ul>
<li><p>生成密钥库</p>
<p>确保环境变量配置了%JAVA_HOME%\bin, 因为生成密钥库是使用 jdk 中的 keytool工具</p>
<p>进入dos命令运行如下命令：</p>
<p>keytool -genkeypair -alias test-cyq -validity 3650 -keyalg RSA -dname \</p>
<p>123456</p>
</li>
<li><p>配置tomcat 启用https 协议并指定密钥库</p>
<p>进入server.xml ，将http配置注释掉，打开https，并配置https两个属性，指定密钥库的位置和密钥库的密码</p>
</li>
</ul>
</li>
<li><p>SSL 证书种类</p>
<p>域名型 DVSSL</p>
<p>企业型 OVSSL</p>
<p>增强型 EVSSL</p>
</li>
</ol>
<h5 id="Https-优缺点"><a href="#Https-优缺点" class="headerlink" title="Https 优缺点"></a>Https 优缺点</h5><p>优点：安全性高</p>
<p>缺点：收费，也不是绝对安全，耗电耗资源</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>网络安全</tag>
      </tags>
  </entry>
  <entry>
    <title>计网2</title>
    <url>/2020/05/06/%E8%AE%A1%E7%BD%912/</url>
    <content><![CDATA[<p><strong>概述</strong> 第二节 计算机网络体系结构与参考模型</p>
<a id="more"></a>

<h4 id="计算机网络分层结构"><a href="#计算机网络分层结构" class="headerlink" title="计算机网络分层结构"></a>计算机网络分层结构</h4><ol>
<li><p>我们把计算机网络的各层及其协议的集合 称为<strong>网络的体系结构</strong>，是从<strong>功能</strong>上描述计算机网络结构，是计算机网络中的层次、各层的协议及层间接口的集合。体系结构是抽象的，而实现是具体的。</p>
</li>
<li><p>分成的五个基本原则：</p>
<ul>
<li><p>每层都实现一种相对独立功能，降低大系统复杂度</p>
</li>
<li><p>各层之间界面自然清晰，易于理解，相互交流尽可能少</p>
</li>
<li><p>各层采用最合适的技术来实现</p>
</li>
<li><p>保持下层对上传的独立性，下层单项提供上层服务</p>
</li>
<li><p>整个分层结构促进标准化工作</p>
</li>
</ul>
</li>
<li><p>在计网分层结构中，第n层中的活动元素通常称为<strong>n层实体</strong>。不同及其上的同一层称为<strong>对等层</strong>，同一层的实体称为<strong>对等实体</strong>。n 提供服务给 n+1层。</p>
</li>
<li><p>在计网分层结构中，每个报文都分为两部分：数据部分 SDU 和控制信息部分 PCI，SDU+PCI = PDU</p>
</li>
<li><p>服务数据单元（SDU）、协议控制信息（PCI）、协议数据单元（PDU）；在各层间传输数据时，把从第n+1层收到的PDU作为第n层的SDU，加上第n层的PCI，变成了第n层的PDU，交给第n-1层作为SDU发送，接收方接收时做相反的处理。</p>
</li>
<li><p>物理层的PDU称为<strong>比特</strong>；链路层的PDU称为<strong>帧</strong>、网络层的PDU称为<strong>分组</strong>、传输层的PDU称为<strong>报文</strong>；</p>
</li>
</ol>
<h4 id="计算机网络的协议、接口、服务的概念"><a href="#计算机网络的协议、接口、服务的概念" class="headerlink" title="计算机网络的协议、接口、服务的概念"></a>计算机网络的协议、接口、服务的概念</h4><h5 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h5><ol>
<li>协议，就是规则的集合。为网络中的数据交换建立的规则、标准、约定称为<strong>网络协议</strong>（Network Protocol）；控制两个或多个对等实体进行通信的规则集合，是<strong>水平的</strong>。不对等实体之间是没有协议的。</li>
<li>协议由<strong>语法</strong>、<strong>语义</strong>和<strong>同步</strong>三部分组成。语法规定传输数据的格式（比如二进制 01）；语义规定了所要完成的功能，需要发出何种控制信息、完成何种动作、答复；同步规定了执行各操作的条件、时序关系等。</li>
<li>一个完整的协议通常具有线路管理（建立、释放连接）、差错控制、数据转换等功能。</li>
</ol>
<h5 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h5><p>接口时同一结点内相邻两层间交换信息的连接点，是一个系统内部的规定。每层只能为紧邻的层次之间定义接口，不能跨层定义接口。服务访问点（Service Access Point , SAP），服务是通过SAP提供给上层使用的。每个SAP都有一个能够表示它的地址。SAP是一个抽象概念，实际上是一个逻辑接口。</p>
<h5 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h5><p>服务是指下层为紧邻的上层提供的功能调用，是<strong>垂直的</strong>。对等实体在协议的控制下，使得本层能为上层提供服务。OSI中称为服务原语：请求、指示、响应、证实。</p>
<p>计算机网络提供的服务可按照以下分类</p>
<ul>
<li>面向连接服务与无连接服务</li>
<li>可靠服务和不可靠服务</li>
<li>有应答服务和无应答服务</li>
</ul>
<h4 id="ISO-OSI参考模型和TCP-IP模型（考纲）"><a href="#ISO-OSI参考模型和TCP-IP模型（考纲）" class="headerlink" title="ISO/OSI参考模型和TCP/IP模型（考纲）"></a>ISO/OSI参考模型和TCP/IP模型（考纲）</h4><p>目的：支持异构网络系统的互联互通。</p>
<h5 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h5><p>国际标准化组织ISO提出的网络体系结构模型，称为开放系统互联参考模型OSI/RM，简称为OSI参考模型，有7层。</p>
<img src="/2020/05/06/%E8%AE%A1%E7%BD%912/OSI%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.jpg" class>

<p>总结下：</p>
<ol>
<li>物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流(就是由1、0转化为电流强弱来进行传输，到达目的地后再转化为1、0，也就是我们常说的数模转换与模数转换)。这一层的数据叫做比特。</li>
<li>数据链路层：定义了如何让格式化数据以进行传输，以及如何让控制对物理介质的访问。这一层通常还提供错误检测和纠正，以确保数据的可靠传输。</li>
<li>网络层：在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择。Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。</li>
<li>传输层：定义了一些传输数据的协议和端口号(WWW端口80等)，如：TCP(传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据)，UDP(用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做段。</li>
<li>会话层：通过传输层(端口号：传输端口与接收端口)建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求(设备之间需要互相认识可以是IP也可以是MAC或者是主机名)。</li>
<li>表示层：可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换吗(EBCDIC)，而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。</li>
<li>应用层：是最靠近用户的OSI层。这一层为用户的应用程序(例如电子邮件、文件传输和终端仿真)提供网络服务。</li>
</ol>
<h5 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP/IP模型"></a>TCP/IP模型</h5><p>事实标准 4层</p>
<img src="/2020/05/06/%E8%AE%A1%E7%BD%912/TCPIP%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.jpg" class>

<p>总结下：</p>
<ol>
<li>TCP/IP参考模型是首先由ARPANET所使用的<a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=301274&ss_c=ssc.citiao.link">网络体系结构</a>。这个体系结构在它的两个主要协议出现以后被称为TCP/IP参考模型(TCP/IP Reference Model)。这一网络协议共分为四层：<a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=166609564&ss_c=ssc.citiao.link">网络访问层</a>、<a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=62691577&ss_c=ssc.citiao.link">互联网层</a>、传输层和应用层</li>
<li>TCP/IP协议不是 TCP和 IP这两个协议的合称，而是指因特网整个TCP/IP协议族。</li>
</ol>
]]></content>
      <categories>
        <category>考研笔记</category>
      </categories>
      <tags>
        <tag>考研803</tag>
      </tags>
  </entry>
  <entry>
    <title>计网4</title>
    <url>/2020/05/07/%E8%AE%A1%E7%BD%914/</url>
    <content><![CDATA[<p><strong>物理层</strong> 第四节 传输介质与物理层设备</p>
<a id="more"></a>

<h4 id="双绞线、同轴电缆、光纤与无线传输介质"><a href="#双绞线、同轴电缆、光纤与无线传输介质" class="headerlink" title="双绞线、同轴电缆、光纤与无线传输介质"></a>双绞线、同轴电缆、光纤与无线传输介质</h4><p>传输介质，又称传输媒体，是发送设备和接收设备之间的物理通路，并非物理层的设备！！！。传输介质可分为<strong>导向传输介质</strong>和<strong>非导向传输介质</strong>。导向传输：电磁波被导向沿着固体媒介(铜线或光纤)传播；非导向传输：传输介质是空气、真空或海水。</p>
<h5 id="双绞线"><a href="#双绞线" class="headerlink" title="双绞线"></a>双绞线</h5><ol>
<li>最常用的古老传输介质，两根采用一定规则并排绞合、相互绝缘的铜导线组成。</li>
<li>绞合减少对相邻导线电磁干扰。无层的双绞线是(UTP)，双绞线外面加一层金属丝编织成的屏蔽层，这就是屏蔽双绞线(STP)。</li>
<li>双绞线便宜，在局域网和传统电话网中普遍使用。双绞线带宽取决于铜线粗细和传输距离。模拟传输和数字传输都可以使用双绞线，通信距离一般几千米到数十千米。距离太远，模拟传输需要用<strong>放大器放大</strong>衰减信号；数字传输需要用<strong>中继器</strong>将失真的信号<strong>整形</strong>。</li>
</ol>
<h5 id="同轴电缆"><a href="#同轴电缆" class="headerlink" title="同轴电缆"></a>同轴电缆</h5><ol>
<li>同轴电缆由内导体、绝缘层、网状编织层屏蔽层和塑料外层构成。共用一个轴心。按特性阻抗数值的不同，分为两类：基带同轴电缆传输基带数字信号，用于局域网；宽带同轴电缆传输宽带信号，用于有线电视系统。</li>
<li>外导体屏蔽层，良好抗干扰特性，广泛用于传输较高速率的数据，其传输距离更远，比双绞线贵。</li>
</ol>
<h5 id="光纤（考纲）"><a href="#光纤（考纲）" class="headerlink" title="光纤（考纲）"></a>光纤（考纲）</h5><ol>
<li>光纤通信利用光导纤维（简称光纤）传递光脉冲来通信。有光脉冲为1，无光脉冲为0。光纤通信系统的带宽范围极大。</li>
<li>光纤由<strong>纤芯</strong>（实心）和包层组成，光波通过纤芯进行传导，包层较纤芯有较低的折射率。当光纤从高折射率介质射向低折射率介质，其折射角大于入射角。如果入射角足够大，会形成全反射，即光线碰到包层时会折射回纤芯，这个过程不断重复，光沿着光纤传输下去。</li>
<li>两种光纤：<ul>
<li><strong>多模光纤</strong>：入射角不同，形成多束光纤传输。光源是发光二极管。光脉冲在多模光纤传输逐渐展宽，易失真，只适合短距离传输。</li>
<li><strong>单模光纤</strong>：光纤直径减小到一个光波长度，光纤就像一根波导，可使光纤一直向前传播，不会产生过多反射。光源是定向性好的激光二极管，制作成本高，衰减小，适合远距离传输。</li>
</ul>
</li>
</ol>
<p>光纤特点：</p>
<ul>
<li>传输损耗小，中继距离长，对远距离传输特别经济</li>
<li>抗雷电和电磁干扰好</li>
<li>无串音干扰，保密性好</li>
<li>体积小，重量轻</li>
</ul>
<h5 id="无线传输介质"><a href="#无线传输介质" class="headerlink" title="无线传输介质"></a>无线传输介质</h5><ol>
<li>无线电波：信号向所有方向扩散；广泛用于通信领域：无线手机通信、计算机网络中的无线局域网（WLAN）等。</li>
<li>微波、红外线和激光：高频率带宽；信号固定方向传播，直线；卫星通信使用微波信号。</li>
</ol>
<h4 id="物理层接口的特性"><a href="#物理层接口的特性" class="headerlink" title="物理层接口的特性"></a>物理层接口的特性</h4><p>主要任务：确定与传输媒体的接口有关的一些特性：</p>
<p>机械特性、电器特性、功能特性、规程特性</p>
<h4 id="中继器"><a href="#中继器" class="headerlink" title="中继器"></a>中继器</h4><ol>
<li>中继器，又称转发器。主要功能，将信号整形并放大再转发出去，信号再生。放大器是放大模拟信号，中继器整形数字信号。</li>
<li>具有5-4-3规则</li>
</ol>
<h4 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h4><ol>
<li>集线器（Hub）实质上是一个多端口的中继器，也工作在物理层。由Hub组成的网络是共享式网络，但逻辑上仍是一个总线网。Hub只能在半双工状态下工作。</li>
<li>对信号进行放大后发到其他所有端口。</li>
<li>星型拓扑结构的中间就是集线器。</li>
</ol>
]]></content>
      <categories>
        <category>考研笔记</category>
      </categories>
      <tags>
        <tag>考研803</tag>
      </tags>
  </entry>
  <entry>
    <title>计网3</title>
    <url>/2020/05/06/%E8%AE%A1%E7%BD%913/</url>
    <content><![CDATA[<p><strong>物理层</strong> 第三节 通信基础：基本概念、奈奎斯特定理香浓定理、编码与调制</p>
<a id="more"></a>



<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><h5 id="数据、信号与码元"><a href="#数据、信号与码元" class="headerlink" title="数据、信号与码元"></a>数据、信号与码元</h5><p>通信的目的是传递消息。</p>
<ol>
<li><strong>数据</strong>是指传送信息的实体。<strong>信号</strong>是指数据的<strong>电气或电磁</strong>表现，是数据在传输过程中的存在形式。数据和信号都可以用“模拟的”和“数字的”来修饰。<ul>
<li>连续变化的数据（或信号）称为<strong>模拟数据</strong>（模拟信号）；</li>
<li>取值仅允许为有限的几个离散数值的数据（或信号）称为<strong>数字数据</strong>（数字信号）；</li>
</ul>
</li>
<li>数据的传输方式可分为串行传输、并行传输。<ul>
<li><strong>串行传输</strong>是指：一个一个的比特按照时间顺序传输（对经济考虑，远距离通信通常采用串行传输）；</li>
<li><strong>并行传输</strong>是指：多个比特通过多条通信信道同时传输；速度快，费用高，适用于近距离，用于计算机内部数据传输；</li>
</ul>
</li>
<li><strong>码元</strong>：是指用一个固定时长的信号波形（数字脉冲）表示一位k进制数字，代表不同离散数值的基本波形，是<strong>数字通信</strong>中<strong>数字信号</strong>的计量单位，这个时长内的信号称为k进制码元，而该<strong>时长</strong>称为<strong>码元宽度</strong>。1码元可以携带多个比特的信息量。eg：在使用二进制编码时，只有两种不同的码元：一种代表0状态，一种代表1状态；在使用四进制编码时，2bit位可以表示四种码元：00 01 10 11；使用n进制编码，就有n中码元，即有 <em>2的x次方 = n</em> ，x个bit来表示。</li>
</ol>
<h5 id="信源、信道与信宿"><a href="#信源、信道与信宿" class="headerlink" title="信源、信道与信宿"></a>信源、信道与信宿</h5><ol>
<li><strong>数据通信</strong>是指数字计算机或其他数字终端之间的通信。一个数据通信系统主要划分为信源、信道和信宿三部分。</li>
<li><strong>信源</strong>是产生和发送数据的源头。<strong>信宿</strong>是接收数据的终点，它们通常都是计算机或其他数字终端转置。需要通过<strong>变换器</strong>（调制解调器）转换成合适于在<strong>信道</strong>上传输的信号，也需要反转换器转成原始信息。</li>
<li>信道与电路不等同，<strong>信道</strong>是信号的<strong>传输媒介</strong>。<strong>噪声源</strong>是信道上的噪声（对信号的干扰）。</li>
<li>信道分为<strong>模拟信道</strong>和<strong>数字信道</strong>；也可分为<strong>无线信道</strong>和<strong>有线信道</strong>。</li>
<li>信道上传送信号有基带信号和宽带信号。<ul>
<li><strong>基带信号</strong>：将数字信号 1 和 0 直接用不同电压表示，然后传到数字信道上（基带传输）；</li>
<li><strong>宽带信号</strong>：将基带信号进行调制形成频分复用模拟信号，然后传到模拟信道上（宽带传输）；</li>
</ul>
</li>
<li>通信双方信息交互方式，可分为三种基本方式：<ul>
<li>单工通信：无线电、广播、电视广播</li>
<li>半双工：任何一方不能同时发送和接收信息</li>
<li>全双工</li>
</ul>
</li>
<li>信道的极限容量是指信道的<strong>最高码元传输速率</strong>或信道的极限信息传输速率。</li>
</ol>
<h5 id="速率、波特和带宽"><a href="#速率、波特和带宽" class="headerlink" title="速率、波特和带宽"></a>速率、波特和带宽</h5><ol>
<li><p>速率也称数据率，指数据传输速率，表示单位时间内传输的数据量<em>（s = vt）</em>。</p>
<ul>
<li><p><strong>码元传输速率</strong>。又称码元速率、波形速率。表示单位时间数字通信系统所传码元个数（也是脉冲个数或信号变化的次数），单位波特Baud。1 Baud = 1码元 / S。码元可多进制；码元速率与进制数无关。</p>
</li>
<li><p><strong>信息传输速率</strong>。又称信息速率，比特率。表示单位时间内数字通信系统传输的二进制码元个数（即比特数），单位比特/秒（b/s）。</p>
</li>
<li><p>若一个码元携带n比特的信息量，则M波特率的码元传输速率所对应的信息传输速率为 Mn b/s。</p>
<p>eg：若一码元携带2bit信息量，则5Baud的码元传输速率对应的信息传输速率为：<u>10 b/s</u>。</p>
<p>一码元携带2bit，即2*5=10 b/s。</p>
</li>
</ul>
</li>
<li><p>带宽原指具有的频带宽度，单位hz。在实际网络中，带宽表示最高数据率 b/s。</p>
</li>
</ol>
<h4 id="奈奎斯特定理与香浓定理（考纲）"><a href="#奈奎斯特定理与香浓定理（考纲）" class="headerlink" title="奈奎斯特定理与香浓定理（考纲）"></a>奈奎斯特定理与香浓定理（考纲）</h4><h5 id="奈斯定理"><a href="#奈斯定理" class="headerlink" title="奈斯定理"></a>奈斯定理</h5><ol>
<li><p>奈奎斯特（Nyquist）定理又称奈氏准则，在理想低通（没有噪声、宽带有限）的信道，极限码元传输速率为2W波特。W是理想低通信道的带宽，单位Hz。若用V表示每个码元离散电平的数目（即多少种不同的码元，即多少进制），则<strong>极限数据率</strong>为：</p>
<p><u><em>理想低通信道下的极限传输率 = 2Wlog2V b/s</em></u></p>
</li>
<li><p>奈氏准则结论：</p>
<ul>
<li>任何信道，码元传输速率有上限。超过上限会出现码间串扰。</li>
<li>信道频带越宽（通过的信号高频分量越多），就可用更高的速率进行码元的有效传输。</li>
<li>给出了码元传输速率的限制，但未限制每个码元可以对应多少个二进制位。</li>
</ul>
<p>提高数据传输速率，就设法使每个码元携带更多个比特的信息量，此时需要采用多元制的调制方法。</p>
</li>
</ol>
<h5 id="香浓定理"><a href="#香浓定理" class="headerlink" title="香浓定理"></a>香浓定理</h5><ol>
<li><p>香浓（Shannon）定理给出了 带宽受限 且 有高斯白噪音干扰 的信道极限数据传输率，可以做到不产生误差。定理定义为：</p>
<p><u><em>信道的极限数据传输率 = Wlog2（1+S/N） b/s</em></u></p>
<p>（W为信道带宽，S/N为信噪比；S为传输信号平均功率，N为信道内部高斯噪声功率）</p>
<p>单位转换：<u><em>信噪比 = 10log10（S/N）dB</em></u></p>
</li>
<li><p>香浓定理结论：</p>
<ul>
<li>信道带宽或信道中的信噪比越大，信息极限传输速率越高。</li>
<li>对一定的传输宽带和一定的噪声比，信息传输速率的上限是确定的。</li>
<li>只要信息的传输速率低于极限传输速率，就能找方法实现无差错的传输。</li>
<li>香浓定理得出信息极限传输速率，实际要低很多。</li>
</ul>
<p>若S/N没有上限，那么极限信息传输速率也没有上限。虽然实际信噪比有限制的。</p>
<p>限制了一个码元对应的二进制位数。</p>
</li>
</ol>
<h4 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h4><p>编码 –&gt;数字信号</p>
<p>调制 –&gt;模拟信号</p>
<h5 id="数字数据编码为数字信号（考纲）"><a href="#数字数据编码为数字信号（考纲）" class="headerlink" title="数字数据编码为数字信号（考纲）"></a>数字数据编码为数字信号（考纲）</h5><ol>
<li><p>归零编码</p>
</li>
<li><p>非归零编码</p>
</li>
<li><p>反向非归零编码</p>
</li>
<li><p>曼彻斯特编码（考纲）</p>
<p><strong>注意</strong>：以太网使用的编码方式就是 曼彻斯特编码。</p>
</li>
<li><p>查分曼彻思编码（考纲）</p>
</li>
</ol>
<h5 id="数字数据调制为模拟信号（考纲）"><a href="#数字数据调制为模拟信号（考纲）" class="headerlink" title="数字数据调制为模拟信号（考纲）"></a>数字数据调制为模拟信号（考纲）</h5><p>发送端数字数据调制为模拟信号在模拟信道上传输，在接收端将模拟信号还原为数字信号。对应调制解调器的调制和解调过程。</p>
<ol>
<li>调幅</li>
<li>调频</li>
<li>调相</li>
<li>调幅+调相</li>
</ol>
]]></content>
      <categories>
        <category>考研笔记</category>
      </categories>
      <tags>
        <tag>考研803</tag>
      </tags>
  </entry>
  <entry>
    <title>重绘和重排</title>
    <url>/2021/04/13/%E9%87%8D%E7%BB%98%E5%92%8C%E9%87%8D%E6%8E%92/</url>
    <content><![CDATA[<p>HTML页面进行重绘和重排（回流）</p>
<a id="more"></a>

<h3 id="浏览器运行机制："><a href="#浏览器运行机制：" class="headerlink" title="浏览器运行机制："></a>浏览器运行机制：</h3><ol>
<li>构建DOM树    生成内容树（html结构）</li>
<li>构建渲染树      css样式</li>
<li>布局渲染树      从根节点(&lt;html&gt;)递归调用，计算每一个元素的大小，位置等；给出每个节点所在屏幕上出现的确定坐标</li>
<li>绘制渲染树      遍历渲染树，使用UI层来绘制每个节点</li>
</ol>
<h3 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h3><p>​        重绘指的是，一个元素外观（颜色、背景）的改变，所触发的浏览器行为，即浏览器会根据新属性重新绘制页面</p>
<h3 id="重排（回流）"><a href="#重排（回流）" class="headerlink" title="重排（回流）"></a>重排（回流）</h3><p>​        重排指的是，一个元素或多个元素因为规模尺寸、布局、隐藏等改变页面需要重新构建页面。注意：每个页面至少需要回流一次，就是第一次加载的时候。</p>
<p>重排一定会导致重绘！！重排和重绘都会导致浏览器速度变慢！</p>
<h3 id="优化方法："><a href="#优化方法：" class="headerlink" title="优化方法："></a>优化方法：</h3><ol>
<li>浏览器自己的优化：浏览器会维护1个队列，把所有会引起重绘和重拍的操作放在队列中，达到一定数量或者一定时间间隔，浏览器就会更新队列，进行一次批处理。（维护队列，后批处理）</li>
<li>我们要注意的优化：减少对渲染树的操作，我们可以合并多次DOM和样式的修改，并减少对style样式的请求<ul>
<li>直接改变元素的className</li>
<li>需要多次重排的元素，position可以改为 absolute 或 fixed 。元素脱离了文档流，他的变化不会影响到其他元素了</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>面试基础篇01</title>
    <url>/2020/02/23/%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80%E7%AF%8701/</url>
    <content><![CDATA[<h4 id="面试基础篇01"><a href="#面试基础篇01" class="headerlink" title="面试基础篇01"></a>面试基础篇01</h4><a id="more"></a>

<h4 id="1-call-和-apply-的区别是什么，哪个性能更好一些？"><a href="#1-call-和-apply-的区别是什么，哪个性能更好一些？" class="headerlink" title="1.call 和 apply 的区别是什么，哪个性能更好一些？"></a>1.call 和 apply 的区别是什么，哪个性能更好一些？</h4><p>答：1.都是function原型上的方法，每一個函數作爲function函數的实例，可以调取原型上的call和apply方法；2.都是改变this指向的，唯一区别是call是一个个传参，而apply是以数组的形式传参。3.相类似方法bind，但是没有立即执行这个方法，预先处理改变this指向（异步可以用）。4.call性能要优于apply（尤其是传递给函数的参数超过三个的时候），所以开发的时候使用call多一点。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fn.call(obj, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>); <span class="comment">// 傳參是一個個</span></span><br><span class="line">fn.apply(obj, [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>]);<span class="comment">// 以數組的形式保存起來</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>];</span><br><span class="line">	obj = &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x, y, z</span>) </span>&#123;&#125;</span><br><span class="line">fn.apply(obj, arr); <span class="comment">//x=10,y=20,z=30</span></span><br><span class="line">fn.call(obj, arr); <span class="comment">//x=[10, 20, 30] y=z=undefined</span></span><br><span class="line">fn.call(obj, ...arr); <span class="comment">//基于ES6的展开运算符也可以实现把数组中的每一项依次传递给函数</span></span><br></pre></td></tr></table></figure>

<p>自己实现性能测试（只供参考）：任何的代码性能测试都是和测试的环境有关系的，例如CPU、内存、GPU等电脑当前性能。（电脑性能一般不稳定）</p>
<p><strong>console.time</strong>可以测试出一段程序执行的时间</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.time(<span class="string">'A'</span>);</span><br><span class="line"><span class="comment">//let t1 = new Date();</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;<span class="number">1000000</span>; i++)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//console.log(new Date() - t1);</span></span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'A'</span>);</span><br></pre></td></tr></table></figure>

<h4 id="2-实现-5-add-3-minus-2-使其结果输出为：6"><a href="#2-实现-5-add-3-minus-2-使其结果输出为：6" class="headerlink" title="2.实现(5).add(3).minus(2), 使其结果输出为：6"></a>2.实现(5).add(3).minus(2), 使其结果输出为：6</h4><p><em>arr.push();</em></p>
<p><em>arr是Array的实例，可以调用Array.prototype上的方法，push就是Array.prototype上的一个方法。</em></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">~<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//每一個方法執行完，都要返回Number这个类的实例，这样才可以继续调取Number类原型中的方法（链式写法）</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">        n = <span class="built_in">Number</span>(n);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isNaN</span>(n) ? <span class="number">0</span> : n;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">        n = check(n);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span> + n; </span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">minus</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">         n = check(n);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span> - n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Number</span>.prototype.add = add;</span><br><span class="line">    <span class="built_in">Number</span>.prototype.minus = minus;</span><br><span class="line"> <span class="comment">/* ["add", "minus"].forEach(item =&gt; &#123;</span></span><br><span class="line"><span class="comment">        Number.prototype[item] = eval(item);</span></span><br><span class="line"><span class="comment">    &#125;);*/</span></span><br><span class="line">&#125;();</span><br><span class="line"><span class="built_in">console</span>.log((<span class="number">5</span>).add(<span class="number">3</span>).minus(<span class="number">2</span>));</span><br></pre></td></tr></table></figure>

<h4 id="3-箭头函数与普通函数（function）的区别是什么？-构造函数（function）可以使用new生成实例，那么箭头函数可以吗？-为什么？"><a href="#3-箭头函数与普通函数（function）的区别是什么？-构造函数（function）可以使用new生成实例，那么箭头函数可以吗？-为什么？" class="headerlink" title="3.箭头函数与普通函数（function）的区别是什么？ 构造函数（function）可以使用new生成实例，那么箭头函数可以吗？  为什么？"></a>3.箭头函数与普通函数（function）的区别是什么？ 构造函数（function）可以使用new生成实例，那么箭头函数可以吗？  为什么？</h4><p>1.箭头函数es6语法比普通函数更简洁</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">functuon fn (x)&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> fn = <span class="function">(<span class="params">x</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">y</span>) =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2.箭头函数没有自己的this，他里面this是继承函数所处的上下文中的this，使用call/apply无法改变this的指向</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'OBJ'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);  <span class="comment">//this 指向obj</span></span><br><span class="line">&#125;</span><br><span class="line">fn1.call(obj);</span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">let</span> fn2 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);	<span class="comment">//this 指向window</span></span><br><span class="line">&#125;</span><br><span class="line">fn2.call(obj);</span><br></pre></td></tr></table></figure>

<h4 id="4-如何把一个字符串的大小写取反，例如‘AbC’变成’aBc’"><a href="#4-如何把一个字符串的大小写取反，例如‘AbC’变成’aBc’" class="headerlink" title="4.如何把一个字符串的大小写取反，例如‘AbC’变成’aBc’"></a>4.如何把一个字符串的大小写取反，例如‘AbC’变成’aBc’</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'abcdEFG的單詞！*'</span>;</span><br><span class="line"><span class="comment">/*for (let str i=0; i&lt;str.length; i++) &#123;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="comment">//正則</span></span><br><span class="line">str = str.replace(<span class="regexp">/[a-zA-Z]/g</span>, (content) =&gt; &#123;</span><br><span class="line">    <span class="comment">//content：每一次正则匹配的结果</span></span><br><span class="line">    <span class="comment">//验证是否为大写字母；把字母转换为大写后看和之前是否一样，如果一样，那么之前也是大写的；在ASCII表中找到大学字母的取值范围进行判断（65-90）。</span></span><br><span class="line">     <span class="comment">//content.charCodeAt()&gt;=65 &amp;&amp; content.charCodeAt()&lt;=90</span></span><br><span class="line">    <span class="keyword">return</span> content.toUpperCase() === content ? content.toLowerCase() : content.toUpperCase();</span><br><span class="line">   </span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(str);</span><br></pre></td></tr></table></figure>

<h4 id="5-实现一个字符串匹配算法，从字符串S中，查找是否存在字符串T，若存在-返回所在位置，不存在返回-1"><a href="#5-实现一个字符串匹配算法，从字符串S中，查找是否存在字符串T，若存在-返回所在位置，不存在返回-1" class="headerlink" title="5.实现一个字符串匹配算法，从字符串S中，查找是否存在字符串T，若存在 返回所在位置，不存在返回-1."></a>5.实现一个字符串匹配算法，从字符串S中，查找是否存在字符串T，若存在 返回所在位置，不存在返回-1.</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">indexOf/includes <span class="comment">//内置方法</span></span><br><span class="line">~<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;			<span class="comment">//闭包</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    循环原始字符串中的每一项，让每一项从当前位置向后截取			T.length个字符，和T比较，如果不一样，继续循环；如果一样</span></span><br><span class="line"><span class="comment">    返回当前索引值即可，循环结束；</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">myIndexOf</span>(<span class="params">T</span>)</span>&#123;</span><br><span class="line">      <span class="comment">//this：S</span></span><br><span class="line">    	<span class="keyword">let</span> lenT = T.length,</span><br><span class="line">      	 	lenS = <span class="keyword">this</span>.length，</span><br><span class="line">        	res = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(lenT&gt;lenS)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= lenS - lenT; i++)&#123;</span><br><span class="line">        	<span class="keyword">if</span>(<span class="keyword">this</span>.substr(i,lenT) === T)&#123;</span><br><span class="line">                res = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">       	 <span class="keyword">return</span> res;<span class="comment">//从当前字符i，截取lenT个，并与T对比。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用正则的方式做</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">myIndexOf</span>(<span class="params">T</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(T), <span class="comment">//这里是把T字符串变成了正则</span></span><br><span class="line">            res = reg.exec(<span class="keyword">this</span>);</span><br><span class="line">      	<span class="keyword">return</span> res === <span class="literal">null</span> ? <span class="number">-1</span> :res.index;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//把myIndexOf这个方法挂载到String的原型方法上</span></span><br><span class="line">    <span class="built_in">String</span>.prototype.myIndexOf = myIndexOf;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> S = <span class="string">'helloworld'</span>,</span><br><span class="line">	T = <span class="string">'world'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(S.myIndexOf(T));</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端面经</category>
      </categories>
      <tags>
        <tag>前端面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>计网5</title>
    <url>/2020/05/07/%E8%AE%A1%E7%BD%915/</url>
    <content><![CDATA[<p><strong>数据链路层</strong> 第五节 数据链路层的功能 + 组帧 +差错控制</p>
<a id="more"></a>

<h4 id="数据链路层的功能（考纲）"><a href="#数据链路层的功能（考纲）" class="headerlink" title="数据链路层的功能（考纲）"></a>数据链路层的功能（考纲）</h4><p>数据链路层（小秘） 使用下层 物理层的服务，并提供服务给上层 网络层。这三层是通信子网；主要作用，加强物理层传输原始比特流的功能，将物理层（傻子）提供的可能出差错的链路改造成逻辑上无差错的数据链路，使之对网络层（boss）表现为一条无差错链路。</p>
<h5 id="为网络层提供服务"><a href="#为网络层提供服务" class="headerlink" title="为网络层提供服务"></a>为网络层提供服务</h5><ol>
<li><p>无确认的无连接服务</p>
<p>机器发送数据帧时不需先建立链路连接，收到帧也不用确认，对丢失的帧，链路层也不重发（真随缘发送）。适用于实时通信或误码率较低的通信信道，如以太网：通信质量好，有线传输链路。</p>
</li>
<li><p>有确认的无连接服务</p>
<p>机器发送数据帧时不需先建立链路连接，收到帧要发回确认。丢失帧重传。误码率高的比如无线传输。</p>
</li>
<li><p>有确认的面向连接服务</p>
<p>帧传输三阶段：建立数据链、传输帧、释放数据链路。</p>
<p>注：不存在无确认的面向连接服务。</p>
</li>
</ol>
<h5 id="链路管理"><a href="#链路管理" class="headerlink" title="链路管理"></a>链路管理</h5><p>数据链路层连接的“建立、维持、释放”过程称为链路管理。主要用于有确认的面向连接服务。</p>
<h5 id="帧定界、帧同步与透明传输"><a href="#帧定界、帧同步与透明传输" class="headerlink" title="帧定界、帧同步与透明传输"></a>帧定界、帧同步与透明传输</h5><p><a href="https://blog.csdn.net/cainv89/article/details/50603699?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase">https://blog.csdn.net/cainv89/article/details/50603699?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase</a></p>
<p>我们需要对网络层（boss）的<strong>分组封装成帧</strong>，以帧传输。将一段数据的<strong>前后</strong>分别添加首部、尾部就构成帧。首尾部包含很多<strong>控制信息</strong>，主要作用是确定帧的界限，即<strong>帧定界</strong>。<strong>帧同步</strong>：接收方能从接收到的二进制比特流中区分出帧的起始与终止。</p>
<p><strong>透明传输</strong>：不管所传输的数据是什么样的比特组合，都应当能在链路上传送。</p>
<h5 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h5><p>控制发送速率。（大题必考！！！后面会有流量控制与可靠传输机制详细讲解，<u>停等协议</u>和<u>滑动窗口协议</u>）。发送方发送速度大于接收方接收速度，控制发送方的发送速率。</p>
<h4 id="组帧（考纲）"><a href="#组帧（考纲）" class="headerlink" title="组帧（考纲）"></a>组帧（考纲）</h4><p>将比特组合成帧，以帧为单位传输，为了在出错时只发送帧，而不是全部比特数据。</p>
<h4 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h4><p>差错检测防止差错的无效数据帧，浪费网络资源</p>
<h5 id="检错编码"><a href="#检错编码" class="headerlink" title="检错编码"></a>检错编码</h5><h5 id="纠错编码"><a href="#纠错编码" class="headerlink" title="纠错编码"></a>纠错编码</h5><p>海明码</p>
]]></content>
      <categories>
        <category>考研笔记</category>
      </categories>
      <tags>
        <tag>考研803</tag>
      </tags>
  </entry>
  <entry>
    <title>面试基础篇02</title>
    <url>/2020/02/26/%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80%E7%AF%8702/</url>
    <content><![CDATA[<h4 id="面试基础篇02"><a href="#面试基础篇02" class="headerlink" title="面试基础篇02"></a>面试基础篇02</h4><a id="more"></a>

<h4 id="1-var-a"><a href="#1-var-a" class="headerlink" title="1.var a = ?;"></a>1.var a = ?;</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//var a = ?;</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    n: <span class="number">0</span>,</span><br><span class="line">    <span class="comment">//私有的属性方法</span></span><br><span class="line">    toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ++ <span class="keyword">this</span>.n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//a.toString() //此时调取的不是Object.prototype.toString了，调取的是自己私有的方法</span></span><br><span class="line"><span class="keyword">if</span> ( a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a ==<span class="number">3</span> ) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'ok'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	== 進行比较，如果左右两边数据类型不一样，则先转换为相同的数据类型，然后再进行比较</span></span><br><span class="line"><span class="comment">	1.&#123;&#125; == &#123;&#125; 不相等，两个对象进行比较，比较的是堆内存的地址</span></span><br><span class="line"><span class="comment">	2.null == undefined 相等， null === undefined 不相等</span></span><br><span class="line"><span class="comment">	3.NaN == NaN 都不成立， NaN和谁都不相等</span></span><br><span class="line"><span class="comment">	4.[12] == '12' 成立，对象和字符串比较，是把对象toString转化为字符串后进行类型比较</span></span><br><span class="line"><span class="comment">	5.剩余所有情况在进行比较的时候，都是转换为数字（前提数据类型不一样）</span></span><br><span class="line"><span class="comment">	对象转数字：先toString转换为字符串，然后再转换为数字</span></span><br><span class="line"><span class="comment">	字符串转数字：只要传一个非数字字符，结果就是NaN</span></span><br><span class="line"><span class="comment">	布尔转数字：true -&gt; 1  false -&gt; 0</span></span><br><span class="line"><span class="comment">	null转数字：0</span></span><br><span class="line"><span class="comment">	undefined转数字 NaN</span></span><br><span class="line"><span class="comment">	*[12] == true =&gt; Number([12].toString()) == 1 fasle</span></span><br><span class="line"><span class="comment">	*[1] == trur =&gt; 1 == 1 true</span></span><br><span class="line"><span class="comment">	*[] == false =&gt; 0 == 0 true</span></span><br><span class="line"><span class="comment">	*[] == 1     =&gt; 0 == 1 false</span></span><br><span class="line"><span class="comment">	*'1' == 1    =&gt; 1 == 1 true</span></span><br><span class="line"><span class="comment">	*true == 2	 =&gt; 1 == 2 false</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//shift(); 删除数组第一项，把删除的内容返回，原有数组改变</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">a.toString = a.shift;  <span class="comment">//添加私有的toString方法</span></span><br><span class="line"><span class="keyword">if</span> ( a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a ==<span class="number">3</span> ) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'ok'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">es6中新增加的一些方法</span></span><br><span class="line"><span class="comment">	String.fromCharCode() </span></span><br><span class="line"><span class="comment">	Array.from()</span></span><br><span class="line"><span class="comment">	Array.isArray()</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="2-let-obj"><a href="#2-let-obj" class="headerlink" title="2.let obj = {"></a>2.let obj = {</h4><h4 id><a href="#" class="headerlink" title="}"></a>}</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.push = <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>[<span class="keyword">this</span>.length] = val</span><br><span class="line">    <span class="comment">//this.length在原来的基础上加1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*[12, 23].push(100)</span></span><br><span class="line"><span class="comment">[12, 23, 100]</span></span><br><span class="line"><span class="comment">arr=[12,23]</span></span><br><span class="line"><span class="comment">arr[arr.length] = 100;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="number">2</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="number">3</span>: <span class="number">4</span>,</span><br><span class="line">    length: <span class="number">2</span>,</span><br><span class="line">    push: <span class="built_in">Array</span>.prototype.push</span><br><span class="line">&#125;</span><br><span class="line">obj.push(<span class="number">1</span>)</span><br><span class="line">obj.push(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端面经</category>
      </categories>
      <tags>
        <tag>前端面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>面试基础篇03</title>
    <url>/2020/02/26/%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80%E7%AF%8703/</url>
    <content><![CDATA[<p><strong>从浏览器地址栏输入url到显示页面的步骤</strong></p>
<a id="more"></a>

<hr>
<blockquote>
<p>学习文档转自<a href="http://blog.poetries.top/FE-Interview-Questions/base/">http://blog.poetries.top/FE-Interview-Questions/base/</a></p>
</blockquote>
<hr>
<h5 id="基础版本"><a href="#基础版本" class="headerlink" title="基础版本"></a><strong>基础版本</strong></h5><ul>
<li>浏览器根据请求的<code>URL</code>交给<code>DNS</code>域名解析，找到真实<code>IP</code>，向服务器发起请求；</li>
<li>服务器交给后台处理完成后返回数据，浏览器接收文件（<code>HTML、JS、CSS</code>、图象等）；</li>
<li>浏览器对加载到的资源（<code>HTML、JS、CSS</code>等）进行语法解析，建立相应的内部数据结构（如<code>HTML</code>的<code>DOM</code>）；</li>
<li>载入解析到的资源文件，渲染页面，完成。</li>
</ul>
<h5 id="详细版"><a href="#详细版" class="headerlink" title="详细版"></a><strong>详细版</strong></h5><ol>
<li><p>在浏览器地址栏输入URL</p>
</li>
<li><p>浏览器查看</p>
<p>缓存</p>
<p>，如果请求资源在缓存中并且新鲜，跳转到转码步骤</p>
<ol>
<li><p>如果资源未缓存，发起新请求</p>
</li>
<li><p>如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。</p>
</li>
<li><p>检验新鲜通常有两个HTTP头进行控制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Expires</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cache-Control</span><br></pre></td></tr></table></figure>

<p>：</p>
<ul>
<li>HTTP1.0提供Expires，值为一个绝对时间表示缓存新鲜日期</li>
<li>HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的最大新鲜时间</li>
</ul>
</li>
</ol>
</li>
<li><p>浏览器<strong>解析URL</strong>获取协议，主机，端口，path</p>
</li>
<li><p>浏览器<strong>组装一个HTTP（GET）请求报文</strong></p>
</li>
<li><p>浏览器</p>
<p>获取主机ip地址</p>
<p>，过程如下：</p>
<ol>
<li>浏览器缓存</li>
<li>本机缓存</li>
<li>hosts文件</li>
<li>路由器缓存</li>
<li>ISP DNS缓存</li>
<li>DNS递归查询（可能存在负载均衡导致每次IP不一样）</li>
</ol>
</li>
<li><p>打开一个socket与目标IP地址，端口建立TCP链接</p>
<p>，三次握手如下：</p>
<ol>
<li>客户端发送一个TCP的<strong>SYN=1，Seq=X</strong>的包到服务器端口</li>
<li>服务器发回<strong>SYN=1， ACK=X+1， Seq=Y</strong>的响应包</li>
<li>客户端发送<strong>ACK=Y+1， Seq=Z</strong></li>
</ol>
</li>
<li><p>TCP链接建立后<strong>发送HTTP请求</strong></p>
</li>
<li><p>服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用HTTP Host头部判断请求的服务程序</p>
</li>
<li><p>服务器检查<strong>HTTP请求头是否包含缓存验证信息</strong>如果验证缓存新鲜，返回<strong>304</strong>等对应状态码</p>
</li>
<li><p>处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作</p>
</li>
<li><p>服务器将<strong>响应报文通过TCP连接发送回浏览器</strong></p>
</li>
<li><p>浏览器接收HTTP响应，然后根据情况选择</p>
<p>关闭TCP连接或者保留重用，关闭TCP连接的四次握手如下</p>
<p>：</p>
<ol>
<li>主动方发送<strong>Fin=1， Ack=Z， Seq= X</strong>报文</li>
<li>被动方发送<strong>ACK=X+1， Seq=Z</strong>报文</li>
<li>被动方发送<strong>Fin=1， ACK=X， Seq=Y</strong>报文</li>
<li>主动方发送<strong>ACK=Y， Seq=X</strong>报文</li>
</ol>
</li>
<li><p>浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同</p>
</li>
<li><p>如果资源可缓存，<strong>进行缓存</strong></p>
</li>
<li><p>对响应进行<strong>解码</strong>（例如gzip压缩）</p>
</li>
<li><p>根据资源类型决定如何处理（假设资源为HTML文档）</p>
</li>
<li><p><strong>解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行js脚本</strong>，这些操作没有严格的先后顺序，以下分别解释</p>
</li>
<li><p>构建DOM树</p>
<p>：</p>
<ol>
<li><strong>Tokenizing</strong>：根据HTML规范将字符流解析为标记</li>
<li><strong>Lexing</strong>：词法分析将标记转换为对象并定义属性和规则</li>
<li><strong>DOM construction</strong>：根据HTML标记关系将对象组成DOM树</li>
</ol>
</li>
<li><p>解析过程中遇到图片、样式表、js文件，<strong>启动下载</strong></p>
</li>
<li><p>构建</p>
<p>CSSOM树</p>
<p>：</p>
<ol>
<li><strong>Tokenizing</strong>：字符流转换为标记流</li>
<li><strong>Node</strong>：根据标记创建节点</li>
<li><strong>CSSOM</strong>：节点创建CSSOM树</li>
</ol>
</li>
<li><p><a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction">根据DOM树和CSSOM树构建渲染树</a></p>
<p>:</p>
<ol>
<li>从DOM树的根节点遍历所有<strong>可见节点</strong>，不可见节点包括：1）<code>script</code>,<code>meta</code>这样本身不可见的标签。2)被css隐藏的节点，如<code>display: none</code></li>
<li>对每一个可见节点，找到恰当的CSSOM规则并应用</li>
<li>发布可视节点的内容和计算样式</li>
</ol>
</li>
<li><p>js解析如下</p>
<p>：</p>
<ol>
<li>浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时<strong>document.readystate为loading</strong></li>
<li>HTML解析器遇到<strong>没有async和defer的script时</strong>，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用document.write()把文本插入到输入流中。<strong>同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作script和他们之前的文档内容</strong></li>
<li>当解析器遇到设置了<strong>async</strong>属性的script时，开始下载脚本并继续解析文档。脚本会在它<strong>下载完成后尽快执行</strong>，但是<strong>解析器不会停下来等它下载</strong>。异步脚本<strong>禁止使用document.write()</strong>，它们可以访问自己script和之前的文档元素</li>
<li>当文档完成解析，document.readState变成interactive</li>
<li>所有<strong>defer</strong>脚本会<strong>按照在文档出现的顺序执行</strong>，延迟脚本<strong>能访问完整文档树</strong>，禁止使用document.write()</li>
<li>浏览器<strong>在Document对象上触发DOMContentLoaded事件</strong></li>
<li>此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些<strong>内容完成载入并且所有异步脚本完成载入和执行</strong>，document.readState变为complete，window触发load事件</li>
</ol>
</li>
<li><p><strong>显示页面</strong>（HTML解析过程中会逐步显示页面）</p>
</li>
</ol>
<h5 id="详细简版"><a href="#详细简版" class="headerlink" title="详细简版"></a><strong>详细简版</strong></h5><ol>
<li>从浏览器接收<code>url</code>到开启网络请求线程（这一部分可以展开浏览器的机制以及进程与线程之间的关系）</li>
<li>开启网络线程到发出一个完整的<code>HTTP</code>请求（这一部分涉及到dns查询，<code>TCP/IP</code>请求，五层因特网协议栈等知识）</li>
<li>从服务器接收到请求到对应后台接收到请求（这一部分可能涉及到负载均衡，安全拦截以及后台内部的处理等等）</li>
<li>后台和前台的<code>HTTP</code>交互（这一部分包括<code>HTTP</code>头部、响应码、报文结构、<code>cookie</code>等知识，可以提下静态资源的<code>cookie</code>优化，以及编码解码，如<code>gzip</code>压缩等）</li>
<li>单独拎出来的缓存问题，<code>HTTP</code>的缓存（这部分包括http缓存头部，<code>ETag</code>，<code>catch-control</code>等）</li>
<li>浏览器接收到<code>HTTP</code>数据包后的解析流程（解析<code>html</code>-词法分析然后解析成<code>dom</code>树、解析<code>css</code>生成<code>css</code>规则树、合并成<code>render</code>树，然后<code>layout</code>、<code>painting</code>渲染、复合图层的合成、<code>GPU</code>绘制、外链资源的处理、<code>loaded</code>和<code>DOMContentLoaded</code>等）</li>
<li><code>CSS</code>的可视化格式模型（元素的渲染规则，如包含块，控制框，<code>BFC</code>，<code>IFC</code>等概念）</li>
<li><code>JS</code>引擎解析过程（<code>JS</code>的解释阶段，预处理阶段，执行阶段生成执行上下文，<code>VO</code>，作用域链、回收机制等等）</li>
<li>其它（可以拓展不同的知识模块，如跨域，web安全，<code>hybrid</code>模式等等内容）</li>
</ol>
]]></content>
      <categories>
        <category>前端面经</category>
      </categories>
      <tags>
        <tag>前端面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>Brakebills</title>
    <url>/2021/10/22/Brakebills/</url>
    <content><![CDATA[<p>Chapte I </p>
<p>‘’ Step of the path “</p>
<a id="more"></a>

<hr>
<p>“ 紧急情况！” 简走向校长。</p>
<p>“ 一直都是紧急情况 ” 校长看着报纸，平淡的说。</p>
<p>“ 已经发生了 ” 简把手中死去的飞蛾放在校长面前。</p>
<p>“ 他们都还没到Brakebills ” </p>
<p>“ 我知道，把他们带来那儿，至少当他到来时，他们会有些自保能力 ” - 简。</p>
<p>“ 你对我们能操纵所有事物能力的想法总是让我惊讶不已 ” - 校长 Henry。</p>
<p>“ 我必须试一下，把他们带到Brakebills是你的责任，特别是他，你最近有关注那个男孩吗？” - 简。</p>
<hr>
<p>“ Chatwin家的双胞胎和他们的哥哥被送到乡下，从小，Martin Chatwein就有抑郁症，为了减轻他的痛苦，他沉溺于精彩传奇故事中。他将她的姐姐Jane Chatwein 和哥哥 Rupert 从一个竖立钟表中穿梭进入到了一个神奇美丽的地方，魔法世界–fillory。”    Julia敲开门，走向躺在床上的Quentin Coldwater。“我这一周都在找你，你去哪儿了”  Julia想让Q振作起来，“我在我父亲家里面呆着 ”  Q也沉浸于魔法故事中，逃走了现实中的面试。</p>
<p>第二天，Julia带着Q来到了面试地点，却惊讶的发现有个老头子死在了里面，并且看到了他在小说中描述的那个钟表。等到警察来解决事情过后，Julia和Q又因为Q的沉迷而吵架。</p>
<p>“ you have to stop！”</p>
<p>“ stop what？”</p>
<p>“ 你不能这样逃离生活，你别再管fiilory这些破事会怎样 ” </p>
<p>“ 你以前喜欢fillory的 ”  - Q</p>
<p>” 是的，我喜欢，它陪伴着我们的高中时光，但是这已经过去了，我们要面对现实。我知道你上周去了哪里，是医院，你跟上次感觉一模一样，感到虚幻无力 “  - Julia</p>
<p>“ 每个人生活都有不如意的地方 ” - Q</p>
<p>“ 生活开始变了，变得真实了。听着，我只是说，你擅长的东西很多，随便选一样去工作 ” - Julia</p>
<p>两人分开后，Julia去找男友了，Q独自在路边走着。此时Q手中的纸被风吹走，然后引导着他走进了一个很大的绿色草坪之上，面前是一个学院。同时Julia莫名其妙也被引领到此地。</p>
<hr>
<p>“ Quentin Coldwater？” 一个名叫Eliet的高年级学长打量着Q</p>
<p>“ 这是哪？”</p>
<p>“ Brakebills University，你迟到了 ”</p>
<hr>
<p>此时学校正在举行一场考试，Julia和Q都在这场考试当中。但最终Julia没能通过考试，会被消除记忆后送回原本世界。</p>
<p>” 你们不能这样驱逐我，这些题目都是变化的，我要求申请重新考试 “  Julia对着一个教授Lee说到。</p>
<p>” 这就是规则，没能通过这次考试的，就不能入学 “ - Lee</p>
<p>“ 当我知道魔法都是真的之后，我还怎么能回到原本的世界中继续生活？” - Julia</p>
<p>“ 所以我们将会使用记忆消除药水，没关系，回去之后，你就什么都不记得了 ” - Lee</p>
<p>趁着 Lee 拿药水之际，Julia将自己的手臂用戒指划出一大道伤口，试图想一次记住这些事情。</p>
<hr>
<p>学长Eliet和学姐Margo去挑逗这个弱不经风的Q，带他逛着校园。校园里有各种魔法师，通灵的，幻术，治疗师等。此时有几个紧张兮兮的学生走过。</p>
<p>“ 他们是。。？” - Q</p>
<p>“ 他们是三年级的学生，据说一个班30多个人，最终只剩几个人去了，有人说他们退学了，有人说他们疯了，传闻很多不是吗？“ Eliet和Margo互相打趣着说。</p>
<p>“ Step on the garden path ” Margo对Q说到。</p>
<p>他们三个在校园里坐着，此时一个人低着头默默走过，她叫Alice。</p>
<p>“ 她的父母也是魔法师，她姑姑是这里的老师，如果能巴结到她，没准就能顺利毕业了。但校园里总有这些性格奇奇怪怪的孩子，他们并不受人欢迎 ” - Margo</p>
<p>“ hello，Alice，交个朋友吧！” - Margo挑逗的说到。</p>
<p>Alice瞟了一眼他们，就走开了。</p>
<hr>
<p>Q后来找到Alice，说Eliet和Margo只是想表示善意。而且自己很羡慕她这种魔法世家。而Alice并不在乎，因为她的父母并不关心她的生活她的学业。</p>
<p>“ 我可以帮助你 ” - Q</p>
<p>“ 帮助什么？” - Alice</p>
<p>“ whatever you need，只是，我懂得这种没人理解的心情 ” - Q</p>
<hr>
<p>Julia的男友James打来电话。</p>
<p>“ hei，you jerk！你忘记了Julia的生日了吗？” - James</p>
<p>“ hei ，James，I’m glad you call.” - Q</p>
<p>“ look, Julia最近魂不守舍的，可能是马上要入学了，有点紧张，我打算给她办个party “ - James</p>
<p>party现场。Q把Eliet 和 Margo带来了，他们俩在旁边嗨着玩。Q走向Julia。</p>
<p>“ 我要你告诉他们，他们看错我了 ” - Julia</p>
<p>“ Who ? ” - Q</p>
<p>“ Brakebills ,如果你说什么是 Brakebills 我会拿刀捅你，让他们再给我测试一下 ” - Julia</p>
<p>“ 你怎么会？ ” - Q</p>
<p>“ 会记得？，我让自己不忘记的 ” - Julia</p>
<p>“ 你不是该去耶鲁吗？ ” - Q</p>
<p>“ 那是我还不知道有其他，谁还会在乎商学院？你在乎吗？ ” - Julia</p>
<p>“ 那你必须有某种能力 ” - Q</p>
<p>此时Julia向Q展示了一个小小的花火魔法，她学了很久才学会的。</p>
<p>“ 人们在醉意或者无意识的时候或许会展现出某些奇怪的东西，但这不意味你有魔法潜能 ” - Q</p>
<p>“ 真伤人 ”  - Julia</p>
<p>“ 你知道你只是不想输 ” - Q</p>
<p>“ 什么？”  - Julia</p>
<p>“ 你知道你除此之外什么都在行，即使不擅长这个也没关系，你在伤害你自己。“  - Q</p>
<p>” 他们斩断了我的人生之路 ”  - Julia</p>
<p>“ 你的生活在这里 ” - Q</p>
<hr>
<p>Julia来到卫生间，此时Julia的衣服扣子一颗颗掉，然后身体突然被提起到空中，然后被魔法推到了墙上。这时走过来一个男人，叫做Pete。他抚摸着Julia。Julia突然手冒火光，将捆绑在手上的衣物解开。</p>
<p>“ what the hell ，你是什么强奸犯吗？” - Julia</p>
<p>“ No，当然不是，我也不会那样做，我只是来看看我是否做错了，看样子我没错，你以为只有从那所破学校学习到的东西才叫魔法吗？，我们已经观察你很久了 Julia ” - Pete</p>
<p>“ ’我们‘ 是谁？ ” - Julia</p>
<hr>
<p>回到学校，Q正在图书馆翻阅书，此时他貌似进入幻境，那个人正是书中的Jane，也就是Jane chatwin。</p>
<p>” 你以为你找到了归宿感 Brakebills ” - Jane</p>
<p>“ 别再踌躇不前，step of the path，赶快学会提问题 ，Brakebills 只是一个工具，你找到了归属感不是Brakebills，而是你开始掌握自己的命运” - Jane</p>
<hr>
<p>Alice找到Q，说她需要帮助。</p>
<p>“ 我需要你帮忙，我在学习一个魔法仪式 ” - Alice</p>
<p>“ OK，just tell me what to do ” - Q</p>
<p>午夜时分，他们来到教室，开始准备做仪式。在Penny脑海中，一直出现Q的声音，都快烦死了，就顺势找到了他们，并带来了Kate。</p>
<p>他们四个围在一起开始施咒，但什么都没发生，Penny气冲冲走了。当他们四人走后，镜子里面出现了一个用血画的笑脸。</p>
<hr>
<p>第二天，教授Lee 正在上课。突然学校的时钟开始不动了，校长意识到了危机，赶紧奔向教室。此时教室里面，所有人除了眼睛其他什么都不能动。从镜子里面出来了一个满脸是飞蛾的西装男人，走到前面，把教授杀死了。校长推开门用魔法还击，但不敌野兽。他也被控制住了，还被挖了眼珠放在桌上。</p>
<p>此时Q手上的硬币掉在了桌上，野兽注意到了，一步步慢慢逼近。</p>
<p>“ Quentin Coldwater ，there you are ，我们还是把一切扼杀在摇篮中吧 。“ 野兽捂住了Q的嘴。</p>
<p>此时校长用移物术将简给他的小钟表交到了Q手中，Q集中注意力按下了钟表，整个教室的时间开始流动，所有人开始惊慌的逃出教室。此时Penny脑海中突然传出一个女声 “ help！“ </p>
<p>Katy开始用战斗魔法还击野兽，可不敌野兽，一挥手把她头撞到了桌子上。Alice开始使用魔法将野兽脸上的飞蛾驱散，野兽捂住脸连连后退到镜子里面。Penny拿起凳子砸向了镜子。他们四个人都知道，这个野兽是怎么来的。</p>
<p>校园医务室的人来到教室，收拾着残局，调查者此次背后的野兽。</p>
<p>“ 你是如何知道战斗魔法的？” - 教授 Sunderland</p>
<p>“ 我知道学校不允许使用战斗魔法，但是，这种情况了。再说，我们能现在离开这里吗？please？！ ” - Kate</p>
<p>“ 你说校长给了你什么东西 ” - Sunderland</p>
<p>“ 校长给了我个钟表，我按了下去，校长还活着吗？ ” - Q</p>
<p>“ 他只是受了伤 ” - Sunderland</p>
<p>“ 我知道你们想知道发生了什么，我能告诉你们的是， 我们生活的世界只是多个世界中的一个，你们所看到的野兽来自其他地方。我们看不到本质，只知道它既强大又邪恶 。Brakebills有守卫和护盾的保护。我们目前在调查野兽是如何进入校园的，每个人将会被重新审查，该为此次袭击负责的人，将会被逐出校园。明天停课，星期三会有一个测试 ” - Sunderland</p>
<hr>
]]></content>
      <tags>
        <tag>fillory</tag>
      </tags>
  </entry>
  <entry>
    <title>Hedge witches</title>
    <url>/2021/10/22/Hedge-witches/</url>
    <content><![CDATA[<p>Chapter II</p>
<p>“ Level 50, Top bitch in NY, for starters ”</p>
<a id="more"></a>

<hr>
<p>Pete 把 Julia 带到一个废旧的仓库，里面还有几个类似小混混的人，这里的环境简直比Brakebills差了好几万倍。</p>
<p>“ 他们是谁？” - Julia</p>
<p>“ 跟你一样，new ” - Pete</p>
<p>“ Marina 和 Julia 跟我走 ” - Pete</p>
<p>Pete引领着她俩，然后将Marina和Julia关进了冷冻室里，并反锁了门。</p>
<p>“ Don‘t be an asshole！open the door！ ” - Julia 敲打着门。</p>
<p>“ 真的见鬼了，这里也太冷了，我们被困在这里了，他们想要杀了我们 ” Marina颤抖的说。</p>
<p>“ 他们不会杀了我们，这些人不是杀人犯 “  Julia正在打量着这里的环境和物品。</p>
<p>“ 你怎么知道？” - Marina</p>
<p>“ 他们没这种，这就像是一个欺负新人的惯例，一个测试  ” - Julia</p>
<hr>
<p>学校这边，Margo和Eliet带着Alice和Q来到无忧小屋里。</p>
<p>“ 你知道什么东西袭击了你吗？” - Margo</p>
<p>“ 不，我不知道 ” - Alice</p>
<p>“ 我还以为你出身魔法世家，可能奇闻异事见得多 ” - Margo</p>
<p>“ 你没有参加学院的考试，而是直接来的，为什么？有什么东西吸引着你吗？是学校的防御系统？还是珍贵的图书？” - Margo</p>
<p>“ 我父母有这里的钥匙，所以我偷了一把 ” - Alice</p>
<p>“ 你在这里总有原因的吧 ” - Margo</p>
<p>“ there is no reason ” - Alice</p>
<p>“ 我只是想和你做朋友 ” - Margo</p>
<p>“ 我不这样觉得，还是算了吧 ” - Alice起身离开 </p>
<hr>
<p>“ Ok, 这里有个谜语，我们翻翻这些报纸，没准能找到些东西 ” - Marina</p>
<p>“ 并不会这么简单的 ” - Julia</p>
<p>Pete在门外看了看，说到 “ come on “，然后是施了一点小魔法。</p>
<p>“ 啊啊！” Marina被面前突然起身的死尸下了一跳，那具死尸居然活了过来追赶着他们。</p>
<p>“ easy, it’me pete, Julia, 你想不想学魔法？ 如果你连这个都解决不了，那怎么对付我们将要做的事情，你们有没有四处找找 ”</p>
<p>最终，Julia和Marina找到了单子上的材料，施展了魔法，出来了。</p>
<p>“ This is shit test, I almost die there ” Julia对Pete凶道。</p>
<p>“ 我已经想你证明过我自己了，在我生日那天的卫生间里，你看到我施展过魔法 ” -  Julia</p>
<p>“ 你是在向我证明你自己 ”  Marina转头对Julia说，并展示出自己手上的五颗星印记。</p>
<p>“ 来点轻松的，我们去喝一杯吧 ” - Pete</p>
<hr>
<p>Alice找到Q，而Q不现在不想理Alice</p>
<p>“ 你跟我说那是什么提升潜能的魔法仪式，结果招来了，招来了满脸飞蛾的野兽 ，你一开始就不该说谎的 ” - Q</p>
<p>“ 对不起，我不该把你卷入这件事情当中，只是你手上的那个印记和我寻找那本书上的印记是一样的，还有我的哥哥，我意思是我哥哥的灵魂让你帮助我他取得联系 ” - Alice</p>
<p>“ 你哥哥？我听说过，你哥哥死在了学校里，你是想调查你哥哥的死因？” - Q</p>
<p>“ 我真的不确定这是不是真实的，我手上这个印记，是在我梦到fillory的时候出现的，是来自jane的 ” - Q</p>
<p>“ Jane Chatwin，the fillry book ” - Q</p>
<p>“ 我现在没空花时间听你讲这些玄幻的小说 ” - Alice</p>
<p>“ 深入费洛里这本书可能是虚构的，但Chatwin家族是真的 ” - Q</p>
<p>Q和Alice一起查看了当年30多年前的录影，是采访作家Christopher Plover的邻居的。当年chatwin双胞胎jane和martin送到了这里，由Plover收养。但当双胞胎神秘失踪过后，Plover心力憔悴，这就是他写的作品都比较阴沉的原因吧，过后Plover也神秘消失了。后来是Plover的姐姐打理着这件房子。他们都是好人，收养了很多孩子。后人为纪念Plover，这座房子现在可以供人参观浏览。</p>
<hr>
<p>Sunderland已经通过魔法查到了昨晚上，他们四个有在教室里施展魔法。他们被叫去审问。</p>
<p>Q 和 Alice 都说只是学习魔法。Penny 出来对 Kate说 “ we can go now ”。原来是Penny出卖了Q，把所有责任推给了Q。</p>
<p>这下Q要被逐出校园了。他试着打电话给Julia，问她是如何不被抹除记忆的。但Julia那边没接电话。</p>
<hr>
<p>Q 来到教室，审问他的是简，不过这时她自称克莱尔。</p>
<p>“ 你并非十分出色，你很聪明，但并非天才，你有魔法能力，但仅此而已。最糟糕的是，你太渴望归属感，而忘记了你为什么会来到这里。 ” - 简</p>
<p>“ 你梦见过是吧，fillory，在被野兽攻击之前的fillory。我也梦见过；我曾经目视过野兽那双眼睛 ” - 简</p>
<p>“ 什么？”</p>
<p>“ 你相信使命吗？” - 简</p>
<p>“ 是的 ”</p>
<p>“ 我以前也相信使命，只是我尽量乐观对待事情。虽然我不能告诉你为什么野兽会找上你，但接下来怎么做，是你的选择 ” - 简</p>
<p>“ who are you？ ”</p>
<p>“ 我只是一个不及格的魔法师罢了 ” - 简</p>
<p>“ 今天我不会抹去你的记忆，我会向学校申请再给你一次机会。他们会尊重我的决定。” - 简</p>
<p>“ Quentin，别让我失望 ，别再不安分的回到花园小径上，否则为了你好，我会抹除一切。” - 简</p>
<hr>
<p>简来到医院</p>
<p>“ 你怎么样 Henry？” 简满脸歉意的看着躺在床上的校长。校长双眼被挖走，手指也被野兽弄断了。</p>
<p>“ 对不起，我知道他来了，但我发誓我没有想到这么快 ” - 简</p>
<p>“ 没有人准备好了 ，我们需要更多时间，还有一个看得见的双手正常的老师 ” 校长无奈的说到。</p>
<p>“ 我们会帮助你的，治好你的手和眼睛 ” - 简</p>
<p>“ 这是你该想办法解决的麻烦，Quentin，Penny 他们现在还不足以对抗 ，你应该回去，找到野兽，然后杀掉他 ” - 校长生气的说到。</p>
<p>“ 你说的就像我随便搭个公交车就能回去一样，你以为我有办法的话，我们俩就该去喝酒庆祝而不是我在这里看着你失去眼睛和手的样子 ” - 简急着说又表现出担忧的样子。</p>
<p>“ 我们能做的只能把他们培养成经验丰富的魔法师 ” - 校长</p>
<p>“ 这远远不够 ” - 简</p>
<p>“ 我知道 ” - 校长</p>
<hr>
<p>Quentin拖着行李返回学校。</p>
<p>“ Quentin！ Here  ” Eliet在远处拿着酒招呼着Q</p>
<p>“ You little poor guy , come here , get some wine ” Margo 也叫道</p>
]]></content>
      <tags>
        <tag>fillory</tag>
      </tags>
  </entry>
  <entry>
    <title>Niffen</title>
    <url>/2021/10/22/Niffen/</url>
    <content><![CDATA[<p>Chapter III</p>
<p>“ 他全身燃烧了起来，直到不复存在，他变成了Niffen ”</p>
<a id="more"></a>

<hr>
<p>“ 是时候该学些魔法了，慢慢来 ” - Pete对Julia说到，Julia开始慢慢体会到魔法的滋味。</p>
<p>“  某种程度上，魔法师一直都在获得力量，远超自己的能量，元素。但是能量也会有代价。我们严格按照我们的处事方式开设这门课程是有原因的。自由散漫， 只关注在错误的事情上，缺乏引导，这些行为极其危险。有些咒语，有些能量太过强大，单凭一个魔法师无法驾驭。如果失控，它们就会反噬，会杀了你，改变你成为另外的样子 ” - 校长</p>
<p>（ 相比于Brakebills，Hedge witches的行为就太过危险 ）</p>
<p>“ 现在你们要进行测试，来识别你们的能力类型。这样会更好的引导，更好的了解自己，发觉自己的潜能，到达更高的高度 ” - 校长</p>
<p>Alice会折射光线，Kate明显是一个战斗魔法师。Q因为找不到自己的类型而自怨自哀当中。</p>
<hr>
<p>Alice和Q来到无忧小屋</p>
<p>Alice主动找到了Margo</p>
<p>“ 我之前并不是故意表现出这种态度的 ” - Alice</p>
<p>“ 没关系，每个人都有bitch的时候。你身上围绕着一种，不幸下，有一丝愤怒 ” - Margo</p>
<p>“ 我来Brakebills，是为了调查我哥哥的死因 ”  - Alice</p>
<p>Margo找到了五年前的照片，“ 当时Charlie喜欢一个女孩叫做Emily ”</p>
<hr>
<p>Margo和Alice找到了Emily</p>
<p>Emily 看到他俩后想离开，“ Emily, Charlie 是我哥哥 ” 这才叫住了Emily</p>
<p>“ 五年前，我迷恋上了我的教授，为了他我做了一个很坏的事情，我用魔法去整容，但我失败了。我的一半的脸都垮塌了，Charlie当时想帮助我恢复容貌，他将各种魔法混合在一起，在施展的时候，控制不住自己，他全身燃烧了起来，直到不复存在，他变成了Niffen ” - Emily</p>
<p>“ 你们知道什么是Niffen吗？”  - Emily</p>
<p>Alice和Margo对视了一下，Alice知道。</p>
<hr>
<p>“ you loser ,stop sing that ” Penny对Q吼道</p>
<p>“ 我没有唱… ” - Q</p>
<p>“ I know, I mean in your head, in your mind ” - Penny</p>
<p>“ 你观察我的大脑，你个恶心的疯子 ” - Q</p>
<p>“ 你以为我想，别唱了，信不信我捶死你 ” - Penny</p>
<p>Q被Penny吓到连连后退跑了</p>
<p>Penny最近脑袋中经常有各种声音，这让他十分难受。</p>
<p>最后经过测试得知他的魔法类型是穿越者，是很罕见的一种。学校找来了唯一的穿越者老师来授课。</p>
<hr>
<p>之前有Hedgewitch的人借书，是Eliet收费借给他们的。现在Eliet和Q一起去找书回来。因为那本魔法书要繁殖，需要上册。</p>
<p>来到废弃的工厂旁边，走进去，Q见到了正在学习魔法的Julia，他无奈也不敢相信Julia会跟这些业余魔法师混在一起。转身就要走，Julia拦下了他</p>
<p>“ 就这样？就这样走了？ ” - Julia上前质问道</p>
<p>“ 怎么，你想让我说什么？ ” - Q摇着头失望的说</p>
<p>“ 要不说声 对不起？最开始我以为是他们给我的测试，入学之前的测试，结果我等了一周、两周，我以为会有人来给我抹去记忆。然后我才意识到，你根本没有向他们提及我  ” - Julia</p>
<p>“ look，Jules “ - Q</p>
<p>“ 你曾是我最好的朋友 ” - Julia</p>
<p>“ 是的，所以我放手了 ” - Q</p>
<p>“ 什么叫你放手了 ” - Julia</p>
<p>“ Brakebills里的人，他们可以操纵光线，可以读心，可以飞，而你不过是会些把戏 ” - Q</p>
<p>“ 就是这样吗？真实的你？” - Julia</p>
<p>“ 你有想过你一直怎么对我的吗？” - Q</p>
<p>“ 什么，我.. ” - Julia</p>
<p>“ 当然，你永远都是很好的，都是对的，对待你什么都做不到的小Q非常贴心非常友好 “ - Q</p>
<p>“ 不要那么说我，那是你的说法 ” - Julia</p>
<p>“ 你和James不过都是同情我罢了 ” - Q</p>
<p>“ 你为什么要这么说 ” - Julia</p>
<p>“ 因为这是事 Julia ” - Q</p>
<p>“ 这不是事实 ” - Julia</p>
<p>“ 承认吧，承认吧，就承认吧 ” - Q</p>
<p>“ 所以你就要因此惩罚我 ” - Julia</p>
<p>“ 我不知道我还能说些什么，你不能怪我，是你自己没有魔法天赋，你男友知道你在这里吗？你跟一群把魔法当把戏的混混们一起 ” - Q</p>
<p>“ 你在开玩笑吗？这些人… ” - Julia</p>
<p>“ 不要在沦落至此了，我很抱歉，但我认真的，你会付出惨重的代价，清醒点吧 ” - Q</p>
<p>Q的无情和自私让Julia有些伤心</p>
<hr>
<p>“ 你差点就被开除了，下次可不要这么粗心了 ” - Marina高傲的对着Kate说</p>
<p>“ 只是突然出现了个满脸都是飞蛾的怪物，用了什么麻痹人的魔法，我不得已这么做 ” - Kate</p>
<hr>
<p>Niffen学校禁止讨论的话题。她找到了对应的咒语，想让她哥哥复活。她告诉了Quentin，但Q因为担心Alice会做出一些出格的事情，所以提前准备了一个绑定器，可以讲灵魂绑定在这个小盒子里，以便她哥哥出现时失控了，可以有东西控制住他。</p>
<p>夜晚，Alice来到学校喷泉旁边，开始施魔法。她哥哥从温泉中冒出来，全身上下的血管中不时冒出蓝色的火焰，面目凶残。Quentin突然出现叫住Alice</p>
<p>“ 他不是你哥哥，他是Niffen ” - Q喊道</p>
<p>Alice焦急得施展着魔法，急切的想唤起Charlie心中的理智 “ 我知道你在里面Charlie ”。Q想靠近，却被Charlie一挥手仍向了远处。</p>
<p>“ Alice… Don’t…  ” - Q</p>
<p>Alice自己快掌控不住魔法的时候，Q突然拿出那个小盒子喊道 “ cksooids danbyim, I bound you! ”. 只见Charlie的灵魂被吸入小盒子中。</p>
<p>“ 我马上就成功了 ” - Alice有些歇斯底里和绝望的喊道</p>
<p>“ 对不起 Alice ”</p>
<hr>
<p>Alice收拾行李准备离开学院了。</p>
<p>“ 你去哪儿？小可爱 ” - Margo</p>
<p>“ 我要走了，你开心了，少了竞争对手 ” - Alice</p>
]]></content>
      <tags>
        <tag>filler</tag>
      </tags>
  </entry>
  <entry>
    <title>scikit learn</title>
    <url>/2021/10/23/scikit-learn/</url>
    <content><![CDATA[<p>scikit-learn 机器学习的库。其他还有tensorflow、pytorch</p>
<a id="more"></a>

<hr>
<h4 id="Scikit-learn-有六个API大类"><a href="#Scikit-learn-有六个API大类" class="headerlink" title="Scikit-learn 有六个API大类"></a>Scikit-learn 有六个API大类</h4><p><strong>classfication</strong></p>
<p><strong>regression</strong></p>
<p><strong>clustering</strong></p>
<p>分类、回归、聚类</p>
<p><strong>dimensionality reduction</strong></p>
<p><strong>model selection</strong></p>
<p><strong>preprocessing</strong></p>
<p>降维（调优）</p>
<p>模型选择</p>
<p>特征工程（数据预处理）</p>
<hr>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"></span><br><span class="line">iris = load_iris()</span><br><span class="line"></span><br><span class="line">x_train, x_test, y_train, y_test = train_test_split(iris.data, iris.target, test_size=<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 特征化工程</span></span><br><span class="line"></span><br><span class="line">transfer = StandardScaler()</span><br><span class="line">x_train = transfer.fit_transform(x_train)</span><br><span class="line">x_test = transfer.transform(x_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 机器学习(模型训练)</span></span><br><span class="line"></span><br><span class="line">estimator2 = KNeighborsClassifier(n_neighbors=<span class="number">9</span>)</span><br><span class="line">estimator2.fit(x_train,y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模型评估</span></span><br><span class="line">y_predict = estimator2.predict(x_test)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"预测结果为：\n"</span>, y_predict)</span><br><span class="line">print(y_predict == y_test)</span><br></pre></td></tr></table></figure>





<h4 id="Facebook预测地点题"><a href="#Facebook预测地点题" class="headerlink" title="Facebook预测地点题"></a>Facebook预测地点题</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split, GridSearchCV</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data = pd.read_csv(<span class="string">'./FBlocation/train.csv'</span>)</span><br><span class="line">data.head()</span><br><span class="line">data.describe()</span><br><span class="line">data.shape</span><br><span class="line"></span><br><span class="line">facebook_data = data.query(<span class="string">"x&gt;2.0 &amp; x&lt;2.5 &amp; y&gt;2.0 &amp; y&lt;2.5"</span>)</span><br><span class="line"><span class="comment"># facebook_data = data.query("x&gt;2.0 &amp; x&lt;2.5")</span></span><br><span class="line">time = pd.to_datetime(facebook_data[<span class="string">"time"</span>],unit=<span class="string">"s"</span>)</span><br><span class="line">time = pd.DatetimeIndex(time)</span><br><span class="line"></span><br><span class="line">facebook_data[<span class="string">"day"</span>] = time.day</span><br><span class="line">facebook_data[<span class="string">"hour"</span>] = time.hour</span><br><span class="line">facebook_data[<span class="string">"weekday"</span>] = time.weekday</span><br><span class="line"></span><br><span class="line"><span class="comment"># # 去掉签到较少的地方</span></span><br><span class="line"></span><br><span class="line">place_count = facebook_data.groupby(<span class="string">"place_id"</span>).count()</span><br><span class="line">place_count = place_count[place_count[<span class="string">"row_id"</span>]&gt;<span class="number">3</span>]</span><br><span class="line">facebook_data = facebook_data[facebook_data[<span class="string">"place_id"</span>].isin(place_count.index)]</span><br><span class="line">facebook_data.shape</span><br><span class="line"><span class="comment"># print(facebook_data)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 确定特征值和目标值</span></span><br><span class="line">x = facebook_data[[<span class="string">"x"</span>, <span class="string">"y"</span>, <span class="string">"accuracy"</span>, <span class="string">"hour"</span>, <span class="string">"day"</span>, <span class="string">"weekday"</span>]]</span><br><span class="line">y = facebook_data[<span class="string">"place_id"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分割数据集</span></span><br><span class="line">x_train, x_test, y_train, y_test = train_test_split(x, y, random_state=<span class="number">2</span>, test_size=<span class="number">0.25</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 特征工程 标准化</span></span><br><span class="line">transfer = StandardScaler()</span><br><span class="line">x_train = transfer.fit_transform(x_train)</span><br><span class="line">x_test = transfer.fit_transform(x_test)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 机器学习 -- knn+cv</span></span><br><span class="line"><span class="comment"># 实例化一个训练器</span></span><br><span class="line">estimator = KNeighborsClassifier()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 交叉验证,网格搜索实现</span></span><br><span class="line">param_grid = &#123;<span class="string">"n_neighbors"</span>: [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]&#125;</span><br><span class="line">estimator = GridSearchCV(estimator=estimator, param_grid=param_grid, cv=<span class="number">10</span>, n_jobs=<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模型训练</span></span><br><span class="line">estimator.fit(x_train, y_train)</span><br><span class="line"></span><br><span class="line">score_ret = estimator.score(x_test, y_test)</span><br><span class="line">print(<span class="string">"准确率为:\n"</span>, score_ret)</span><br><span class="line"></span><br><span class="line">y_pre = estimator.predict(x_test)</span><br><span class="line">print(<span class="string">"预测值是:\n"</span>, y_pre)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"最好的模型是:\n"</span>, estimator.best_estimator_)</span><br><span class="line">print(<span class="string">"最好的结果是:\n"</span>, estimator.best_score_)</span><br><span class="line">print(<span class="string">"所有的结果是:\n"</span>, estimator.cv_results_)</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>机器学习库</tag>
      </tags>
  </entry>
  <entry>
    <title>迷幻师的困局</title>
    <url>/2021/10/22/%E8%BF%B7%E5%B9%BB%E5%B8%88%E7%9A%84%E5%9B%B0%E5%B1%80/</url>
    <content><![CDATA[<p>“ Stop playing , start living ”</p>
<a id="more"></a>

<hr>
<p>Quentin从病床上起来，面对一切陌生的环境，好像是在一个精神疗养院。</p>
]]></content>
      <tags>
        <tag>fillory</tag>
      </tags>
  </entry>
  <entry>
    <title>numpy学习</title>
    <url>/2021/10/24/numpy%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="Numpy数组运算库"><a href="#Numpy数组运算库" class="headerlink" title="Numpy数组运算库"></a>Numpy数组运算库</h3><p>Numpy（Numerical Python）是一个开源的Python科学计算库，<strong>用于快速处理任意维度的数组</strong>。</p>
<p>Numpy<strong>支持常见的数组和矩阵操作</strong>。对于同样的数值计算任务，使用Numpy比直接使用Python要简洁的多。</p>
<p>Numpy<strong>使用ndarray对象来处理多维数组</strong>，该对象是一个快速而灵活的大数据容器。</p>
<a id="more"></a>

<p><u>ndarray的优势</u>：</p>
<ul>
<li><p>内存块风格</p>
<ul>
<li>list – 分离式存储,存储内容多样化</li>
<li>ndarray – 一体式存储,存储类型必须一样</li>
</ul>
</li>
<li><p>ndarray支持并行化运算（向量化运算）</p>
</li>
<li><p>ndarray底层是用C语言写的,效率更高,释放了GIL</p>
</li>
</ul>
<h4 id="1-ndarray的属性"><a href="#1-ndarray的属性" class="headerlink" title="1 ndarray的属性"></a>1 ndarray的属性</h4><table>
<thead>
<tr>
<th align="center">属性名字</th>
<th align="center">属性解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>ndarray.shape</strong></td>
<td align="center">数组维度的元组</td>
</tr>
<tr>
<td align="center">ndarray.ndim</td>
<td align="center">数组维数</td>
</tr>
<tr>
<td align="center">ndarray.size</td>
<td align="center">数组中的元素数量</td>
</tr>
<tr>
<td align="center">ndarray.itemsize</td>
<td align="center">一个数组元素的长度（字节）</td>
</tr>
<tr>
<td align="center"><strong>ndarray.dtype</strong></td>
<td align="center">数组元素的类型</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过np.array来创建一个ndarray对象</span></span><br><span class="line">score = np.array(</span><br><span class="line">[[<span class="number">80</span>, <span class="number">89</span>, <span class="number">86</span>, <span class="number">67</span>, <span class="number">79</span>],</span><br><span class="line">[<span class="number">78</span>, <span class="number">97</span>, <span class="number">89</span>, <span class="number">67</span>, <span class="number">81</span>],</span><br><span class="line">[<span class="number">90</span>, <span class="number">94</span>, <span class="number">78</span>, <span class="number">67</span>, <span class="number">74</span>],</span><br><span class="line">[<span class="number">91</span>, <span class="number">91</span>, <span class="number">90</span>, <span class="number">67</span>, <span class="number">69</span>],</span><br><span class="line">[<span class="number">76</span>, <span class="number">87</span>, <span class="number">75</span>, <span class="number">67</span>, <span class="number">86</span>],</span><br><span class="line">[<span class="number">70</span>, <span class="number">79</span>, <span class="number">84</span>, <span class="number">67</span>, <span class="number">84</span>],</span><br><span class="line">[<span class="number">94</span>, <span class="number">92</span>, <span class="number">93</span>, <span class="number">67</span>, <span class="number">64</span>],</span><br><span class="line">[<span class="number">86</span>, <span class="number">85</span>, <span class="number">83</span>, <span class="number">67</span>, <span class="number">80</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成0和1的数组</span></span><br><span class="line">ones = np.ones([<span class="number">4</span>,<span class="number">8</span>])</span><br></pre></td></tr></table></figure>

<h4 id="2-浅拷贝和深拷贝"><a href="#2-浅拷贝和深拷贝" class="headerlink" title="2 浅拷贝和深拷贝"></a>2 浅拷贝和深拷贝</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line"><span class="comment"># 从现有的数组当中创建，深拷贝</span></span><br><span class="line">a1 = np.array(a)</span><br><span class="line"><span class="comment"># 相当于索引的形式，并没有真正的创建一个新的</span></span><br><span class="line">a2 = np.asarray(a)</span><br></pre></td></tr></table></figure>

<h4 id="3-生成固定范围数组"><a href="#3-生成固定范围数组" class="headerlink" title="3 生成固定范围数组"></a>3 生成固定范围数组</h4><ul>
<li><p>np.linspace(start,stop,num,endpoint)</p>
<ul>
<li><p>start 开始值 ；stop 终止值</p>
</li>
<li><p>num 要生成的等间隔样例数量，默认为50</p>
</li>
<li><p>endpoint 序列中是否包含stop值，默认为true</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成等间隔的数组</span></span><br><span class="line">np.linspace(<span class="number">0</span>, <span class="number">100</span>, <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">array([  <span class="number">0.</span>,  <span class="number">10.</span>,  <span class="number">20.</span>,  <span class="number">30.</span>,  <span class="number">40.</span>,  <span class="number">50.</span>,  <span class="number">60.</span>,  <span class="number">70.</span>,  <span class="number">80.</span>,  <span class="number">90.</span>, <span class="number">100.</span>])</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>np.arange()</p>
<ul>
<li><p>step – 步长</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.arange(<span class="number">10</span>, <span class="number">50</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>np.logspace()</p>
<ul>
<li>生成以10的N次幂的数据</li>
</ul>
</li>
</ul>
<h4 id="4-生成随机数组"><a href="#4-生成随机数组" class="headerlink" title="4 生成随机数组"></a>4 生成随机数组</h4><p>（ np.random模块 ）</p>
<p><strong>正态分布</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成均值为1.74，标准差为1的正态分布数据，100000000个</span></span><br><span class="line"><span class="comment"># 第三个参数 也可以是（4,5），这样是生成4行5列矩阵</span></span><br><span class="line"></span><br><span class="line">x1 = np.random.normal(<span class="number">1.75</span>, <span class="number">1</span>, <span class="number">100000000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画图看分布状况</span></span><br><span class="line"><span class="comment"># 1）创建画布</span></span><br><span class="line">plt.figure(figsize=(<span class="number">20</span>, <span class="number">10</span>), dpi=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2）绘制直方图</span></span><br><span class="line">plt.hist(x1, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3）显示图像</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>



<p><strong>均匀分布</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成均匀分布的随机数</span></span><br><span class="line"></span><br><span class="line">x2 = np.random.uniform(<span class="number">-1</span>, <span class="number">1</span>, <span class="number">100000000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画图看分布状况</span></span><br><span class="line"><span class="comment"># 1）创建画布</span></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">10</span>), dpi=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2）绘制直方图</span></span><br><span class="line">plt.hist(x=x2, bins=<span class="number">1000</span>)  <span class="comment"># x代表要使用的数据，bins表示要划分区间数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3）显示图像</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>pandas学习</title>
    <url>/2021/10/24/pandas%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h4 id="Pandas学习"><a href="#Pandas学习" class="headerlink" title="Pandas学习"></a>Pandas学习</h4><p>以Numpy为基础，借力Numpy模块在计算方面性能高的优势</p>
<p>基于matplotlib，能够简便画图</p>
<p>独特的数据结构（Series、DataFrame、MultiIndex）</p>
<a id="more"></a>

<hr>
<h4 id="1-Series的创建"><a href="#1-Series的创建" class="headerlink" title="1 Series的创建"></a>1 Series的创建</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入pandas</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">pd.Series(data=<span class="literal">None</span>, index=<span class="literal">None</span>, dtype=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">data：传入的数据，可以是ndarray、list等</span><br><span class="line">index：索引，必须是唯一的，且与数据的长度相等。如果没有传入索引参数，则默认会自动创建一个从<span class="number">0</span>-N的整数索引。</span><br><span class="line">dtype：数据的类型</span><br></pre></td></tr></table></figure>

<h4 id="2-Series的属性"><a href="#2-Series的属性" class="headerlink" title="2 Series的属性"></a><strong>2 Series的属性</strong></h4><p>为了更方便地操作Series对象中的索引和数据，<strong>Series中提供了两个属性index和values</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">color_count = pd.Series(&#123;<span class="string">'red'</span>:<span class="number">100</span>, <span class="string">'blue'</span>:<span class="number">200</span>, <span class="string">'green'</span>: <span class="number">500</span>, <span class="string">'yellow'</span>:<span class="number">1000</span>&#125;)</span><br><span class="line">color_count</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看索引</span></span><br><span class="line">color_count.index</span><br><span class="line"><span class="comment"># 查看值</span></span><br><span class="line">color_count.values</span><br><span class="line"><span class="comment"># 可用索引获取值</span></span><br><span class="line">color_count[<span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<h4 id="3-DataFrame的创建"><a href="#3-DataFrame的创建" class="headerlink" title="3 DataFrame的创建"></a>3 DataFrame的创建</h4><p>DataFrame是一个类似于二维数组或表格(如excel)的对象，既有行索引，又有列索引</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入pandas</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">pd.DataFrame(data=<span class="literal">None</span>, index=<span class="literal">None</span>, columns=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">x1 = pd.DataFrame(np.random.randn(<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用Pandas中的数据结构</span></span><br><span class="line">score_df = pd.DataFrame(score)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造行索引序列</span></span><br><span class="line">subjects = [<span class="string">"语文"</span>, <span class="string">"数学"</span>, <span class="string">"英语"</span>, <span class="string">"政治"</span>, <span class="string">"体育"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造列索引序列</span></span><br><span class="line">stu = [<span class="string">'同学'</span> + str(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(score_df.shape[<span class="number">0</span>])]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加行索引</span></span><br><span class="line">data = pd.DataFrame(score, columns=subjects, index=stu)</span><br></pre></td></tr></table></figure>

<h4 id="4-DataFrame属性"><a href="#4-DataFrame属性" class="headerlink" title="4 DataFrame属性"></a>4 DataFrame属性</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.shape</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">(<span class="number">10</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 行索引</span></span><br><span class="line">data.index</span><br><span class="line"><span class="comment"># 列索引</span></span><br><span class="line">data.columns</span><br><span class="line"><span class="comment"># 直接获取其中array的值</span></span><br><span class="line">data.values</span><br><span class="line"><span class="comment"># 转置</span></span><br><span class="line">T</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不补充参数，默认5行。填入参数N则显示前N行</span></span><br><span class="line">data.head(<span class="number">5</span>)</span><br><span class="line">data.tail(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新添加索引123456</span></span><br><span class="line">data.reset_index(drop = <span class="literal">True</span> / Fales)</span><br><span class="line"><span class="comment"># 重新设置其中一列作为索引</span></span><br><span class="line">data.set_index()</span><br></pre></td></tr></table></figure>

<h4 id="5-文件读写"><a href="#5-文件读写" class="headerlink" title="5 文件读写"></a>5 文件读写</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 读取，查看结果</span></span><br><span class="line">pd.read_csv(<span class="string">"./data/test.csv"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选取10行数据保存,便于观察数据</span></span><br><span class="line">data[:<span class="number">10</span>].to_csv(<span class="string">"./data/test.csv"</span>, columns=[<span class="string">'open'</span>])</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>matplotlib学习</title>
    <url>/2021/10/24/matplotlib%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="Matplotlib画图"><a href="#Matplotlib画图" class="headerlink" title="Matplotlib画图"></a>Matplotlib画图</h3><a id="more"></a>

<h4 id="1-matplotlib-pyplot模块"><a href="#1-matplotlib-pyplot模块" class="headerlink" title="1 matplotlib.pyplot模块"></a>1 matplotlib.pyplot模块</h4><p>matplotlib.pytplot包含了一系列类似于matlab的画图函数。</p>
<p><u>画各种图，折线图、统计图、散点图、饼状图、柱状图等利用不同的函数</u></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">各种图的API：</span><br><span class="line"></span><br><span class="line">plt.plot(x,y) 折线图</span><br><span class="line">plt.scatter(x, y) 散点图</span><br><span class="line">plt.bar(x, width, align=<span class="string">'center'</span>) 柱状图</span><br><span class="line">plt.hist(x,bins) 直方图 <span class="comment"># x是数据  bins是多少一组</span></span><br><span class="line">plt.pie(x, labels=,autopct=,colors) 饼状图</span><br><span class="line">Parameters:  </span><br><span class="line">x:数量，自动算百分比</span><br><span class="line">labels:每部分名称</span><br><span class="line">autopct:占比显示指定%<span class="number">1.2</span>f%%</span><br><span class="line">colors:每部分颜色</span><br></pre></td></tr></table></figure>



<h4 id="2-画图流程"><a href="#2-画图流程" class="headerlink" title="2 画图流程"></a>2 画图流程</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.创建画布</span></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">10</span>), dpi=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.绘制折线图</span></span><br><span class="line">plt.plot([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> ,<span class="number">7</span>], [<span class="number">17</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">15</span>,<span class="number">11</span>,<span class="number">11</span>,<span class="number">13</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.显示图像</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画出温度变化图</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 0.准备x, y坐标的数据</span></span><br><span class="line">x = range(<span class="number">60</span>)</span><br><span class="line">y_shanghai = [random.uniform(<span class="number">15</span>, <span class="number">18</span>) <span class="keyword">for</span> i <span class="keyword">in</span> x]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.创建画布</span></span><br><span class="line">plt.figure(figsize=(<span class="number">20</span>, <span class="number">8</span>), dpi=<span class="number">80</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.绘制折线图</span></span><br><span class="line"></span><br><span class="line">plt.grid(<span class="literal">True</span>, linestyle=<span class="string">'--'</span>, alpha=<span class="number">0.5</span>) <span class="comment"># 添加网格</span></span><br><span class="line">plt.plot(x, y_shanghai)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.显示图像</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>



<h4 id="3-中文显示问题解决"><a href="#3-中文显示问题解决" class="headerlink" title="3 中文显示问题解决"></a>3 中文显示问题解决</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pylab <span class="keyword">import</span> mpl</span><br><span class="line"><span class="comment"># 设置显示中文字体</span></span><br><span class="line">mpl.rcParams[<span class="string">"font.sans-serif"</span>] = [<span class="string">"SimHei"</span>]</span><br><span class="line"><span class="comment"># 设置正常显示符号</span></span><br><span class="line">mpl.rcParams[<span class="string">"axes.unicode_minus"</span>] = <span class="literal">False</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>yfd实习记录 3</title>
    <url>/2021/08/02/yfd%E5%AE%9E%E4%B9%A0%E8%AE%B0%E5%BD%953/</url>
    <content><![CDATA[<p>从2021年6.3 - 7.15</p>
<a id="more"></a>

<p>“ 我都不愿意把自己的这段实习经历写在履历当中 ” - 知乎某网友</p>
<p>我也一样，事实上，本身就是签的劳务合同，没有什么法律效应，而且对我本专业也并无什么作用。我写这篇日志是因为我遇到了我觉得好的人，不论是工作上的虚情假意还是什么，其实除开工作，大家私底下都是正正常常的人，有着正正常常的感情。</p>
<p>先是培训的9天，我记得培训的9天，的确很无聊，而且就是在慢慢向我们暴露公司的运作情况，我们入职的定位。基本上就是无条件加班而已，初入职场其实我什么都不懂，也有一股冲劲，所以对于加班的事情，我是可以接受的。然后就是帮助我的小组朋友们，大家都很友好，还有和我一起进入同一组的思思老师。</p>
<p>怎么说，就是我们其实可能比在职的那些伙伴们更早体会到双减的到来，毕竟在入职之前已经被恶心了一次了。但是进入公司过后，我发现他们中其实很少有人知道公司有这样的变动。我其实摸不清楚大家对这份工作的依赖程度，毕竟工资的确比一般传统行业要高，而且有几位已经干了大半年了，他们的经验什么的都是非常丰富的。所以我并没有明着说，到是有个也才刚入职2个月的小伙伴说了句“ 我就等着公司把我开除了，我要去学面包烹饪 ”，我恍然大悟，其实面对这种作息时间十分不规范的公司，我们并没有多少的责任感去做好工作上的每件事情的，而且我们的选择其实很多的。我总是觉得人的职业很多很广泛，但当放在自己身上，总是想要尽力弄好每件事情，而忘记了其实当这个工作并不是自己长久打算的时候，就要学会划水划水。</p>
<hr>
<p>2021.10.20</p>
<p>最终我在7月15号的时候离职。因为前一天我发高烧了。长时间的工作说话导致我喉咙十分严重，并且引起高烧反复。现在回想起，其实我那段时间很多焦虑都是无用的。我总是对未到来的事情感到焦虑不已，有些人有拖延症，而我简直是把好多事情提前了一长段时间，从而搞得我十分焦虑，不能享受当下的悠闲。比如现在可是周日的下午，我本可以刷着剧，喝着奶茶，吃着薯片，或者我也可以去外面玩，到处逛逛。我现在的担忧其实很多都是无用的。这句话应该会是我后来三年会经常提醒自己的话。还有一点就是，身体健康，身心健康，干净整洁才是最重要的，而不是局限于某一件衣服、穿搭之类的。</p>
]]></content>
      <categories>
        <category>实习</category>
      </categories>
      <tags>
        <tag>实习</tag>
      </tags>
  </entry>
  <entry>
    <title>yfd实习记录 2</title>
    <url>/2021/05/31/yfd%E5%AE%9E%E4%B9%A0%E8%AE%B0%E5%BD%95-2/</url>
    <content><![CDATA[<p>体检 + 5.28 所发生的事情</p>
<a id="more"></a>

<h3 id="pt1-体检"><a href="#pt1-体检" class="headerlink" title="pt1 体检"></a>pt1 体检</h3><p>几天前，去沙坪坝爱康国宾医院体检，体检完成后，一健传回hr，体检费用140。</p>
<p>体检就是常规的体检。</p>
<h3 id="pt2-5-28事件"><a href="#pt2-5-28事件" class="headerlink" title="pt2 5.28事件"></a>pt2 5.28事件</h3><p>5月28日下午4点多，微信的入职群和租房群被解散，然后接到一个重庆那边的电话，说猿辅导业务已满，暂停招人（借口），让我自愿放弃入职。当时我就十分的气愤，拿到offer以后，公司要求的什么，我都做了，什么都准备好了，就在入职前几天，先把微信群解散，再一个个打电话引导性的让我们放弃入职，我当时就坚决不自愿放弃入职。公司单方面毁offer，造成我的时间和金钱的损失谁来赔偿？让我相互理解？真的狗！</p>
<p>后来有个和我一起面试通过的小姐姐加了我微信，她是在小红书上看到的。再后来微博上面有几个人在发微博指控，就知道了是全国的猿辅导都在毁offer，hr一律不回复（有些还是回了，有些没回的可能也被开了）。后来加了全国的猿辅导维权群，里面有人提议打电话到总部去申述。第二天早上我就打电话过去申述，她那边询问我的情况和我的诉求，我就说能入职就入职，但我不放弃入职的机会！下午的时候北京那边又打来电话，又询问我的诉求，我也是说，因为一切都准备好了，这样一通电话就让我放弃入职是不可能的！欺负大学生吗？我说能入职尽量入职，到6月3号的时候，如果实在不能入职，我这边也在找另外的工作。</p>
<p>当天下午，收到第一次打电话让我放弃入职的那个电话号码打来，就说可以6月3号入职，说是岗位稀缺（借口），让我不要给其他人说可以入职的事情。</p>
<p>（因为出了这种事，所有的打工人都是受害者，所以打电话时我只是控诉了公司的这种不诚信，不透明的恶劣方式，其余的也表示无奈）</p>
<h3 id="pt3-气愤–冷静"><a href="#pt3-气愤–冷静" class="headerlink" title="pt3 气愤–冷静"></a>pt3 气愤–冷静</h3><p>28号上午的时候还在举行双选会，28号下午就停止招人，明显的不是因为岗位需求减少的原因，而是有什么文件下达，这种国家层面的要求我们谁也不能说什么。所以在挂断第一通电话过后，回想了一下，我又打了过去，就仔细说明了我的诉求：能正常入职就正常入职，不能那就等到6月3号再说。29号 上午的时候，我们学校居然还有人在发猿辅导招聘的广告，我加了QQ，他说可以把简历给他，我就说了我的情况，他就不说话了，然后boss直聘上还在招人，还有在线下举办招聘会的情况，我就想说这是混乱了吗？我不想搞什么阴谋论。</p>
<p>那个群里面真的是鱼龙混杂，居然还有人说 “与其在这维权，不如抓紧时间找下一份工作”，这种人什么成分一目了然。被毁offer的甚至有春招过来的，推掉其他很多offer过来的，错过了黄金春招，然后听信一句不如抓紧时间？？</p>
<p>28号-29号，因为房租的问题，我必须在那边找到实习或者兼职，我也投了作业帮、清北教育等，但这个形势下，估计也不会招人了。我在boss直聘上看了看其他职位，有工资不高，但比较轻松的。（这算是当时以及现在的备用选项）。</p>
<h3 id="pt4-在线教育"><a href="#pt4-在线教育" class="headerlink" title="pt4 在线教育"></a>pt4 在线教育</h3><p>这种在线教育真的，在国家的红线徘徊，谁也想不到哪一天会崩塌，然后失业。只能说，冲！考公务员！</p>
<h3 id="pt5-打工人真难"><a href="#pt5-打工人真难" class="headerlink" title="pt5 打工人真难"></a>pt5 打工人真难</h3><p>今天5月31号，我就想尽早入职，然后培训。毕竟培训期间是有工资的，即使说培训完过后把我开除，这下我也有准备去找下家。</p>
]]></content>
      <categories>
        <category>实习</category>
      </categories>
      <tags>
        <tag>实习</tag>
      </tags>
  </entry>
  <entry>
    <title>vue快速复习</title>
    <url>/2021/11/06/vue%E5%BF%AB%E9%80%9F%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<p>vue基础快速复习</p>
<a id="more"></a>

<h3 id="一、vue基础"><a href="#一、vue基础" class="headerlink" title="一、vue基础"></a>一、vue基础</h3><h4 id="vue简介"><a href="#vue简介" class="headerlink" title="vue简介"></a>vue简介</h4><ol>
<li><p>javascript框架，比jquery库更强大；</p>
</li>
<li><p>更简单的DOM操作；（以前通过id获取元素，操作页面）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'btn'</span>).addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="string">'haha'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>响应式数据驱动</p>
</li>
</ol>
<h4 id="第一个vue程序"><a href="#第一个vue程序" class="headerlink" title="第一个vue程序"></a>第一个vue程序</h4><ol>
<li><p>选择环境：开发环境：学习阶段使用</p>
<p>​                    生产环境：mini版，更轻</p>
</li>
<li><p>声明式渲染</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &#123;&#123;&#125;&#125; 是插值表达式--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line">    </span><br><span class="line"><span class="actionscript">    el:<span class="string">"#app"</span>,</span></span><br><span class="line">    data:&#123;</span><br><span class="line"><span class="actionscript">        message:<span class="string">"哈哈"</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中</p>
<p>el：挂载点（不要挂载到html、body元素上，也不要挂载到单标签上；要挂载到双标签上&lt;p&gt;&lt;/p&gt;、&lt;div&gt;&lt;/div&gt;）</p>
<p>data：数据对象</p>
<p>methods：方法</p>
</li>
</ol>
<h3 id="二、本地应用"><a href="#二、本地应用" class="headerlink" title="二、本地应用"></a>二、本地应用</h3><h4 id="vue指令"><a href="#vue指令" class="headerlink" title="vue指令"></a>vue指令</h4><p>添加到html标签中，相当于给html标签；元素增加一个属性</p>
<ol>
<li><p>内容绑定、事物绑定</p>
<ul>
<li><p><strong>v-text</strong>：只会解析为文本；改变里面<u>所有</u>的文本</p>
</li>
<li><p><strong>v-html</strong>：内容中有html结构，会被解析为标签</p>
</li>
<li><p><strong>v-on</strong>：绑定事件,可简写为@；@click = “”; @mouseenter=””;</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"单击"</span> @<span class="attr">click</span>=<span class="string">"btn1"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line">    </span><br><span class="line"><span class="actionscript">    el:<span class="string">"#app"</span>,</span></span><br><span class="line">    data:&#123;</span><br><span class="line"><span class="actionscript">        message:<span class="string">"哈哈"</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line"><span class="actionscript">        btn1:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.message = <span class="string">"嘻嘻嘻嘻！"</span>,	<span class="comment">// 方法内部通过this，访问data中的数据</span></span></span><br><span class="line"><span class="actionscript">           	alert(<span class="string">"单击，我被弹出！"</span>)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>显示切换、属性绑定</p>
<ul>
<li><p><strong>v-show</strong>=“true/false”；布尔值；通过操纵样式；display:none；<strong>会导致重绘</strong></p>
<p>v-show=”isShow” ；在vue实例中的data数据对象里面写 isShow:false</p>
</li>
<li><p><strong>v-if=“表达式/数据对象”</strong> ； 根据表达式的真假，切换元素的显示和隐藏（操作dom元素）；<strong>会导致重绘和重排</strong></p>
</li>
<li><p><strong>v-bind</strong>；设置单个元素的属性（比如 src title class）</p>
<p>比如说给图片增加属性就用  v-bind : src = “数据对象”；然后v-bind可以省略；:src,  <u>:title</u>(<u>鼠标悬停显示出信息</u>), :class</p>
</li>
</ul>
</li>
<li><p>列表循环、表单元素绑定</p>
<ul>
<li><p><strong>v-for</strong>；循环生成列表结构；通常和<u>数组</u>结合使用</p>
<p>v-for=”(item,index) in arr”  <u>index 是索引</u>；其中arr也可以是复杂数组对象；item.name、item.age去访问</p>

</li>
<li><p>*<em>v-on *</em>补充（事件）</p>
<p>可以传参；@click=”add(2,5)”；后面对应方法加形参；@keyup.enter=“sayHi”；敲回车键时会执行sayHi方法</p>
</li>
<li><p><strong>v-model</strong></p>
<p>双向数据绑定，设置<strong>表单元素</strong>的值； input 、select 、checkbox 、textarea</p>
<p>&lt;input type=”text” v-model=”msg”&gt;; data:{ msg:”双向绑定的数据” } </p>
</li>
</ul>
</li>
</ol>
<h4 id="案例：记事本"><a href="#案例：记事本" class="headerlink" title="案例：记事本"></a>案例：记事本</h4><p>v-for 渲染数组列表；根据数组形成列表结构</p>
<p>v-model 获取用户输入的数据；</p>
<p>v-on 绑定事件，@keyup.enter=”add”回车，add方法中新增数据；</p>
<p>​                            删除数据：@click：”remove(index)”；方法中写：this.lists.splice(index,1)</p>
<h3 id="三、网络应用"><a href="#三、网络应用" class="headerlink" title="三、网络应用"></a>三、网络应用</h3><p>ajax、promise 、.then、 axios、await、async</p>
<p>promise是js的内置对象，为了解决回调嵌套太多导致的回调地狱问题。</p>
<p>new promise；实例化promise对象，然后通过.then方法得到其返回的结果</p>
<p><strong>axios是一个专门发起请求的库</strong>，axios发起请求，返回的就是一个promise对象，也就可以在后面.then拿到其结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// get 用params携带参数</span></span><br><span class="line"><span class="comment">// post 用data传参数；会携带到body对象中去</span></span><br><span class="line"></span><br><span class="line">axios(&#123;</span><br><span class="line">  method:<span class="string">'GET'</span></span><br><span class="line">  url:<span class="string">"http://xxxx"</span>,</span><br><span class="line">  params:&#123;</span><br><span class="line">  	id:<span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过async await 和.then方式 都可以拿到promise对象中的数据。因为axios请求返回值就是promise对象，所以可以用await修饰</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'btn'</span>).addEventListener(<span class="string">'click'</span>,<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> axios(&#123;</span><br><span class="line">                      method:<span class="string">'POST'</span></span><br><span class="line">                      url:<span class="string">"http://xxxx"</span>,</span><br><span class="line">                      data :&#123;</span><br><span class="line">                        name:<span class="string">'zs'</span>,</span><br><span class="line">                        age:<span class="string">'19'</span></span><br><span class="line">                      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续优化</span></span><br><span class="line"><span class="comment">// &#123;data:res&#125; = &#123;data,param,aa,ccxx,...&#125; 对一大群数据中，结构出自己需要的，并且更名为res</span></span><br><span class="line"><span class="comment">// 解构赋值，是因为axios给promise的数据外面又套了一层，共有6个大类对象，我们请求的后端数据是在data中的</span></span><br><span class="line"><span class="comment">// 而这个data 又可能与我们在后端写的data重名，导致后面获取真正数据时出现data.data，所以我们更名为res</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'btn'</span>).addEventListener(<span class="string">'click'</span>,<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;<span class="attr">data</span>:res&#125; = <span class="keyword">await</span> axios(&#123;</span><br><span class="line">                      method:<span class="string">'POST'</span></span><br><span class="line">                      url:<span class="string">"http://xxxx"</span>,</span><br><span class="line">                      data :&#123;</span><br><span class="line">                        name:<span class="string">'zs'</span>,</span><br><span class="line">                        age:<span class="string">'19'</span></span><br><span class="line">                      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(res.data),</span><br><span class="line">    <span class="built_in">console</span>.log(res.status)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// axios还有 axios.get('http://xxxx',params...) 这种写法 .get .post</span></span><br></pre></td></tr></table></figure>

<img src="/2021/11/06/vue%E5%BF%AB%E9%80%9F%E5%A4%8D%E4%B9%A0/1.png" class>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
</search>
